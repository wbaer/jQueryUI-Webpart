/// <reference types="es6-promise" />
import { DisplayMode } from '@microsoft/sp-core-library';
import { IClientSideWebPartManifest } from '@microsoft/sp-module-interfaces';
import IWebPartData from './IWebPartData';
import IWebPartHost from './IWebPartHost';
import IWebPartManagerContext from './IWebPartManagerContext';
import { IPropertyPaneControl } from '../propertyPane/propertyPaneControl/IPropertyPaneControl';
import { PropertyPaneState } from '../propertyPane/propertyPane/PropertyPaneDefinitions';
/**
 * The ClientSideWebPartManager is expected to be the public interface to client side web parts. Each
 * host is expected to create an instance of this class and manage loading of all web parts in that host
 * through that one instance. e.g. On one page, if there are multiple Canvas objects, each one could have
 * one instance of this class. If the page hosts web parts without the Canvas, then the page can have an
 * instance of this class. Overall this class is expected to provide the following purpose:
 *
 *    - Orchestrates loading of one or more web parts in a host.
 *    - It takes care of loading web part dependencies asynchronously. Each web part loads completely
 *      independently of the other web parts in the host.
 *    - Keep a reference to all the loaded web parts and help provide bulk operations on the web parts.
 *    - Help manage memory leak type issues in one place.
 *    - Integrate the web parts with the PropertyPane and other external entities.
 *    - Help troubleshoot web parts during escalations.
 *
 * @internal
 */
export default class ClientSideWebPartManager {
    /**
     * Reference to the PropertyPane controller.
     * Note, all instances of ClientSideWebPartManager share the same PropertyPane controller.
     */
    private static _propertyPaneController;
    /**
     * Reference to the instances of all ClientSideWebPartManager instances in the app.
     */
    private static readonly _webPartManagerList;
    /**
     * Dictionary of all the active web parts in this insance of the manager.
     */
    private _webparts;
    /**
     * Host for this instance of the web part manager.
     * Note, at the current time there is no support for multiple hosts and the host is not expected to change.
     */
    private _host;
    private _logSource;
    /**
     * Timer to mark the canvas dirty.
     */
    private _dirtyBitTimer;
    /**
     * Event aggregator instance scoped to this web part manager instance.
     */
    private _eventAggregator;
    /**
     * Web part status renderer instance scoped to this web part manager instance.
     */
    private _statusRenderer;
    /**
     * Page context reference.
     */
    private _pageContext;
    /**
     * Promise for the async call to get edit-time web parts.
     */
    private _toolboxManifestsPromise;
    /**
     * Initialize the ClientSideWebPartManager.
     *
     * @param host - Reference to the host. A web part host is a component that is deemed capable of hosting a web
     * part. Any component that implements the IWebPartHost is allowed to host a web part.
     */
    constructor(host: IWebPartHost);
    /**
     * Load a web part in the provided DOM element. Does the following steps
     *
     *    - Validate params.
     *    - Validate the web part manifest.
     *    - Perform an async import of the web part modules from the provided manifest.
     *    - Instantiate the web part object.
     *    - Perform web part lifecycle events like deserialization, initalization and rendering.
     *    - If an error happens during any of the above steps, catch the error and log it.
     *
     * @param context - web part manager context.
     */
    loadWebPart(context: IWebPartManagerContext): Promise<void>;
    /**
     * Set a IPropertyPaneControl object into the set of the Client Side Web Part Manager's
     * managed web parts.
     *
     * @param id - A unique instance id.
     * @param control - A control that implements the minimum subset of IClientSideWebPartInternal
     *   needed to utilize the Property Pane.
     *
     * @internal
     */
    setPropertyPaneControl(id: string, control: IPropertyPaneControl): void;
    /**
     * Fetch web part manifests. This makes a REST call to load the current site's web parts into the module loader.
     */
    fetchWebPartManifests(): Promise<void>;
    /**
     * Get list of active web part manifests.
     *
     * @returns - array of manifests.
     */
    getWebPartManifests(): IClientSideWebPartManifest<any>[];
    /**
     * Set the display mode of the specified web part. If no web part id is specified, switch mode of all web parts.
     * If the display mode passed is same as the current mode, no change is applied.
     *
     * @param displayMode - the new DisplayMode.
     * @param instanceId - instance id of the web part.
     */
    setDisplayMode(displayMode: DisplayMode, instanceId?: string): void;
    /**
     * Serialize the specified web part. If no web part is specified, serialize all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    serialize(instanceId?: string): Map<string, IWebPartData>;
    /**
     * Dispose the specified web part. If no web part is specified, dispose all web parts.
     *
     * @param instanceId - instance id of the web part.
     */
    dispose(instanceId?: string): void;
    tryGeneratePreviewImageUrl(instanceIds?: string[]): string | undefined;
    /**
     * Set the property pane state which helps configuring the web part.
     *
     * @param instanceId - web part instance id.
     * @param propertyPaneState - indicates in what state the PropertyPane should be.
     * @param renderedByWebPart - is the property pane rendered by a web part and not by Canvas or any other source.
     */
    setPropertyPaneState(instanceId: string, propertyPaneState?: PropertyPaneState, renderedByWebPart?: boolean): void;
    /**
     * Returns true if the current property pane source is a web part and not the Canvas or any other source.
     */
    isPropertyPaneRenderedByWebPart(): boolean;
    /**
      * Method to handle the web part delete action from the host. There is a key distinction between delete and dispose.
      * Delete implies that the web part has been deleted from the page and the web part should dispose all the server
      * side or other external resources attached to the web part. Dispose implies that an in-place navigation is
      * happening and the web part manager should delete the web part from its cache.
      *
      * @param instanceId - instance id of the webpart which is deleted.
      */
    onWebPartDelete(instanceId: string): void;
    /**
     * Render an error message in the web part container div.  Also logs the error message to the IWebPartHost logger.
     */
    renderError(domElement: HTMLElement, error: Error): void;
    /** ------------------- PRIVATE ------------------- **/
    /**
     * Workaround for a server issue - disambiguate manifest locales if they haven't already been disambiguated
     * (VSO#243888) tracks fixing this issue.
     */
    private _disambiguateWebPartManifestLocales(manifests);
    /**
     * Validate and process input parameters.
     */
    private _validateInput(context);
    /**
     * Validate the web part manifest.
     */
    private _validateManifest(manifest, mode, webPartTag);
    /**
     * Execute the provided callback for the list of provided web part ids. If no list if provided,
     * execute the callback on all web parts.
     */
    private _executeForIdsOrAll(instanceIds, cb);
    /**
     * Generate web part context.
     */
    private _getWebPartContext(context);
    private _instanceOfBase(wpi);
    private _getLoadedModuleList(moduleLibrary);
    /**
     * This is a temporary implementation of updating the host that a web part has updated properties.
     * Currently we run a timer that regularly checks for updated properties and raises the dirty bit
     * handler to the host. todo (VSO SPPPLAT#200728) tracks fixing this scenario in a better way.
     */
    private _startDirtyBitTimer(mode);
    /**
     * Creates a new extra data object for writing successes to QosMonitor.
     */
    private _createSuccessExtraData(alias, isInternal, manifestId);
    /**
     * Creates a new extra data object for writing unexpected failures to QosMonitor.
     */
    private _createUnexpectedFailureExtraData(alias, instanceId, isInternal, manifestId);
    /**
     * Creates a new QosMonitor with a scenario name specific to the web part type.
     */
    private _createLoadQosMonitor(manifest);
    /**
     * Create the web part tag. Web part tag is a unique tag per web part instance and is used for logging and telemetry.
     */
    private _createWebPartTag(manifest, instanceId);
    private _deleteWebPart(id);
    /**
     * Get web part manifest instance from manifest. Promotes the pre-configured entries.
     */
    private _getManifestInstance(context);
    /**
     * If non-non parameter passed, return array else return undefined.
     */
    private _getArrayOrUndefined(instanceId?);
    private _initialzeOnResizeEventHandler();
    /**
     * Window onresize event handler.
     */
    private _onContainerResize();
    /**
     * Listener for window post message that the property pane has been toggled open/close.
     *
     * @todo(SPPPLAT Bug #299413): Implement missing schema for property pane post messages
     */
    private _onPropertyPaneToggled(event);
    /**
    * Handles property pane configuration change callback.
    * The callback is only triggered on the ClientSideWebPartManager that manages the currently configured WebPart.
    * Except for the PropertyPaneWebPartsSwitched event, where all the ClientSideWebPartManagers' callbacks are trigged.
    */
    private _onWebPartConfigurationChange(event, data?);
}
