/**
 * @file writePackage.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Writes a package xml object to disk, in both raw and zipped format
 */
"use strict";
/* tslint:disable:no-any */
var mkdirp = require("mkdirp");
var path = require("path");
var rmdir = require("rimraf");
var fs = require("fs");
var JSZip = require("node-zip");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var utilities_1 = require("../utilities");
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */
function writePackage(solution, config) {
    var zip = new JSZip();
    return cleanRawPackageDirectory(config)
        .then(function () { return Promise.all([
        writeODCFile(solution.manifest, config, zip),
        writeXmlFile(solution.relationships, config, zip),
        writeXmlFile(solution.contentTypesXml, config, zip),
        writeIcon(solution.icon, config, zip)
    ]
        .concat(solution.customFiles.map(function (customFile) { return writeXmlFile(customFile, config, zip); }))
        .concat(solution.features.map(function (feature) { return writeFeature(feature, config, zip); }))); })
        .then(function () {
        return writeFile(config.paths.zippedPackage, zip.generate({ base64: false, compression: 'DEFLATE' }), 'binary');
    });
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = writePackage;
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */
function cleanRawPackageDirectory(config) {
    return new Promise(function (complete, reject) {
        rmdir(config.paths.debugDir, function (error) {
            if (error) {
                reject(error);
                return;
            }
            gulp_core_build_1.log("Cleaned " + config.paths.debugDir);
            complete();
        });
    });
}
exports.cleanRawPackageDirectory = cleanRawPackageDirectory;
function writeFeature(feature, config, zip) {
    return Promise.all([
        writeODCFile(feature, config, zip),
        writeXmlFile(feature.config, config, zip)
    ]
        .concat(feature.assets.elementFiles.map(function (asset) { return writeXmlFile(asset, config, zip); }))
        .concat(feature.assets.elementManifests.map(function (asset) { return writeXmlFile(asset, config, zip); }))
        .concat(feature.assets.upgradeActions.map(function (asset) { return writeXmlFile(asset, config, zip); }))
        .concat(feature.components.map(function (component) { return writeXmlFile(component, config, zip); })));
}
exports.writeFeature = writeFeature;
/**
 * Write the app icon related files: The icon file itself, and the config.xml
 * If there is no icon it does nothing.
 * If the icon path is invalid, it throws an error.
 */
function writeIcon(icon, config, zip) {
    if (icon) {
        var filepath = path.join(config.paths.packageDir, icon.path);
        if (fs.statSync(filepath).isFile()) {
            return Promise.all([
                readFile(filepath).then(function (data) { return writeFileToPath(icon.path, data, config, zip); }),
                writeXmlFile(icon.config, config, zip),
                writeXmlFile(icon.relationships, config, zip)
            ]);
        }
        else {
            throw new Error("Icon with path \"" + icon.path + "\" was not found.");
        }
    }
}
exports.writeIcon = writeIcon;
function writeXmlFile(file, config, zip) {
    return writeFileToPath(file.filename, file.xml, config, zip);
}
exports.writeXmlFile = writeXmlFile;
function writeODCFile(file, config, zip) {
    return Promise.all([
        writeFileToPath(file.filename, file.xml, config, zip),
        writeXmlFile(file.relationships, config, zip)
    ]);
}
exports.writeODCFile = writeODCFile;
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */
function writeFileToPath(filename, contents, config, zip) {
    var filepath = path.join(config.paths.debugDir, filename);
    return utilities_1.serial([
        function () { return ensureDirectory(filepath); },
        function () { return writeFile(filepath, contents); },
        function () { return addFileToZip(filename, contents, zip); }
    ]);
}
/**
 * Returns a promise which ensures a directory on disk exists using mkdirp
 */
function ensureDirectory(filepath) {
    return new Promise(function (complete, reject) {
        var directories = filepath.split(path.sep);
        directories.pop();
        var pathToFile = directories.join(path.sep);
        mkdirp(pathToFile, function (err) {
            if (err) {
                reject(err);
                return;
            }
            complete();
        });
    });
}
/**
 * Wraps fs.readFile in a promise
 */
function readFile(filename, flag) {
    return new Promise(function (complete, reject) {
        fs.readFile(filename, function (error, data) {
            if (error) {
                reject(error);
                return;
            }
            complete(data);
        });
    });
}
/**
 * Wraps fs.writeFile in a promise
 */
function writeFile(filename, contents, flag) {
    return new Promise(function (complete, reject) {
        fs.writeFile(filename, contents, flag, function (error) {
            if (error) {
                reject(error);
                return;
            }
            gulp_core_build_1.log("Created file: " + filename);
            complete();
        });
    });
}
/**
 * Adds a file to a zip package
 */
function addFileToZip(filepath, content, zip) {
    return new Promise(function (complete, reject) {
        var directories = filepath.split(path.sep);
        var file = directories.pop();
        for (var _i = 0, directories_1 = directories; _i < directories_1.length; _i++) {
            var dir = directories_1[_i];
            zip = zip.folder(dir);
        }
        zip.file(file, content);
        complete();
    });
}

//# sourceMappingURL=writePackage.js.map
