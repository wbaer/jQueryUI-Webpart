/// <reference types="node" />
import * as gulp from 'gulp';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { IComponentModuleConfiguration, IPathModuleConfiguration, ILocalizedPathModuleConfiguration } from '@microsoft/sp-module-interfaces';
import OdspGulpTask from './../OdspGulpTask';
import { IConfigEntry, IBundleEntry } from './../configureWebpack/ConfigureWebpackTask';
export declare const externalsRegex: RegExp;
export interface ICopyAssetsTaskConfig {
    /**
     * Path to where assets should be staged for deployment to CDN during a production build
     */
    deployCdnPath?: string;
    /**
     * Extensions of webpack-produced assets to ignore
     */
    extsToIgnore?: string[];
}
export interface IWebpackStatsObject {
    assets: IWebpackAsset[];
    chunks: IWebpackChunk[];
    modules: IWebpackModule[];
}
export interface IWebpackAsset {
    name: string;
    chunks: number[];
}
export interface IWebpackChunk {
    entry: boolean;
    id: number;
    files: string[];
    names: string[];
    hash: string;
    size: number;
}
export interface IWebpackModule {
    name: string;
    chunks: number[];
}
export interface IDeployEntry {
    manifest: IClientSideComponentManifest;
    bundleEntry: IBundleEntry;
    configEntry: IConfigEntry;
    entryName?: string;
    debugModules?: IDeployModules;
    productionModules?: IDeployModules;
}
export interface IDeployModules {
    entryModuleId?: string;
    localizedPathModules: Map<string, ILocalizedPathModuleConfiguration>;
    pathModules: Map<string, IPathModuleConfiguration>;
    componentModules: Map<string, IComponentModuleConfiguration>;
}
/**
 * Prepares deployment to CDNs and the manifest server through onedrive-buildtools.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
export declare class CopyAssetsTask extends OdspGulpTask<ICopyAssetsTaskConfig> {
    name: string;
    taskConfig: ICopyAssetsTaskConfig;
    loadSchema(): Object;
    executeTask(gulp: gulp.Gulp, completeCallback: (error?: string) => void): NodeJS.ReadWriteStream;
    private _copyStrings(stringsCopyCallbackMap, tasks);
    private _processEntry(deployEntry, shouldPrepareProductionDeployment, stringsModuleId, bundleTemporaryNameRegex, tasks);
    private _processExternals(externalModules, tasks);
    private _processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
    private _renameWithHash(gulpStream, getFilename, filenameCallback);
    private _getRenameTransformFunction(getFilename, filenameCallback);
    private _selectDefaultLocaleForResource(paths, externalName);
    private _fillLocalizedPaths(paths, defaultLocale, moduleConfig);
    private _fillLocalizedPath(path, locale, defaultLocale, moduleConfig);
    /**
     * For webpack entries that are imported using SystemJS, the script is injected into the page, but
     * the element is removed before the entry is initialized. Webpack requires a public path be set,
     * and because we don't have a single host location, we need to set the public path dynamically.
     * The public path is set when the entry is initialized, and in certain cases (like in development),
     * it will look at the script tags on the page to determine what the root path is.
     *
     * We can append a small bit of code to the end of the entry's JS file that will mitigate this issue
     * by maintaining a registry of scripts that have been injected onto the page, so the public path
     * can be correctly set even if the script element that pointed to the entry's JS file has been removed
     * already.
     */
    private _insertGlobalRegisterCodeIfNecessary(self, debug);
}
