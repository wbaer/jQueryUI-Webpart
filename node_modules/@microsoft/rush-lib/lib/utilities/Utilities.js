// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
var child_process = require("child_process");
var fsx = require("fs-extra");
var os = require("os");
var rimraf = require("rimraf");
var Utilities = (function () {
    function Utilities() {
    }
    /**
     * For a scoped NPM package name this separates the scope and name parts.  For example:
     * parseScopedPackageName('@my-scope/myproject') = { scope: '@my-scope', name: 'myproject' }
     * parseScopedPackageName('myproject') = { scope: '', name: 'myproject' }
     */
    Utilities.parseScopedPackageName = function (scopedName) {
        if (scopedName.substr(0, 1) !== '@') {
            return { scope: '', name: scopedName };
        }
        var slashIndex = scopedName.indexOf('/');
        if (slashIndex >= 0) {
            return { scope: scopedName.substr(0, slashIndex), name: scopedName.substr(slashIndex + 1) };
        }
        else {
            throw new Error('Invalid scoped name: ' + scopedName);
        }
    };
    /**
     * NodeJS equivalent of performance.now().
     */
    Utilities.getTimeInMs = function () {
        var seconds;
        var nanoseconds;
        _a = process.hrtime(), seconds = _a[0], nanoseconds = _a[1];
        return seconds * 1000 + nanoseconds / 1000000;
        var _a;
    };
    /**
     * Returns the values from a Set<T>
     */
    Utilities.getSetAsArray = function (set) {
        // When ES6 is supported, we can use Array.from() instead.
        var result = [];
        set.forEach(function (value) {
            result.push(value);
        });
        return result;
    };
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    Utilities.retryUntilTimeout = function (fn, maxWaitTimeMs, getTimeoutError, fnName) {
        var startTime = Utilities.getTimeInMs();
        var looped = false;
        var result;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            try {
                result = fn();
                break;
            }
            catch (e) {
                looped = true;
                var currentTime = Utilities.getTimeInMs();
                if (currentTime - startTime > maxWaitTimeMs) {
                    throw getTimeoutError(e);
                }
            }
        }
        if (looped) {
            var currentTime = Utilities.getTimeInMs();
            var totalSeconds = ((currentTime - startTime) / 1000.0).toFixed(2);
            console.log(fnName + "() stalled for " + totalSeconds + " seconds");
        }
        return result;
    };
    Utilities.createFolderWithRetry = function (folderName) {
        // We need to do a simple "fs.mkdirSync(localModulesFolder)" here,
        // however if the folder we deleted above happened to contain any files,
        // then there seems to be some OS process (virus scanner?) that holds
        // a lock on the folder for a split second, which causes mkdirSync to
        // fail.  To workaround that, retry for up to 7 seconds before giving up.
        var maxWaitTimeMs = 7 * 1000;
        return Utilities.retryUntilTimeout(function () { return fsx.mkdirSync(folderName); }, maxWaitTimeMs, function (e) { return new Error("Error: " + e + os.EOL + "Often this is caused by a file lock " +
            'from a process such as your text editor, command prompt, ' +
            'or "gulp serve"'); }, 'createFolderWithRetry');
    };
    /**
     * Determines if the path points to a file and that it exists.
     */
    Utilities.fileExists = function (path) {
        var exists = false;
        try {
            var lstat = fsx.lstatSync(path);
            exists = lstat.isFile();
        }
        catch (e) { }
        return exists;
    };
    /**
     * Determines if a path points to a directory and that it exists.
     */
    Utilities.directoryExists = function (path) {
        var exists = false;
        try {
            var lstat = fsx.lstatSync(path);
            exists = lstat.isDirectory();
        }
        catch (e) { }
        return exists;
    };
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    Utilities.dangerouslyDeletePath = function (folderPath) {
        try {
            rimraf.sync(folderPath, { disableGlob: true });
        }
        catch (e) {
            throw new Error(e.message + os.EOL + 'Often this is caused by a file lock'
                + ' from a process such as your text editor, command prompt, or "gulp serve"');
        }
    };
    /**
     * Attempts to delete a file. If it does not exist, or the path is not a file, it no-ops.
     */
    Utilities.deleteFile = function (filePath) {
        if (Utilities.fileExists(filePath)) {
            console.log("Deleting: " + filePath);
            fsx.unlinkSync(filePath);
        }
    };
    /*
     * Returns true if outputFilename has a more recent last modified timestamp
     * than all of the inputFilenames, which would imply that we don't need to rebuild it.
     * Returns false if any of the files does not exist.
     * NOTE: The filenames can also be paths for directories, in which case the directory
     * timestamp is compared.
     */
    Utilities.isFileTimestampCurrent = function (outputFilename, inputFilenames) {
        if (!fsx.existsSync(outputFilename)) {
            return false;
        }
        var outputStats = fsx.statSync(outputFilename);
        for (var _i = 0, inputFilenames_1 = inputFilenames; _i < inputFilenames_1.length; _i++) {
            var inputFilename = inputFilenames_1[_i];
            if (!fsx.existsSync(inputFilename)) {
                return false;
            }
            var inputStats = fsx.statSync(inputFilename);
            if (outputStats.mtime < inputStats.mtime) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns the width of the console, measured in columns
     */
    Utilities.getConsoleWidth = function () {
        var stdout = process.stdout;
        if (stdout && stdout.columns) {
            return stdout.columns;
        }
        return 80;
    };
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    Utilities.executeCommand = function (command, args, workingDirectory, suppressOutput, environmentVariables) {
        if (suppressOutput === void 0) { suppressOutput = false; }
        Utilities._executeCommandInternal(command, args, workingDirectory, suppressOutput ? undefined : [0, 1, 2], environmentVariables);
    };
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    Utilities.executeCommandAndCaptureOutput = function (command, args, workingDirectory, environmentVariables) {
        var result = Utilities._executeCommandInternal(command, args, workingDirectory, ['pipe', 'pipe', 'pipe'], environmentVariables);
        return result.stdout.toString();
    };
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    Utilities.executeCommandWithRetry = function (command, args, maxAttempts, workingDirectory, suppressOutput) {
        if (suppressOutput === void 0) { suppressOutput = false; }
        if (maxAttempts < 1) {
            throw new Error('The maxAttempts parameter cannot be less than 1');
        }
        var attemptNumber = 1;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            try {
                Utilities.executeCommand(command, args, workingDirectory, suppressOutput);
            }
            catch (error) {
                console.log(os.EOL + 'The command failed:');
                console.log(" " + command + " " + args.join(' '));
                console.log("ERROR: " + error.toString());
                if (attemptNumber < maxAttempts) {
                    ++attemptNumber;
                    console.log("Trying again (attempt #" + attemptNumber + ")..." + os.EOL);
                    continue;
                }
                else {
                    console.error("Giving up after " + attemptNumber + " attempts" + os.EOL);
                    throw error;
                }
            }
            break;
        }
    };
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    Utilities.executeCommandAsync = function (command, args, workingDirectory, environmentVariables) {
        // This is a workaround for GitHub issue #25330.  It is not as complete as the workaround above,
        // but there doesn't seem to be an easy asynchronous solution.
        // https://github.com/nodejs/node-v0.x-archive/issues/25330
        if (fsx.existsSync(command + '.cmd')) {
            command += '.cmd';
        }
        return child_process.spawn(command, args, {
            cwd: workingDirectory,
            shell: true,
            env: environmentVariables
        });
    };
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param targetString  The string to be modified
     * @param searchValue   The value to search for
     * @param replaceValue  The replacement text
     */
    Utilities.getAllReplaced = function (targetString, searchValue, replaceValue) {
        return targetString.split(searchValue).join(replaceValue);
    };
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    Utilities._executeCommandInternal = function (command, args, workingDirectory, stdio, environmentVariables) {
        var options = {
            cwd: workingDirectory,
            shell: true,
            stdio: stdio,
            env: environmentVariables
        };
        var result = child_process.spawnSync(command, args, options);
        /* tslint:disable:no-any */
        if (result.error && result.error.errno === 'ENOENT') {
            // This is a workaround for GitHub issue #25330
            // https://github.com/nodejs/node-v0.x-archive/issues/25330
            result = child_process.spawnSync(command + '.cmd', args, options);
        }
        /* tslint:enable:no-any */
        if (result.error) {
            result.error.message += os.EOL + (result.stderr ? result.stderr.toString() + os.EOL : '');
            throw result.error;
        }
        if (result.status) {
            throw new Error('The command failed with exit code ' + result.status + os.EOL +
                (result.stderr ? result.stderr.toString() : ''));
        }
        return result;
    };
    return Utilities;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Utilities;

//# sourceMappingURL=Utilities.js.map
