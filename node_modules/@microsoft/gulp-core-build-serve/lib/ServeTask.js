"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var fs = require("fs");
var ServeTask = (function (_super) {
    __extends(ServeTask, _super);
    function ServeTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'serve';
        _this.taskConfig = {
            api: undefined,
            https: false,
            initialPage: '/index.html',
            port: 4321,
            tryCreateDevCertificate: false
        };
        return _this;
    }
    ServeTask.prototype.loadSchema = function () {
        return require('./serve.schema.json');
    };
    ServeTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        /* tslint:disable:typedef */
        var gulpConnect = require('gulp-connect');
        var open = require('gulp-open');
        var http = require('http');
        var https = require('https');
        /* tslint:enable:typedef */
        var gutil = require('gulp-util');
        var path = require('path');
        var openBrowser = (process.argv.indexOf('--nobrowser') === -1);
        var portArgumentIndex = process.argv.indexOf('--port');
        var _a = this.taskConfig, port = _a.port, initialPage = _a.initialPage;
        var api = this.taskConfig.api;
        var rootPath = this.buildConfig.rootPath;
        var httpsServerOptions = this._loadHttpsServerOptions();
        if (portArgumentIndex >= 0 && process.argv.length > (portArgumentIndex + 1)) {
            port = Number(process.argv[portArgumentIndex + 1]);
        }
        // Spin up the connect server
        gulpConnect.server({
            https: httpsServerOptions,
            livereload: true,
            middleware: function () { return [_this._logRequestsMiddleware, _this._enableCorsMiddleware]; },
            port: port,
            root: rootPath
        });
        // If an api is provided, spin it up.
        if (api) {
            var apiMap = void 0;
            try {
                apiMap = require(path.join(rootPath, api.entryPath));
                if (apiMap && apiMap.default) {
                    apiMap = apiMap.default;
                }
            }
            catch (e) {
                this.logError("The api entry could not be loaded: " + api.entryPath);
            }
            if (apiMap) {
                console.log("Starting api server on port " + api.port + ".");
                var express = require('express');
                var app = express();
                app.use(this._logRequestsMiddleware);
                app.use(this._enableCorsMiddleware);
                app.use(this._setJSONResponseContentTypeMiddleware);
                // Load the apis.
                for (var apiMapEntry in apiMap) {
                    if (apiMap.hasOwnProperty(apiMapEntry)) {
                        console.log("Registring api: " + gutil.colors.green(apiMapEntry));
                        app.get(apiMapEntry, apiMap[apiMapEntry]);
                    }
                }
                var apiPort = api.port || 5432;
                if (this.taskConfig.https) {
                    https.createServer(httpsServerOptions, app).listen(apiPort);
                }
                else {
                    http.createServer(app).listen(apiPort);
                }
            }
        }
        // Spin up the browser.
        if (openBrowser) {
            var uri = initialPage;
            if (!initialPage.match(/^https?:\/\//)) {
                if (!initialPage.match(/^\//)) {
                    initialPage = "/" + initialPage;
                }
                uri = (this.taskConfig.https ? 'https' : 'http') + "://localhost:" + port + initialPage;
            }
            gulp.src('')
                .pipe(open({
                uri: uri
            }));
        }
        completeCallback();
    };
    ServeTask.prototype._logRequestsMiddleware = function (req, res, next) {
        var colors = require('gulp-util').colors;
        /* tslint:disable:no-any */
        var ipAddress = req.ip;
        /* tslint:enable:no-any */
        var resourceColor = colors.cyan;
        if (req && req.url) {
            if (req.url.indexOf('.bundle.js') >= 0) {
                resourceColor = colors.green;
            }
            else if (req.url.indexOf('.js') >= 0) {
                resourceColor = colors.magenta;
            }
            console.log([
                "  Request: ",
                "" + (ipAddress ? "[" + colors.cyan(ipAddress) + "] " : ""),
                "'" + resourceColor(req.url) + "'"
            ].join(''));
        }
        next();
    };
    ServeTask.prototype._enableCorsMiddleware = function (req, res, next) {
        res.setHeader('Access-Control-Allow-Origin', '*');
        next();
    };
    ServeTask.prototype._setJSONResponseContentTypeMiddleware = function (req, res, next) {
        res.setHeader('content-type', 'application/json');
        next();
    };
    ServeTask.prototype._loadHttpsServerOptions = function () {
        if (this.taskConfig.https) {
            var result = {};
            // We're configuring an HTTPS server, so we need a certificate
            if (this.taskConfig.pfxPath) {
                // There's a PFX path in the config, so try that
                this.logVerbose("Trying PFX path: " + this.taskConfig.pfxPath);
                if (fs.existsSync(this.taskConfig.pfxPath)) {
                    try {
                        result.pfx = fs.readFileSync(this.taskConfig.pfxPath);
                        this.logVerbose("Loaded PFX certificate.");
                    }
                    catch (e) {
                        this.logError("Error loading PFX file: " + e);
                    }
                }
                else {
                    this.logError("PFX file not found at path \"" + this.taskConfig.pfxPath + "\"");
                }
            }
            else if (this.taskConfig.keyPath && this.taskConfig.certPath) {
                this.logVerbose("Trying key path \"" + this.taskConfig.keyPath + "\" and cert path \"" + this.taskConfig.certPath + "\".");
                var certExists = fs.existsSync(this.taskConfig.certPath);
                var keyExists = fs.existsSync(this.taskConfig.keyPath);
                if (keyExists && certExists) {
                    try {
                        result.cert = fs.readFileSync(this.taskConfig.certPath);
                        result.key = fs.readFileSync(this.taskConfig.keyPath);
                    }
                    catch (e) {
                        this.logError("Error loading key or cert file: " + e);
                    }
                }
                else {
                    if (!keyExists) {
                        this.logError("Key file not found at path \"" + this.taskConfig.keyPath);
                    }
                    if (!certExists) {
                        this.logError("Cert file not found at path \"" + this.taskConfig.certPath);
                    }
                }
            }
            else {
                var ensureCertificate = require('./certificates').ensureCertificate; // tslint:disable-line
                var devCertificate = ensureCertificate(this.taskConfig.tryCreateDevCertificate, this);
                if (devCertificate.pemCertificate && devCertificate.pemKey) {
                    result.cert = devCertificate.pemCertificate;
                    result.key = devCertificate.pemKey;
                }
                else {
                    this.logWarning('When serving in HTTPS mode, a PFX cert path or a cert path and a key path must be ' +
                        'provided, or a dev certificate must be generated and trusted. If a SSL certificate isn\'t ' +
                        'provided, a default, self-signed certificate will be used. Expect browser security ' +
                        'warnings.');
                }
            }
            return result;
        }
        else {
            return undefined;
        }
    };
    return ServeTask;
}(gulp_core_build_1.GulpTask));
exports.ServeTask = ServeTask;

//# sourceMappingURL=ServeTask.js.map
