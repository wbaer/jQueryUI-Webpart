"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require("path");
var glob = require("glob");
var Webpack = require("webpack");
var rush_lib_1 = require("@microsoft/rush-lib");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var cumulativeManifestProcessor_1 = require("./../writeManifests/cumulativeManifest/cumulativeManifestProcessor");
var deployToAzure_1 = require("./../deployAzureStorage/uploadCDN/deployToAzure");
var ensureBlobService_1 = require("./../utilities/azureStorage/ensureBlobService");
var ensureContainer_1 = require("./../utilities//azureStorage/ensureContainer");
var uploadFileToAzure_1 = require("./../utilities//azureStorage/uploadFileToAzure");
var url_1 = require("./../utilities/url");
var manifestsAzureFilename = 'manifests.js';
var spLoaderId = '1c6c9123-7aac-41f3-a376-3caea41ed83f';
var DevDeployTask = (function (_super) {
    __extends(DevDeployTask, _super);
    function DevDeployTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'dev-deploy';
        _this.taskConfig = {
            useRush: false
        };
        return _this;
    }
    DevDeployTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.account) {
            completeCallback('Azure storage account not set.');
            return;
        }
        if (!this.taskConfig.accessKey) {
            completeCallback('Azure storage account access key not set.');
            return;
        }
        if (!this.taskConfig.container) {
            completeCallback('Azure container name not set.');
            return;
        }
        if (!this.taskConfig.containerDirectoryName) {
            this.logWarning('It is strongly recommended a directory inside the container be used to avoid clobbering other ' +
                'users\' dev deployments.');
        }
        this.taskConfig.useRush = this.taskConfig.useRush || (process.argv.indexOf('--rush') !== -1);
        var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(this);
        var manifests;
        try {
            manifests = this._getManifests(cumulativeManifestProcessor);
        }
        catch (e) {
            completeCallback(e);
            return;
        }
        var manifestsArray = [];
        this.logVerbose("Discovered " + Object.keys(manifests).length + " projects.");
        var storageDirName = this._getStorageDirName();
        var containerUrl = this._getContainerUrl();
        var filesToUpload = new Map();
        var dirsToUpload = new Map();
        var projectContainerNames = new Map(); // Ensure we don't reuse a name
        var spLoaderPath;
        var debugSPLoader;
        var _loop_1 = function (id) {
            if (manifests.hasOwnProperty(id)) {
                var manifestProject_1 = manifests[id];
                var manifest = manifestProject_1.manifestData;
                var loaderConfig = manifest.loaderConfig;
                manifestsArray.push(manifest);
                var projectContainerName = this_1._getAzureDirName(projectContainerNames, manifestProject_1.packagePath);
                var projectBasePath_1 = url_1.joinUrlSegments(storageDirName, projectContainerName);
                var projectBaseFullUrl = url_1.joinUrlSegments(containerUrl, projectBasePath_1);
                loaderConfig.internalModuleBaseUrls = [url_1.ensureTrailingSlash(projectBaseFullUrl)];
                // Ensure we don't reuse a name
                var resourceContainerNames_1 = new Map();
                var processPath = function (rawResourcePath) {
                    var resourcePath = _this._disambiguatePath(rawResourcePath);
                    if (url_1.isUrl(resourcePath)) {
                        return resourcePath; // Do not deal with fully-qualified URL.
                    }
                    else {
                        var filesystemPath = path.join(manifestProject_1.packagePath, resourcePath);
                        var filename = path.basename(resourcePath);
                        // Path resources are in the 'dist' directory by default and usually have some secondary
                        //  references, so let's just upload the whole directory.
                        var filesystemDirectory = path.dirname(filesystemPath);
                        var azureResourceDirName = _this._getAzureDirName(resourceContainerNames_1, filesystemDirectory);
                        var azureDirectory = url_1.joinUrlSegments(projectBasePath_1, azureResourceDirName);
                        dirsToUpload.set(filesystemDirectory, azureDirectory);
                        if (!spLoaderPath && id === spLoaderId) {
                            spLoaderPath = azureDirectory;
                            debugSPLoader = filename;
                        }
                        return url_1.joinUrlSegments(azureResourceDirName, filename);
                    }
                };
                for (var scriptResourceId in loaderConfig.scriptResources) {
                    if (loaderConfig.scriptResources.hasOwnProperty(scriptResourceId)) {
                        var scriptResource = loaderConfig.scriptResources[scriptResourceId];
                        switch (scriptResource.type) {
                            case 'path':
                                // Path script resource, we need to fix up its path and upload it
                                var pathResource = scriptResource;
                                pathResource.path = processPath(pathResource.path);
                                break;
                            case 'component':
                                // We probably don't need to upload the fallback file, and it's nigh-impossible to tell if we'll
                                //  miss secondary dependencies by only uploading the file at the failoverPath, so we'll just clear it
                                //  out and hope this dependency is either satisified by another dev-deploy manifest or by the OOB
                                //  framework
                                var componentResource = scriptResource;
                                componentResource.failoverPath = undefined;
                                break;
                            case 'localizedPath':
                                // Localized path script resource, we need to fix up the paths for each locale and upload each file
                                var localizedPathResource = scriptResource;
                                localizedPathResource.defaultPath = processPath(localizedPathResource.defaultPath);
                                if (localizedPathResource.paths) {
                                    for (var locale in localizedPathResource.paths) {
                                        if (localizedPathResource.paths.hasOwnProperty(locale)) {
                                            localizedPathResource.paths[locale] = processPath(localizedPathResource.paths[locale]);
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        };
        var this_1 = this;
        // Loop through the manifests and collect files and directories to be uploaded, and fix up manifest fields
        for (var id in manifests) {
            _loop_1(id);
        }
        // Expand directories to individual files
        var directoryExpandPromises = [];
        dirsToUpload.forEach(function (azureDirName, localDirName) {
            directoryExpandPromises.push(_this._getFilesInDirectory(localDirName).then(function (files) {
                files.forEach(function (file) {
                    var azureUrl = url_1.joinUrlSegments(azureDirName, file.replace(/\\/g, '/'));
                    filesToUpload.set(path.join(localDirName, file), azureUrl);
                });
            }));
        });
        var blobServicePromise = ensureBlobService_1.default(this.taskConfig.account, this.taskConfig.accessKey)
            .then(function (blobService) { return ensureContainer_1.default(blobService, _this.taskConfig.container, 
        /* createContainerOptions */ undefined, _this.log.bind(_this)); });
        var uploadPromise = blobServicePromise.then(function (blobService) {
            return Promise.all(directoryExpandPromises).then(function () {
                var uploadPromises = [];
                filesToUpload.forEach(function (azurePath, localFile) {
                    uploadPromises.push(uploadFileToAzure_1.default(blobService, _this.taskConfig.container, localFile, azurePath, _this.log.bind(_this)));
                });
                return Promise.all(uploadPromises);
            });
        });
        var manifestsFilePromise = uploadPromise.then(function (blobServices) {
            var blobService = blobServices[0];
            var webpackConfig = cumulativeManifestProcessor.getManifestsFileWebpackConfig(manifestsArray);
            var manifestsFilename = 'devDeployManifests.js';
            var manifestsFileFullPath = path.join(webpackConfig.output.path, manifestsFilename);
            webpackConfig.output.filename = manifestsFilename;
            webpackConfig.entry = cumulativeManifestProcessor.manifestsFilePath;
            return new Promise(function (resolve, reject) {
                Webpack(webpackConfig, function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            }).then(function () {
                return uploadFileToAzure_1.default(blobService, _this.taskConfig.container, manifestsFileFullPath, url_1.joinUrlSegments(storageDirName, manifestsAzureFilename), _this.log.bind(_this));
            });
        });
        return manifestsFilePromise.then(function () {
            var devDeployUrl = _this.getDeployUrl();
            var loaderUrl = url_1.joinUrlSegments(containerUrl, spLoaderPath, debugSPLoader);
            _this.log('UPLOAD COMPLETE.');
            if (loaderUrl) {
                _this.log("Debug loader: \"?moduleloader=" + loaderUrl + "\"");
            }
            _this.log("Debug manifest: \"#debugManifestsFile=" + devDeployUrl + "\"");
            _this.properties.devDeployUrl = devDeployUrl;
            completeCallback();
            return {};
        }).catch(function (error) {
            completeCallback(error.message);
            return {};
        });
    };
    DevDeployTask.prototype.getDeployUrl = function () {
        return url_1.joinUrlSegments(this._getContainerUrl(), this._getStorageDirName(), manifestsAzureFilename);
    };
    DevDeployTask.prototype._getContainerUrl = function () {
        return deployToAzure_1.getAzureStorageUrl(this.taskConfig.account, this.taskConfig.container);
    };
    DevDeployTask.prototype._getStorageDirName = function () {
        return this.taskConfig.containerDirectoryName || '';
    };
    DevDeployTask.prototype._disambiguatePath = function (path) {
        return typeof path === 'string' ? path : path.default;
    };
    DevDeployTask.prototype._getFilesInDirectory = function (dirName) {
        return new Promise(function (resolve, reject) {
            glob(path.join('**', '*.*'), { cwd: dirName }, function (error, files) {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(files);
                }
            });
        });
    };
    /**
     * This function returns a directory name to be used in a directory on Azure storage, ensuring that the name does
     *  not collide with another directory's name. It also ensures that if the specified filesystem path has already
     *  been mapped to an Azure directory, the same name is used on Azure.
     */
    DevDeployTask.prototype._getAzureDirName = function (directoryMap, filesystemPath) {
        var azureDirName = path.basename(filesystemPath).toLowerCase();
        if (directoryMap.has(azureDirName)) {
            var existingPaths = directoryMap.get(azureDirName);
            var currentPathId = existingPaths.indexOf(filesystemPath);
            if (currentPathId === -1) {
                azureDirName = azureDirName + "_" + existingPaths.length;
                existingPaths.push(filesystemPath);
            }
            else if (currentPathId > 0) {
                azureDirName = azureDirName + "_" + currentPathId;
            }
        }
        else {
            directoryMap.set(azureDirName, [filesystemPath]);
        }
        return azureDirName;
    };
    DevDeployTask.prototype._getManifests = function (cumulativeManifestProcessor) {
        if (this.taskConfig.useRush) {
            var rushConfig = rush_lib_1.RushConfiguration.loadFromDefaultLocation();
            if (!rushConfig) {
                throw 'Unable to find the rush configuration file.';
            }
            var manifests = void 0;
            var directories = rushConfig.projects.map(function (proj) { return proj.projectFolder; });
            manifests = cumulativeManifestProcessor.discoverManifests(directories[0], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
            for (var i = 1; i < directories.length; i++) {
                var projectManifests = cumulativeManifestProcessor.discoverManifests(directories[i], cumulativeManifestProcessor_1.ForceSearch.deepSparse);
                manifests = this._mergeReferencedProjectLists(manifests, projectManifests);
            }
            return manifests;
        }
        else {
            return cumulativeManifestProcessor.discoverManifests(this.buildConfig.rootPath, cumulativeManifestProcessor_1.ForceSearch.deepSparse);
        }
    };
    DevDeployTask.prototype._mergeReferencedProjectLists = function (list1, list2) {
        var ids = new Set();
        Object.keys(list1).concat(Object.keys(list2)).forEach(function (id) { return ids.add(id); });
        var result = {};
        ids.forEach(function (id) {
            var list1Element = list1[id];
            var list2Element = list2[id];
            if (!list1Element || !list2Element) {
                // Element is only present in one list
                result[id] = list1Element || list2Element;
            }
            else if (list1Element.manifestCreationTime > list2Element.manifestCreationTime) {
                // List 1's element is newer
                result[id] = list1Element;
            }
            else {
                // List 2's element is newer, or they have the same age
                result[id] = list2Element;
            }
        });
        return result;
    };
    return DevDeployTask;
}(OdspGulpTask_1.default));
exports.DevDeployTask = DevDeployTask;

//# sourceMappingURL=DevDeployTask.js.map
