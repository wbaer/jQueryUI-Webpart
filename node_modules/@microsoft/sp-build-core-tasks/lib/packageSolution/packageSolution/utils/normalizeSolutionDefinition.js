/**
 * @file normalizeSolutionDefinition.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Using a manifest map, creates component definitions and updates a package definition's element guids with
 * actual objects
 */
"use strict";
var path = require("path");
var ComponentType_1 = require("../models/ComponentType");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
function createComponent(manifest) {
    if (!manifest.id || !manifest || !manifest.componentType) {
        return undefined;
    }
    if (manifest.componentType === 'Application') {
        return createApplicationComponent(manifest);
    }
    else if (manifest.componentType === 'WebPart') {
        return createWebPartComponent(manifest);
    }
    else if (manifest.componentType === 'CodePart') {
        return createCodePartComponent(manifest);
    }
    else {
        gulp_core_build_1.log("Component type '" + manifest.componentType + "' not recognized. Skipping manifest.");
        return undefined;
    }
}
function createCodePartComponent(manifest) {
    return {
        name: manifest.alias,
        description: manifest.codePartType + " - " + manifest.alias,
        id: manifest.id,
        manifest: JSON.stringify(manifest),
        type: ComponentType_1.default[manifest.componentType],
        componentDefinition: {}
    };
}
function createApplicationComponent(manifest) {
    return {
        name: manifest.title.default,
        description: manifest.description.default,
        id: manifest.id,
        manifest: JSON.stringify(manifest),
        type: ComponentType_1.default[manifest.componentType],
        componentDefinition: {}
    };
}
function createWebPartComponent(manifest) {
    var i = 0;
    var entries = manifest.preconfiguredEntries.map(function (entry) {
        return {
            id: manifest.id + '_' + i++,
            name: entry.title.default,
            description: entry.description.default,
            webPartData: buildWebPartData(manifest, entry)
        };
    });
    // Use the first entry name and description for the component
    return {
        name: manifest.preconfiguredEntries[0].title.default,
        description: manifest.preconfiguredEntries[0].description.default,
        id: manifest.id,
        manifest: JSON.stringify(manifest),
        type: ComponentType_1.default[manifest.componentType],
        componentDefinition: {
            entries: entries
        }
    };
}
// tslint:disable:no-any
function buildWebPartData(manifest, entry) {
    // tslint:enable:no-any
    return JSON.stringify({
        id: manifest.id,
        instanceId: undefined,
        title: entry.title.default,
        description: entry.description.default,
        version: manifest.version,
        properties: entry.properties
    });
}
function createComponentMapFromManifests(manifests) {
    gulp_core_build_1.log("Attempting creating component definitions for {" + manifests.size + "} manifests");
    var components = new Map();
    manifests.forEach(function (manifest, key) {
        var component = createComponent(manifest);
        if (component) {
            components.set(key, component);
        }
    });
    gulp_core_build_1.log("Created component definitions for {" + components.size + "} manifests");
    return components;
}
function createFeatureFromComponent(component) {
    var componentTypeStr = (component.type === ComponentType_1.default.WebPart ? 'WebPart' : 'Application');
    return {
        title: component.name + " Feature",
        description: "A feature which activates the Client-Side " + componentTypeStr + " named " + component.name,
        id: component.id,
        components: [component],
        assets: {
            elementFiles: [],
            elementManifests: [],
            upgradeActions: []
        }
    };
}
/**
 * Normalizes the passed in solution definition by cross referencing componentIds with the collected list
 * of manifests in the repo. If, for any feature, the componentId list is missing or empty, we add all the
 * components to that feature. Similarly, if the list of features in the solution is empty or missing, a
 * feature is automatically created for all solutions.
 */
function normalizeSolutionDefinition(options, manifests) {
    var componentMap = createComponentMapFromManifests(manifests);
    var numManifests = componentMap.size;
    if (numManifests === 0) {
        throw 'Could not find any valid manifests. Please double check paths.manifestsMatch in the task config.';
    }
    // Then, replace the guids in the solution definition with the component definition
    if (options.solution && options.solution.features) {
        var _loop_1 = function (feature) {
            if (feature.componentIds && feature.componentIds.length > 0) {
                feature.components = feature.componentIds.map(function (componentId) {
                    var manifest = componentMap.get(componentId);
                    if (!manifest) {
                        throw new Error("Component {" + componentId + "} does not exist in feature '" + feature.title + "'. "
                            + 'Please update your configuration.');
                    }
                    return manifest;
                });
            }
            else {
                gulp_core_build_1.log('feature.componentIds not set! ' +
                    ("Adding all [" + numManifests + "] components to feature { " + feature.title + " }."));
                feature.components = [];
                componentMap.forEach(function (component) {
                    feature.components.push(component);
                });
            }
            if (!feature.assets) {
                feature.assets = {
                    elementFiles: [],
                    elementManifests: [],
                    upgradeActions: []
                };
            }
            feature.assets.elementFiles =
                appendBasePathToFeatureFiles(feature.assets.elementFiles, options.paths.sharepointAssetDir);
            feature.assets.elementManifests =
                appendBasePathToFeatureFiles(feature.assets.elementManifests, options.paths.sharepointAssetDir);
            feature.assets.upgradeActions =
                appendBasePathToFeatureFiles(feature.assets.upgradeActions, options.paths.sharepointAssetDir);
        };
        for (var _i = 0, _a = options.solution.features; _i < _a.length; _i++) {
            var feature = _a[_i];
            _loop_1(feature);
        }
    }
    else {
        gulp_core_build_1.log('config.solution.features not set! Instead generating a feature for each component.');
        options.solution.features = [];
        componentMap.forEach(function (component) {
            gulp_core_build_1.log("Creating feature for " + component.name + "...");
            options.solution.features.push(createFeatureFromComponent(component));
        });
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = normalizeSolutionDefinition;
function appendBasePathToFeatureFiles(files, basePath) {
    if (files) {
        return files.map(function (filename) { return path.posix.join(basePath, filename); });
    }
    return [];
}

//# sourceMappingURL=normalizeSolutionDefinition.js.map
