/* tslint:disable:max-line-length */
"use strict";
var gutil = require("gulp-util");
var path = require("path");
/* tslint:disable:typedef */
var prettyTime = require('pretty-hrtime');
/* tslint:enable:typedef */
var state = require("./State");
var config_1 = require("./config");
var index_1 = require("./index");
var WROTE_ERROR_KEY = '__gulpCoreBuildWroteError';
var wiredUpErrorHandling = false;
var duringFastExit = false;
/* tslint:disable:no-any */
var globalInstance = global;
/* tslint:enable:no-any */
var localCache = globalInstance.__loggingCache = globalInstance.__loggingCache || {
    warnings: [],
    errors: [],
    testsRun: 0,
    subTasksRun: 0,
    testsPassed: 0,
    testsFailed: 0,
    testsFlakyFailed: 0,
    testsSkipped: 0,
    taskRun: 0,
    taskErrors: 0,
    coverageResults: 0,
    coveragePass: 0,
    coverageTotal: 0,
    totalTaskHrTime: undefined,
    totalTaskSrc: 0,
    wroteSummary: false,
    writingSummary: false,
    writeSummaryCallbacks: [],
    exitCode: 0,
    writeSummaryLogs: [],
    errorAndWarningSuppressions: {},
    gulp: undefined,
    gulpErrorCallback: undefined,
    gulpStopCallback: undefined,
    shouldLogErrorsDuringSummary: false,
    shouldLogWarningsDuringSummary: false
};
if (!localCache.start) {
    localCache.start = process.hrtime();
}
wireUpProcessErrorHandling();
function isVerbose() {
    return config_1.getFlagValue('verbose');
}
/* tslint:disable:no-any */
function formatError(e) {
    /* tslint:enable:no-any */
    'use strict';
    if (!e.err) {
        if (isVerbose()) {
            return e.message + '\r\n' + e.stack;
        }
        else {
            return e.message;
        }
    }
    // PluginError
    if (typeof e.err.showStack === 'boolean') {
        return e.err.toString() + (e.err.stack && isVerbose() ? '\r\n' + e.err.stack : '');
    }
    // normal error
    if (e.err.stack) {
        if (isVerbose()) {
            return e.err.stack;
        }
        else {
            return e.err.message;
        }
    }
    // unknown (string, number, etc.)
    if (typeof (Error) === 'undefined') {
        if (isVerbose()) {
            return e.message + '\r\n' + e.stack;
        }
        else {
            return e.message;
        }
    }
    else {
        var output = String(e.err);
        try {
            output = JSON.stringify(e.err);
        }
        catch (e) {
        }
        if (isVerbose()) {
            return new Error(output).stack;
        }
        else {
            return new Error(output).message;
        }
    }
}
function afterStreamFlushed(streamName, callback) {
    'use strict';
    if (duringFastExit) {
        callback();
    }
    else {
        var stream = process[streamName];
        var outputWritten = stream.write('');
        if (outputWritten) {
            /* tslint:disable:ban-native-functions */
            setTimeout(function () {
                callback();
            }, 250);
        }
        else {
            stream.once('drain', function () {
                /* tslint:disable:ban-native-functions */
                setTimeout(function () {
                    callback();
                }, 250);
                /* tslint:enable:ban-native-functions */
            });
        }
    }
}
function afterStreamsFlushed(callback) {
    'use strict';
    afterStreamFlushed('stdout', function () {
        afterStreamFlushed('stderr', function () {
            callback();
        });
    });
}
function writeSummary(callback) {
    'use strict';
    var shouldRelogIssues = config_1.getFlagValue('relogIssues');
    localCache.writeSummaryCallbacks.push(callback);
    if (!localCache.writingSummary) {
        localCache.writingSummary = true;
        // flush the log
        afterStreamsFlushed(function () {
            log(gutil.colors.magenta('==================[ Finished ]=================='));
            if (shouldRelogIssues && getWarnings().length) {
                var warnings = getWarnings();
                for (var x = 0; x < warnings.length; x++) {
                    console.error(gutil.colors.yellow(warnings[x]));
                }
            }
            if (shouldRelogIssues && (localCache.taskErrors > 0 || getErrors().length)) {
                var errors = getErrors();
                for (var x = 0; x < errors.length; x++) {
                    console.error(gutil.colors.red(errors[x]));
                }
            }
            afterStreamsFlushed(function () {
                for (var _i = 0, _a = localCache.writeSummaryLogs; _i < _a.length; _i++) {
                    var writeSummaryString = _a[_i];
                    log(writeSummaryString);
                }
                var totalDuration = process.hrtime(getStart());
                log("Project " + state.builtPackage.name + " version:", gutil.colors.yellow(state.builtPackage.version));
                log('Build tools version:', gutil.colors.yellow(state.coreBuildPackage.version));
                log('Node version:', gutil.colors.yellow(process.version));
                // log('Create tasks duration:', gutil.colors.yellow(prettyTime(localCache.taskCreationTime)));
                // log('Read src tasks duration:', gutil.colors.yellow(prettyTime(localCache.totalTaskHrTime)));
                log('Total duration:', gutil.colors.yellow(prettyTime(totalDuration)));
                // log(`Tasks run: ${gutil.colors.yellow(localCache.taskRun + '')} Subtasks run: ${gutil.colors.yellow(localCache.subTasksRun + '')}`);
                if (localCache.testsRun > 0) {
                    log('Tests results -', 'Passed:', gutil.colors.green(localCache.testsPassed + ''), 'Failed:', gutil.colors.red(localCache.testsFailed + ''), 
                    // 'Flakey:', gutil.colors.yellow(localCache.testsFlakyFailed + ''),
                    'Skipped:', gutil.colors.yellow(localCache.testsSkipped + ''));
                }
                if (localCache.coverageResults > 0) {
                    log('Coverage results -', 'Passed:', gutil.colors.green(localCache.coveragePass + ''), 'Failed:', gutil.colors.red((localCache.coverageResults - localCache.coveragePass) + ''), 'Avg. Cov.:', gutil.colors.yellow(Math.floor(localCache.coverageTotal / localCache.coverageResults) + '%'));
                }
                if (getWarnings().length) {
                    log('Task warnings:', gutil.colors.yellow(getWarnings().length.toString()));
                }
                var totalErrors = 0;
                if (localCache.taskErrors > 0 || getErrors().length) {
                    totalErrors = (localCache.taskErrors + getErrors().length);
                    log('Task errors:', gutil.colors.red(totalErrors + ''));
                }
                localCache.wroteSummary = true;
                var callbacks = localCache.writeSummaryCallbacks;
                localCache.writeSummaryCallbacks = [];
                for (var _b = 0, callbacks_1 = callbacks; _b < callbacks_1.length; _b++) {
                    var writeSummaryCallback = callbacks_1[_b];
                    writeSummaryCallback();
                }
            });
        });
    }
    else if (localCache.wroteSummary) {
        var callbacks = localCache.writeSummaryCallbacks;
        localCache.writeSummaryCallbacks = [];
        for (var _i = 0, callbacks_2 = callbacks; _i < callbacks_2.length; _i++) {
            var writeSummaryCallback = callbacks_2[_i];
            writeSummaryCallback();
        }
    }
}
/* tslint:disable:no-any */
function _writeTaskError(e) {
    /* tslint:enable:no-any */
    'use strict';
    if (!e || !(e.err && e.err[WROTE_ERROR_KEY])) {
        writeError(e);
        localCache.taskErrors++;
    }
}
function exitProcess(errorCode) {
    'use strict';
    if (!localCache.watchMode) {
        process.stdout.write('', function () {
            process.exit(errorCode);
        });
    }
}
function wireUpProcessErrorHandling() {
    'use strict';
    if (!wiredUpErrorHandling) {
        wiredUpErrorHandling = true;
        process.on('exit', function (code) {
            'use strict';
            duringFastExit = true;
            if (!global['dontWatchExit']) {
                if (!localCache.wroteSummary) {
                    localCache.wroteSummary = true;
                    console.log('About to exit with code:', code);
                    console.error('Process terminated before summary could be written, possible error in async code not continuing!');
                    console.log('Trying to exit with exit code 1');
                    process.exit(1);
                }
                else {
                    if (localCache.exitCode !== 0) {
                        console.log("Exiting with exit code: " + localCache.exitCode);
                        process.exit(localCache.exitCode);
                    }
                }
            }
        });
        process.on('uncaughtException', function (err) {
            'use strict';
            console.error(err);
            _writeTaskError(err);
            writeSummary(function () {
                exitProcess(1);
                if (localCache.gulp) {
                    localCache.gulp.stop();
                }
                if (localCache.gulpErrorCallback) {
                    localCache.gulpErrorCallback(err);
                }
            });
        });
    }
}
function markErrorAsWritten(error) {
    try {
        error[WROTE_ERROR_KEY] = true;
    }
    catch (e) {
    }
}
/**
 * Adds a message to be displayed in the summary after execution is complete.
 * @param value - the message to display
 */
function logSummary(value) {
    'use strict';
    localCache.writeSummaryLogs.push(value);
}
exports.logSummary = logSummary;
/**
 * Log a message to the console
 * @param args - the messages to log to the console
 */
function log() {
    'use strict';
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    gutil.log.apply(this, args);
}
exports.log = log;
/**
 * Resets the state of the logging cache
 * @internal
 */
function reset() {
    'use strict';
    localCache.start = process.hrtime();
    localCache.warnings = [];
    localCache.errors = [];
    localCache.coverageResults = 0;
    localCache.coveragePass = 0;
    localCache.coverageTotal = 0;
    localCache.taskRun = 0;
    localCache.subTasksRun = 0;
    localCache.taskErrors = 0;
    localCache.totalTaskHrTime = undefined;
    localCache.totalTaskSrc = 0;
    localCache.wroteSummary = false;
    localCache.writingSummary = false;
    localCache.writeSummaryCallbacks = [];
    localCache.testsRun = 0;
    localCache.testsPassed = 0;
    localCache.testsFailed = 0;
    localCache.testsFlakyFailed = 0;
    localCache.testsSkipped = 0;
    localCache.writeSummaryLogs = [];
}
exports.reset = reset;
/** The result of a functional test run */
var TestResultState;
(function (TestResultState) {
    TestResultState[TestResultState["Passed"] = 0] = "Passed";
    TestResultState[TestResultState["Failed"] = 1] = "Failed";
    TestResultState[TestResultState["FlakyFailed"] = 2] = "FlakyFailed";
    TestResultState[TestResultState["Skipped"] = 3] = "Skipped";
})(TestResultState = exports.TestResultState || (exports.TestResultState = {}));
/**
 * Store a single functional test run's information
 * @param name - the name of the test
 * @param result - the result of the test
 * @param duration - the length of time it took for the test to execute
 */
function functionalTestRun(name, result, duration) {
    'use strict';
    localCache.testsRun++;
    switch (result) {
        case TestResultState.Failed:
            localCache.testsFailed++;
            break;
        case TestResultState.Passed:
            localCache.testsPassed++;
            break;
        case TestResultState.FlakyFailed:
            localCache.testsFlakyFailed++;
            break;
        case TestResultState.Skipped:
            localCache.testsSkipped++;
            break;
    }
}
exports.functionalTestRun = functionalTestRun;
function endTaskSrc(taskName, startHrtime, fileCount) {
    'use strict';
    localCache.totalTaskSrc++;
    var taskDuration = process.hrtime(startHrtime);
    if (!localCache.totalTaskHrTime) {
        localCache.totalTaskHrTime = taskDuration;
    }
    else {
        localCache.totalTaskHrTime[0] += taskDuration[0];
        var nanoSecTotal = taskDuration[1] + localCache.totalTaskHrTime[1];
        if (nanoSecTotal > 1e9) {
            localCache.totalTaskHrTime[0]++;
            localCache.totalTaskHrTime[1] = nanoSecTotal - 1e9;
        }
        else {
            localCache.totalTaskHrTime[1] = nanoSecTotal;
        }
    }
    log(taskName, 'read src task duration:', gutil.colors.yellow(prettyTime(taskDuration)), "- " + fileCount + " files");
}
exports.endTaskSrc = endTaskSrc;
/**
 * Store coverage information, potentially logging an error if the coverage is below the threshold
 * @param coverage - the coverage of the file as a percentage
 * @param threshold - the minimum coverage for the file as a percentage, an error will be logged if coverage is below the threshold
 * @param filePath - the path to the file whose coverage is being measured
 */
function coverageData(coverage, threshold, filePath) {
    'use strict';
    localCache.coverageResults++;
    if (coverage < threshold) {
        error('Coverage:', Math.floor(coverage) + '% (<' + threshold + '%) -', filePath);
    }
    else {
        localCache.coveragePass++;
    }
    localCache.coverageTotal += coverage;
}
exports.coverageData = coverageData;
var colorCodeRegex = /\x1B[[(?);]{0,2}(;?\d)*./g;
/**
 * Adds a suppression for an error or warning
 * @param str - the error or warning as a string
 */
function addSuppression(str) {
    'use strict';
    str = str
        .replace(colorCodeRegex, '') // remove colors
        .replace(/\r\n/g, '\n'); // normalize newline
    localCache.errorAndWarningSuppressions[str] = true;
    logSummary(gutil.colors.yellow('Supressing') + " - " + str);
}
exports.addSuppression = addSuppression;
/**
 * Logs a warning. It will be logged to standard error and cause the build to fail
 * if buildConfig.shouldWarningsFailBuild is true, otherwise it will be logged to standard output.
 * @param message - the warning description
 */
function warn() {
    'use strict';
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    args.splice(0, 0, 'Warning -');
    var stringMessage = args.join(' ');
    if (!localCache.errorAndWarningSuppressions[stringMessage.replace(colorCodeRegex, '')]) {
        localCache.warnings.push(stringMessage);
        log(gutil.colors.yellow.apply(undefined, args));
    }
}
exports.warn = warn;
/**
 * Logs an error to standard error and causes the build to fail.
 * @param message - the error description
 */
function error() {
    'use strict';
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    args.splice(0, 0, 'Error -');
    var stringMessage = args.join(' ');
    if (!localCache.errorAndWarningSuppressions[stringMessage.replace(colorCodeRegex, '')]) {
        localCache.errors.push(stringMessage);
        log(gutil.colors.red.apply(undefined, args));
    }
}
exports.error = error;
/**
 * Logs a message about a particular file
 * @param write - the function which will write message
 * @param taskName - the name of the task which is doing the logging
 * @param filePath - the path to the file which encountered an issue
 * @param line - the line in the file which had an issue
 * @param column - the column in the file which had an issue
 * @param errorCode - the custom error code representing this error
 * @param message - a description of the error
 */
function fileLog(write, taskName, filePath, line, column, errorCode, message) {
    'use strict';
    if (!filePath) {
        filePath = '<undefined path>';
    }
    else if (path.isAbsolute(filePath)) {
        filePath = path.relative(process.cwd(), filePath);
    }
    write(gutil.colors.cyan(taskName) + " - " + filePath + "(" + line + "," + column + "): error " + errorCode + ": " + message);
}
exports.fileLog = fileLog;
/**
 * Logs a warning regarding a specific file.
 * @param filePath - the path to the file which encountered an issue
 * @param line - the line in the file which had an issue
 * @param column - the column in the file which had an issue
 * @param warningCode - the custom warning code representing this warning
 * @param message - a description of the warning
 */
function fileWarning(taskName, filePath, line, column, errorCode, message) {
    fileLog(warn, taskName, filePath, line, column, errorCode, message);
}
exports.fileWarning = fileWarning;
/**
 * Logs an error regarding a specific file to standard error and causes the build to fail.
 * @param filePath - the path to the file which encountered an issue
 * @param line - the line in the file which had an issue
 * @param column - the column in the file which had an issue
 * @param errorCode - the custom error code representing this error
 * @param message - a description of the error
 */
function fileError(taskName, filePath, line, column, errorCode, message) {
    fileLog(error, taskName, filePath, line, column, errorCode, message);
}
exports.fileError = fileError;
/**
 * Logs a message to standard output if the verbose flag is specified.
 * @param messargsage - the messages to log when in verbose mode
 */
function verbose() {
    'use strict';
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (config_1.getFlagValue('verbose')) {
        log.apply(undefined, args);
    }
}
exports.verbose = verbose;
function generateGulpError(error) {
    if (isVerbose()) {
        return error;
    }
    else {
        /* tslint:disable:no-any */
        var output = {
            /* tslint:enable:no-any */
            showStack: false,
            toString: function () {
                return '';
            }
        };
        markErrorAsWritten(output);
        return output;
    }
}
exports.generateGulpError = generateGulpError;
/* tslint:disable:no-any */
/**
 * Logs an error to standard error and causes the build to fail.
 * @param e - the error (can be a string or Error object)
 */
function writeError(e) {
    /* tslint:enable:no-any */
    'use strict';
    if (e) {
        if (!e[WROTE_ERROR_KEY]) {
            if (e.err) {
                if (!e.err[WROTE_ERROR_KEY]) {
                    var msg = formatError(e);
                    var time = prettyTime(e.hrDuration);
                    error('\'' + gutil.colors.cyan(e.task) + '\'', gutil.colors.red(e.subTask ? 'sub task errored after' : 'errored after'), gutil.colors.magenta(time), '\r\n', msg);
                    markErrorAsWritten(e.err[WROTE_ERROR_KEY]);
                }
            }
            else if (e.fileName) {
                // This is probably a plugin error
                if (isVerbose()) {
                    error(e.message, '\r\n', e.plugin + ': \'' + gutil.colors.yellow(e.fileName) + '\':' + e.lineNumber, '\r\n', e.stack);
                }
                else {
                    error(e.message, '\r\n', e.plugin + ': \'' + gutil.colors.yellow(e.fileName) + '\':' + e.lineNumber);
                }
            }
            else {
                if (isVerbose()) {
                    error('Unknown', '\r\n', gutil.colors.red(e.message), '\r\n', e.stack);
                }
                else {
                    error('Unknown', '\r\n', gutil.colors.red(e.message));
                }
            }
            markErrorAsWritten(e);
        }
    }
    else {
        error('Unknown Error Object');
    }
}
exports.writeError = writeError;
/**
 * Returns the list of warnings which have been logged
 */
function getWarnings() {
    'use strict';
    return localCache.warnings;
}
exports.getWarnings = getWarnings;
/** Returns the list of errors which have been logged */
function getErrors() {
    'use strict';
    return localCache.errors;
}
exports.getErrors = getErrors;
function getStart() {
    'use strict';
    return localCache.start;
}
exports.getStart = getStart;
function setWatchMode() {
    'use strict';
    localCache.watchMode = true;
}
exports.setWatchMode = setWatchMode;
function getWatchMode() {
    'use strict';
    return localCache.watchMode;
}
exports.getWatchMode = getWatchMode;
function setExitCode(exitCode) {
    'use strict';
    localCache.exitCode = exitCode;
}
exports.setExitCode = setExitCode;
function logStartSubtask(name) {
    log("Starting subtask '" + gutil.colors.cyan(name) + "'...");
    localCache.subTasksRun++;
}
exports.logStartSubtask = logStartSubtask;
function logEndSubtask(name, startTime, errorObject) {
    var duration = process.hrtime(startTime);
    if (name) {
        if (!errorObject) {
            var durationString = prettyTime(duration);
            log("Finished subtask '" + gutil.colors.cyan(name) + "' after " + gutil.colors.magenta(durationString));
        }
        else {
            writeError({
                err: errorObject,
                task: name,
                subTask: true,
                hrDuration: duration
            });
        }
    }
}
exports.logEndSubtask = logEndSubtask;
function initialize(gulp, gulpErrorCallback, gulpStopCallback) {
    'use strict';
    // This will add logging to the gulp execution
    localCache.gulp = gulp;
    wireUpProcessErrorHandling();
    localCache.gulpErrorCallback = gulpErrorCallback || (function () {
        'use strict';
        // Do Nothing
    });
    localCache.gulpStopCallback = gulpStopCallback || (function () {
        'use strict';
        // Do Nothing
    });
    gulp.on('start', function (err) {
        'use strict';
        log('Starting gulp');
    });
    gulp.on('stop', function (err) {
        'use strict';
        writeSummary(function () {
            // error if we have any errors
            if (localCache.taskErrors > 0 ||
                (getWarnings().length && index_1.getConfig().shouldWarningsFailBuild) ||
                getErrors().length ||
                localCache.testsFailed > 0) {
                exitProcess(1);
            }
            localCache.gulpStopCallback(err);
            exitProcess(0);
        });
    });
    gulp.on('err', function (err) {
        'use strict';
        _writeTaskError(err);
        writeSummary(function () {
            exitProcess(1);
            localCache.gulpErrorCallback(err);
        });
    });
    /* tslint:disable:no-any */
    gulp.on('task_start', function (e) {
        /* tslint:enable:no-any */
        'use strict';
        if (localCache.fromRunGulp) {
            log('Starting', '\'' + gutil.colors.cyan(e.task) + '\'...');
        }
        localCache.taskRun++;
    });
    /* tslint:disable:no-any */
    gulp.on('task_stop', function (e) {
        /* tslint:enable:no-any */
        'use strict';
        var time = prettyTime(e.hrDuration);
        if (localCache.fromRunGulp) {
            log('Finished', '\'' + gutil.colors.cyan(e.task) + '\'', 'after', gutil.colors.magenta(time));
        }
    });
    /* tslint:disable:no-any */
    gulp.on('task_err', function (err) {
        /* tslint:enable:no-any */
        'use strict';
        _writeTaskError(err);
        writeSummary(function () {
            exitProcess(1);
        });
    });
    /* tslint:disable:no-any */
    gulp.on('task_not_found', function (err) {
        /* tslint:enable:no-any */
        'use strict';
        log(gutil.colors.red('Task \'' + err.task + '\' is not in your gulpfile'));
        log('Please check the documentation for proper gulpfile formatting');
        exitProcess(1);
    });
}
exports.initialize = initialize;
function markTaskCreationTime() {
    'use strict';
    localCache.taskCreationTime = process.hrtime(getStart());
}
exports.markTaskCreationTime = markTaskCreationTime;

//# sourceMappingURL=logging.js.map
