"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash_1 = require("lodash");
var fs = require("fs");
var merge = require("merge2");
var path = require("path");
var constants_1 = require("./../constants");
var FileUtils_1 = require("./../utilities/FileUtils");
var os_1 = require("os");
var manifestSchemaValidator_1 = require("@microsoft/sp-module-interfaces/lib/manifestSchemaValidator");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var cumulativeManifestProcessor_1 = require("./cumulativeManifest/cumulativeManifestProcessor");
var url_1 = require("./../utilities/url");
var schemaPropertyName = '$schema';
/**
 * Writes a manifest for each entry in the project.
 *
 * Example:
 *  IN:
 *   the result of the prepareDeploy step enumerating each entry, each entry's dependencies, and a developer-generated
 *    base manifest for each entry.
 *
 *  OUT:
 *   a debug and, optionally, a production manifest for each entry.
 */
var WriteManifestsTask = (function (_super) {
    __extends(WriteManifestsTask, _super);
    function WriteManifestsTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'write-manifests';
        _this.taskConfig = {
            deployCdnPath: undefined,
            debugLocale: constants_1.default.defaultLocale,
            cdnUrlPrefix: undefined,
            cdnBasePath: undefined,
            shouldWrapProductionManifestForManifestServer: false,
            cumulativeManifestOptions: {
                ignoreOutputManifestIds: undefined
            }
        };
        // tslint:disable-next-line:no-any
        _this._localizedResourcesCache = {};
        return _this;
    }
    WriteManifestsTask.prototype.loadSchema = function () {
        return require('./write-manifests.schema.json');
    };
    /**
     * Normalizes a locale name. So "en-us" becomes "en-US" and "sr-cyrl-rs" becomes "sr-Cyrl-RS". There are two special
     *  cases. For pseudo-locales like "qps-ploc", everything stays lowecase. For language-script locales like "uz-Cyrl",
     *  only the script name's first character should be uppercased.
     */
    WriteManifestsTask.prototype.normalizeLocaleName = function (localeName) {
        localeName = localeName.toLowerCase();
        var localeTokens = localeName.split('-');
        if (localeTokens.length === 2) {
            var lastToken = localeTokens[1];
            if (lastToken.length === 2) {
                localeTokens[1] = lastToken.toUpperCase();
            }
            else if (lastToken === 'ploc' || lastToken === 'plocm' || lastToken === 'ploca') {
            }
            else {
                // The second token is the script token
                localeTokens[1] = this._uppercaseFirstLetter(lastToken);
            }
        }
        else if (localeTokens.length === 3) {
            var lastToken = localeTokens[2];
            if (lastToken.length === 2) {
                localeTokens[2] = lastToken.toUpperCase();
                localeTokens[1] = this._uppercaseFirstLetter(localeTokens[1]);
            }
            else {
                // The last token is the script token
                localeTokens[2] = this._uppercaseFirstLetter(lastToken);
                localeTokens[1] = localeTokens[1].toUpperCase();
            }
        }
        var normalizedLocale = localeTokens.join('-');
        return normalizedLocale;
    };
    WriteManifestsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.properties.deployEntries || this.properties.deployEntries.length === 0) {
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy entries specified. No manifests to write.');
            completeCallback();
            return;
        }
        var shouldProduceDebugManifests = !!this.taskConfig.debugBasePath;
        if (!this.taskConfig.debugBasePath) {
            this.logWarning('Debug base path not specified. Unable to produce debug manifests.');
        }
        var shouldProduceProductionManifests = this.buildConfig.production && !!this.taskConfig.cdnBasePath;
        if (this.buildConfig.production && !this.taskConfig.cdnBasePath) {
            this.logWarning('CDN base path not specified. Unable to produce production manifests.');
        }
        if (this.buildConfig.production && !this.taskConfig.deployCdnPath) {
            shouldProduceProductionManifests = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('CDN deploy path not specified. Unable to produce production manifests.');
        }
        var debugManifests = [];
        var manifestIds = {};
        var tasks = [];
        this.properties.deployEntries.forEach(function (deployEntry) {
            if (!deployEntry.manifest) {
                _this.logWarning("Manifest not defined for entry \"" + deployEntry.entryName + "\".");
                return;
            }
            var validationResult = manifestSchemaValidator_1.default.validateManifest(JSON.stringify(deployEntry.manifest));
            if (!validationResult.result) {
                var errorText = manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors);
                _this.logError("Manifest validation error (" + deployEntry.configEntry.manifest + "): " + os_1.EOL + errorText);
                return;
            }
            // Ensure we don't have a duplicate ID
            var lowercaseId = deployEntry.manifest.id.toLowerCase();
            if (lowercaseId in manifestIds) {
                /* tslint:disable:max-line-length */
                _this.logError("Duplicate manifest ID \"" + lowercaseId + "\". Exists in \"" + manifestIds[lowercaseId].configEntry.manifest + "\" and \"" + deployEntry.configEntry.manifest + "\".");
            }
            else {
                manifestIds[lowercaseId] = deployEntry;
            }
            _this._localizeManifest(deployEntry.manifest);
            if (shouldProduceDebugManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.debugModules, [_this.taskConfig.debugBasePath], _this._resolveDebugPath.bind(_this), _this.taskConfig.debugLocale);
                var debugManifest = _this._generateManifest(deployEntry, loaderConfig);
                _this._doFinalManifestFixup(debugManifest);
                debugManifests.push(debugManifest);
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(debugManifest, undefined, 2), debugManifest.id + ".manifest.json")
                    .pipe(gulp.dest(_this.buildConfig.distFolder)));
            }
            if (shouldProduceProductionManifests) {
                var loaderConfig = _this._generateLoaderConfig(deployEntry.productionModules, [_this.taskConfig.cdnBasePath], _this._resolveProductionPath.bind(_this));
                var productionManifest = _this._generateManifest(deployEntry, loaderConfig);
                _this._doFinalManifestFixup(productionManifest);
                var cdnManifest = void 0;
                if (_this.taskConfig.shouldWrapProductionManifestForManifestServer) {
                    cdnManifest = {
                        ManifestVersion: productionManifest.manifestVersion,
                        ComponentType: productionManifest.componentType,
                        Id: productionManifest.id,
                        Manifest: JSON.stringify(productionManifest),
                        Name: productionManifest.id,
                        resources: {}
                    };
                }
                else {
                    cdnManifest = productionManifest;
                }
                tasks.push(FileUtils_1.writeStringToFile(JSON.stringify(cdnManifest), productionManifest.id + ".json")
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
            }
        });
        merge(tasks).on('finish', function () {
            // Once this project's manifests are written, crawl the dependency tree discovering manifest files
            if (shouldProduceDebugManifests) {
                var cumulativeManifestOptions = _this.taskConfig.cumulativeManifestOptions;
                cumulativeManifestOptions.baseUrl = _this.taskConfig.debugBasePath;
                var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(_this, cumulativeManifestOptions);
                merge(cumulativeManifestProcessor.generateCumulativeManifest(gulp, debugManifests))
                    .on('finish', function () { return completeCallback(); });
            }
            else {
                completeCallback();
            }
        });
    };
    /**
     * Localizes a manifest. Only works with WebPart and Application manifests,
     * otherwise it does nothing
     */
    WriteManifestsTask.prototype._localizeManifest = function (manifest) {
        switch (manifest.componentType) {
            case 'WebPart':
                // tslint:disable-next-line:no-any
                this._localizeWebPartManifest(manifest);
                break;
            case 'Application':
                this._localizeApplicationManifest(manifest);
                break;
        }
    };
    /**
     * Perform some final fixup on manifests.
     */
    WriteManifestsTask.prototype._doFinalManifestFixup = function (manifest) {
        if (manifest.componentType === 'Application') {
            var applicationManifest = manifest;
            if (!applicationManifest.preloadComponents) {
                applicationManifest.preloadComponents = [];
            }
        }
    };
    /**
     * Localizes a WebPart manifest. That includes title, description and group
     * for all preconfigured entries
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._localizeWebPartManifest = function (manifest) {
        var _this = this;
        // tslint:disable-next-line:no-any
        manifest.preconfiguredEntries.forEach(function (entry) {
            entry.title = _this._localizeString(entry.title);
            entry.description = _this._localizeString(entry.description);
            if (entry.group) {
                entry.group = _this._localizeString(entry.group);
            }
        });
    };
    /**
     * Localizes an Application manifest. This includes title and description of the Application
     */
    WriteManifestsTask.prototype._localizeApplicationManifest = function (manifest) {
        manifest.title = this._localizeString(manifest.title);
        manifest.description = this._localizeString(manifest.description);
    };
    /**
     * Localizes a string with an id in the web $moduleName:expression;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    WriteManifestsTask.prototype._localizeString = function (stringToLocalize) {
        // If there is no id, assume the property is either not localized, or the localized values are
        //  hardcoed.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        var regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<name>:<expr>;
        var matches = stringToLocalize.id.match(regex);
        if (matches && matches.length === 3) {
            this.logVerbose("Localizing string '" + matches[0] + "'");
            return this._localizeStringInternal(
            /* resourceName */ matches[1], 
            /* expression */ matches[2], 
            /* stringId */ matches[0]);
        }
        else {
            this.logError("String id '" + stringToLocalize.id + "' has wrong format. It is not $<moduleName>:<expression>;");
            // Return an empty ILocalizedString
            return {
                default: ''
            };
        }
    };
    /**
     * Localizes a string where it's been verified that the id follows the schema.
     * @param resourceName Name of the resource to load
     * @param expression Expression to be evaluated on the resource
     * @stringId Original id for the string. Used for logging purposes only
     * @returns Localized string with all found locales
     */
    WriteManifestsTask.prototype._localizeStringInternal = function (resourceName, expression, stringId) {
        var localizedString = {
            default: ''
        };
        var resources = this.properties.discoveredLocalizedResources[resourceName];
        if (resources) {
            for (var locale in resources) {
                var resource = this._getResource(resources[locale]); // tslint:disable-line:no-any
                var normalizedLocaleName = this.normalizeLocaleName(locale);
                if (resource) {
                    var evalString = expression.replace(resourceName, 'r');
                    var stringFromExpression = undefined;
                    try {
                        /* tslint:disable:no-any */
                        var shallowDiscoverProperty = function (resource, propertyName) {
                            /* tslint:enable:no-any */
                            var foundBuckets = [];
                            var firstFoundValue;
                            for (var bucketName in resource) {
                                if (resource[bucketName] && resource[bucketName][propertyName]) {
                                    firstFoundValue = resource[bucketName][propertyName];
                                    foundBuckets.push(bucketName);
                                }
                            }
                            if (!firstFoundValue) {
                                throw new Error("A value for a property \"" + propertyName + "\" was not found inside any " +
                                    "property of the resource object.");
                            }
                            if (foundBuckets.length !== 1) {
                                throw new Error("A value for a property \"" + propertyName + "\" was found inside multiple " +
                                    "properties of the resource object and must be disambiguated to be selected.");
                            }
                            return firstFoundValue;
                        };
                        // We support any format for the localized resource,
                        // so we rely on the developer telling the code how to access it.
                        // Eval generates risk. In order to minimize it, only one expression is allowed.
                        // tslint:disable-next-line:no-eval
                        stringFromExpression = eval('function getLocalizedString(r) {' +
                            'return ' + evalString +
                            '}' +
                            'getLocalizedString(resource)');
                    }
                    catch (error) {
                        this.logWarning("Problem extracting id '" + stringId + "' in locale '" + normalizedLocaleName + "'. " +
                            ("ERror: " + error));
                    }
                    if (stringFromExpression) {
                        localizedString[normalizedLocaleName] = stringFromExpression;
                    }
                    else {
                        this.logWarning("Couldn't find id '" + stringId + "' in locale '" + normalizedLocaleName + "'");
                    }
                }
            }
        }
        else {
            this.logError("Localized module '" + resourceName + "' not found");
        }
        return localizedString;
    };
    /**
     * Gets a resource file from a path.
     */
    // tslint:disable-next-line:no-any
    WriteManifestsTask.prototype._getResource = function (resourcePath) {
        if (!this._localizedResourcesCache[resourcePath]) {
            this._cacheResource(resourcePath);
        }
        return this._localizedResourcesCache[resourcePath];
    };
    /**
     * Caches a resource file from a path.
     * Because this execute in the build tools, function define is not defined,
     * so a fake function is created that will return the default element of the module.
     */
    WriteManifestsTask.prototype._cacheResource = function (resourcePath) {
        // Fake a define method to get the localizedResource module
        // tslint:disable-next-line:no-unused-variable no-any
        function define(name, deps, callback) {
            if (typeof name !== 'string') {
                callback = deps;
                deps = name;
                name = undefined;
            }
            if (!Array.isArray(deps)) {
                callback = deps;
                deps = undefined;
            }
            var exports = {}; // tslint:disable-line:no-any
            var result = callback([undefined, exports]); // tslint:disable-line:no-any
            return result.default || result || exports.default;
        }
        try {
            // We can't get the localized module dynamically at this point.
            // Reading and executing the module file in order to get the module
            var resourcesFile = fs.readFileSync(resourcePath, 'utf8');
            // tslint:disable-next-line:no-eval
            var resource = eval(resourcesFile); // tslint:disable-line:no-any
            this._localizedResourcesCache[resourcePath] = resource;
        }
        catch (error) {
            this.logError("Can't get resource '" + resourcePath + "'. " +
                "Check that the module is correct and has doesn't require any external module.");
        }
    };
    WriteManifestsTask.prototype._generateManifest = function (deployEntry, loaderConfig) {
        var manifest = lodash_1.cloneDeep(deployEntry.manifest);
        delete manifest[schemaPropertyName];
        manifest.loaderConfig = loaderConfig;
        return manifest;
    };
    WriteManifestsTask.prototype._generateLoaderConfig = function (deployModules, internalModuleBaseUrls, resolvePath, defaultLocaleOverride) {
        var _this = this;
        var scriptResources = {};
        if (deployModules.pathModules) {
            deployModules.pathModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'path';
                scriptResources[id] = module;
                module.path = resolvePath(module.path);
            });
        }
        if (deployModules.localizedPathModules) {
            deployModules.localizedPathModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'localizedPath';
                scriptResources[id] = module;
                var oldPaths = module.paths;
                module.paths = {};
                var lowercaseLocales = {};
                for (var locale in oldPaths) {
                    var path_1 = oldPaths[locale];
                    var lowercaseLocale = locale.toLowerCase();
                    var normalizedLocale = _this.normalizeLocaleName(lowercaseLocale);
                    lowercaseLocales[lowercaseLocale] = normalizedLocale;
                    module.paths[normalizedLocale] = resolvePath(path_1);
                }
                var lowercaseDefaultLocaleOverride = (defaultLocaleOverride && defaultLocaleOverride.toLowerCase)
                    ? defaultLocaleOverride.toLowerCase()
                    : undefined;
                if (lowercaseDefaultLocaleOverride && lowercaseDefaultLocaleOverride in lowercaseLocales) {
                    module.defaultPath = module.paths[lowercaseLocales[defaultLocaleOverride]];
                    delete module.paths;
                }
                else {
                    module.defaultPath = resolvePath(module.defaultPath);
                }
            });
        }
        if (deployModules.componentModules) {
            deployModules.componentModules.forEach(function (module, id) {
                // Clone the module so we can make changes to it
                module = lodash_1.cloneDeep(module);
                module.type = 'component';
                scriptResources[id] = module;
                if (module.failoverPath) {
                    module.failoverPath = resolvePath(module.failoverPath);
                }
            });
        }
        if (!(deployModules.entryModuleId in scriptResources)) {
            this.logError("Entry module \"" + deployModules.entryModuleId + "\" is missing a definition. The manifest will not " +
                'load');
        }
        var result = {
            entryModuleId: deployModules.entryModuleId,
            internalModuleBaseUrls: internalModuleBaseUrls.map(function (url) { return url_1.ensureTrailingSlash(url); }),
            scriptResources: scriptResources
        };
        return result;
    };
    WriteManifestsTask.prototype._resolveDebugPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPath)) {
                return assetPath;
            }
            else {
                return path.relative(this.buildConfig.rootPath, assetPath).replace(/\\/g, '/');
            }
        }
        else {
            return {
                default: this._resolveDebugPath(assetPath.default),
                debug: this._resolveDebugPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._resolveProductionPath = function (assetPath) {
        if (!assetPath) {
            return undefined;
        }
        if (typeof assetPath === 'string') {
            var assetPathStr = assetPath;
            // If this is a full URL, don't change it
            if (url_1.isUrl(assetPathStr)) {
                return assetPathStr;
            }
            else if (this.taskConfig.cdnUrlPrefix) {
                return url_1.joinUrlSegments(this.taskConfig.cdnUrlPrefix, assetPathStr);
            }
            else {
                return url_1.trimLeadingSlashes(assetPathStr);
            }
        }
        else {
            return {
                default: this._resolveProductionPath(assetPath.default),
                debug: this._resolveProductionPath(assetPath.debug)
            };
        }
    };
    WriteManifestsTask.prototype._uppercaseFirstLetter = function (str) {
        return "" + str.slice(0, 1).toUpperCase() + str.slice(1);
    };
    return WriteManifestsTask;
}(OdspGulpTask_1.default));
exports.WriteManifestsTask = WriteManifestsTask;

//# sourceMappingURL=WriteManifestsTask.js.map
