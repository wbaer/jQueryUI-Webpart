/// <reference types="whatwg-fetch" />
/// <reference types="es6-promise" />
import { ServiceScope } from '@microsoft/sp-core-library';
import { IFetchProvider } from '../httpClient/FetchProvider';
export declare class MockedHeader {
    name: string;
    value: string;
    constructor(name: string, value: string);
}
/**
  * Used with MockFetchProvider.fetch(), this represents a request that we happen
  * to occur.  It specifies the expected details of the request (e.g. the URL,
  * any assertions about headers, etc), along with the mocked response that should
  * be issued.
  */
export interface IMockedRequest {
    /**
     * The expected URL of the REST service request to be performed.
     */
    expectedUrl: string;
    /**
     * A list of headers to be validated.  For each item in the list, MockFetchProvider
     * will assert that it appears in Request.headers with the expected value.  In order
     * to enforce that a header is NOT present, specify its value as "undefined".
     */
    expectedRequestHeaders?: MockedHeader[];
    /**
     * The expected request body to be validated.  If undefined, no validate is performed.
     * If the value is a string, then a string comparison is performed.
     */
    expectedRequestObject?: string;
    /**
     * Optional additional assertions about the expected request, e.g. to validate headers,
     * credentials, caching options, etc.
     */
    requestAssertions?: (request: Request) => void;
    /**
     * The headers to include with the mocked response.
     */
    responseHeaders?: MockedHeader[];
    /**
     * Whether to append a "Content-Length" header to the response, calculated from
     * the responseObject.
     */
    responseContentLengthHeader?: boolean;
    /**
     * The response data that MockFetchProvider should return for this request.
     * If the object is a string, then it will be injected directly as the response.
     * Otherwise, it is assumed to be a JSON object that will be passed to JSON.stringify().
     */
    responseObject: any;
    /**
     * Optional additional headers/details for the response
     */
    responseOptions?: ResponseInit;
}
/**
 * A mock implementation of IFetchProvider, that allows a unit test to specify
 * the sequence of expected REST requests, and then validate that they occur in
 * that order.
 */
export default class MockFetchProvider implements IFetchProvider {
    private static _observeOnlyCounter;
    mockedRequest: IMockedRequest[];
    /**
     * When this is set to true, the MockFetchProvider will not actually validate
     * anything.  Instead, it will dump a console trace of all requests that it
     * receives, which you can use as a guide for writing unit test validation.
     * You still need to call expect() to supply the expected responses.
     */
    practiceRun: boolean;
    private static getNormalizedText(text);
    constructor(serviceScope: ServiceScope);
    /**
     * Adds an expected request to the internal queue.  Items will be removed from this
     * queue and validated whenever fetch() is called.
     */
    expect(mockedRequest: IMockedRequest): void;
    /**
     * Asserts that the queue is empty, e.g. to ensure that the unit test performed
     * all expected requests.
     */
    assertQueueEmpty(): void;
    /**
     * The IFetchProvider contract that we are mocking.
     */
    fetch(request: Request): Promise<Response>;
}
