webpackJsonpspModuleLoader([2],Array(388).concat([
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(407));
	__export(__webpack_require__(439));
	__export(__webpack_require__(444));
	__export(__webpack_require__(460));
	__export(__webpack_require__(410));


/***/ },
/* 389 */,
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var React = __webpack_require__(386);
	var ReactDOM = __webpack_require__(387);
	var DeveloperToolsTab_1 = __webpack_require__(391);
	var DeveloperToolsConsole_1 = __webpack_require__(393);
	var DeveloperToolsConsoleStore_1 = __webpack_require__(394);
	var DeveloperTools = (function () {
	    function DeveloperTools() {
	    }
	    Object.defineProperty(DeveloperTools, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new DeveloperTools();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DeveloperTools.prototype.initialize = function () {
	        var developerToolsDiv = document.createElement('div');
	        document.body.appendChild(developerToolsDiv);
	        ReactDOM.render(React.createElement(DeveloperToolsConsole_1.default), developerToolsDiv);
	    };
	    DeveloperTools.prototype.toggleDeveloperTools = function () {
	        DeveloperToolsConsoleStore_1.default.showHideConsole(!DeveloperToolsConsoleStore_1.default.visible);
	    };
	    DeveloperTools.prototype.showHideDeveloperTools = function (show) {
	        DeveloperToolsConsoleStore_1.default.showHideConsole(show);
	    };
	    DeveloperTools.prototype.registerDeveloperToolsTab = function (developerToolsTab) {
	        var tab = new DeveloperToolsTab_1.default(developerToolsTab);
	        DeveloperToolsConsoleStore_1.default.registerTab(tab);
	    };
	    return DeveloperTools;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DeveloperTools;


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var DeveloperTools_resx_1 = __webpack_require__(392);
	var DeveloperToolsTab = (function () {
	    function DeveloperToolsTab(parameters) {
	        var _this = this;
	        this._isLoading = false;
	        this.loadComponent = function () {
	            if (!_this._componentInitializer) {
	                return Promise.resolve(undefined);
	            }
	            if (!_this._componentInitializerPromise) {
	                _this._isLoading = true;
	                _this._componentInitializerPromise = new Promise(_this._componentInitializer)
	                    .then(function (component) {
	                    _this._isLoading = false;
	                    _this._component = component;
	                })
	                    .catch(function (error) {
	                    _this._isLoading = false;
	                    _this._loadError = error;
	                });
	            }
	            return _this._componentInitializerPromise;
	        };
	        this._title = parameters.title;
	        var componentParameters = parameters;
	        var promiseParameters = parameters;
	        if (promiseParameters.componentInitializer) {
	            this._componentInitializer = promiseParameters.componentInitializer;
	            this._isLoading = true;
	        }
	        else if (componentParameters.component) {
	            this._component = componentParameters.component;
	        }
	        else {
	            throw new Error(DeveloperTools_resx_1.default.missingDeveloperToolsTabInitFunctionError);
	        }
	    }
	    Object.defineProperty(DeveloperToolsTab.prototype, "title", {
	        get: function () {
	            return this._title;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsTab.prototype, "isLoading", {
	        get: function () {
	            return this._isLoading;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsTab.prototype, "component", {
	        get: function () {
	            return this._component;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsTab.prototype, "loadError", {
	        get: function () {
	            return this._loadError;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return DeveloperToolsTab;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DeveloperToolsTab;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var strings =  false
	    ? require('../resx-strings/en-us.json')
	    : __webpack_require__(382);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (strings['_RPELcTeq3ZByqi3N5dt18w'] || {});


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var DeveloperToolsConsoleStore_1 = __webpack_require__(394);
	var LoadingOrErrorModule_1 = __webpack_require__(545);
	var DeveloperToolsFabric_1 = __webpack_require__(388);
	var DeveloperToolsConsole_module_scss_1 = __webpack_require__(550);
	var DeveloperTools_resx_1 = __webpack_require__(392);
	var DeveloperToolsConsole = (function (_super) {
	    __extends(DeveloperToolsConsole, _super);
	    function DeveloperToolsConsole() {
	        var _this = _super.call(this) || this;
	        _this._onDrag = function (e) {
	            var mouseEvent = e; 
	            if (mouseEvent.pageY !== 0) {
	                var height = (document.documentElement.clientHeight - mouseEvent.pageY) /
	                    document.documentElement.clientHeight;
	                DeveloperToolsConsoleStore_1.default.resizeConsole(height);
	            }
	        };
	        _this._setState = function () {
	            _this.setState({
	                topPosition: DeveloperToolsConsoleStore_1.default.height,
	                visible: DeveloperToolsConsoleStore_1.default.visible,
	                tabs: DeveloperToolsConsoleStore_1.default.tabs,
	                selectedTabId: DeveloperToolsConsoleStore_1.default.selectedTabId
	            });
	        };
	        _this.state = {
	            topPosition: DeveloperToolsConsoleStore_1.default.height,
	            visible: DeveloperToolsConsoleStore_1.default.visible,
	            tabs: DeveloperToolsConsoleStore_1.default.tabs,
	            selectedTabId: DeveloperToolsConsoleStore_1.default.selectedTabId
	        };
	        return _this;
	    }
	    DeveloperToolsConsole.prototype.componentDidMount = function () {
	        DeveloperToolsConsoleStore_1.default.addListener(this._setState);
	    };
	    DeveloperToolsConsole.prototype.componentWillUnmount = function () {
	        DeveloperToolsConsoleStore_1.default.removeListener(this._setState);
	    };
	    DeveloperToolsConsole.prototype.render = function () {
	        var RENDER_NOTHING = null; 
	        if (this.state.visible) {
	            var tabs = this.state.tabs.map(function (tab, id) {
	                return React.createElement(DeveloperToolsFabric_1.PivotItem, { linkText: tab.title },
	                    React.createElement(LoadingOrErrorModule_1.default, { tab: tab }));
	            });
	            return React.createElement("div", { className: DeveloperToolsConsole_module_scss_1.default.container, style: { height: this.state.topPosition * 100 + "%" } },
	                React.createElement("div", { className: DeveloperToolsConsole_module_scss_1.default.resizeBar, draggable: true, onDrag: this._onDrag }),
	                React.createElement("div", { className: DeveloperToolsConsole_module_scss_1.default.toolsArea },
	                    React.createElement(DeveloperToolsFabric_1.Pivot, { linkSize: DeveloperToolsFabric_1.PivotLinkSize.normal, linkFormat: DeveloperToolsFabric_1.PivotLinkFormat.links }, tabs),
	                    React.createElement(DeveloperToolsFabric_1.Button, { className: DeveloperToolsConsole_module_scss_1.default.closeButton, buttonType: DeveloperToolsFabric_1.ButtonType.icon, icon: 'Cancel', rootProps: { title: DeveloperTools_resx_1.default.closeDeveloperToolsAriaLabel }, ariaLabel: DeveloperTools_resx_1.default.closeDeveloperToolsAriaLabel, onClick: function () { return DeveloperToolsConsoleStore_1.default.showHideConsole(false); } })));
	        }
	        else {
	            return RENDER_NOTHING;
	        }
	    };
	    return DeveloperToolsConsole;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DeveloperToolsConsole;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseStore_1 = __webpack_require__(395);
	var ManifestManager_1 = __webpack_require__(396);
	var PerformanceDisplay_1 = __webpack_require__(505);
	var TraceDisplay_1 = __webpack_require__(527);
	var DeveloperToolsTab_1 = __webpack_require__(391);
	var ManifestManager_resx_1 = __webpack_require__(504);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var TraceDisplay_resx_1 = __webpack_require__(532);
	var DEFAULT_HEIGHT = 1 / 4;
	var MIN_HEIGHT = 1 / 6;
	var MAX_HEIGHT = 3 / 4;
	var DeveloperToolsConsoleStore = (function (_super) {
	    __extends(DeveloperToolsConsoleStore, _super);
	    function DeveloperToolsConsoleStore() {
	        var _this = _super.call(this) || this;
	        _this._height = DEFAULT_HEIGHT;
	        _this._visible = false;
	        _this._selectedTabId = 0;
	        _this._tabs = [
	            new DeveloperToolsTab_1.default({
	                title: ManifestManager_resx_1.default.tabTitle,
	                component: ManifestManager_1.default
	            }),
	            new DeveloperToolsTab_1.default({
	                title: PerformanceDisplay_resx_1.default.TabTitle,
	                component: PerformanceDisplay_1.default
	            }),
	            new DeveloperToolsTab_1.default({
	                title: TraceDisplay_resx_1.default.TabTitle,
	                component: TraceDisplay_1.default
	            })
	        ];
	        return _this;
	    }
	    Object.defineProperty(DeveloperToolsConsoleStore, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new DeveloperToolsConsoleStore();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsConsoleStore.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsConsoleStore.prototype, "visible", {
	        get: function () {
	            return this._visible;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsConsoleStore.prototype, "selectedTabId", {
	        get: function () {
	            return this._selectedTabId;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DeveloperToolsConsoleStore.prototype, "tabs", {
	        get: function () {
	            return this._tabs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DeveloperToolsConsoleStore.prototype.resizeConsole = function (height) {
	        var newHeight = this._height;
	        if (height >= MAX_HEIGHT) {
	            newHeight = MAX_HEIGHT;
	        }
	        else if (height <= MIN_HEIGHT) {
	            newHeight = MIN_HEIGHT;
	        }
	        else {
	            newHeight = height;
	        }
	        if (newHeight !== this._height) {
	            this._height = newHeight;
	            this.emitChange();
	        }
	    };
	    DeveloperToolsConsoleStore.prototype.showHideConsole = function (show) {
	        if (this._visible !== show) {
	            this._visible = show;
	            this.emitChange();
	        }
	    };
	    DeveloperToolsConsoleStore.prototype.registerTab = function (tab) {
	        this._tabs.push(tab);
	        if (this._tabs.length === 1) {
	            this._selectedTabId = 0;
	        }
	        this.emitChange();
	    };
	    return DeveloperToolsConsoleStore;
	}(BaseStore_1.default));
	exports.DeveloperToolsConsoleStore = DeveloperToolsConsoleStore;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = DeveloperToolsConsoleStore.instance; 


/***/ },
/* 395 */
/***/ function(module, exports) {

	"use strict";
	var BaseStore = (function () {
	    function BaseStore() {
	        this._isDisposed = false;
	        this._listeners = [];
	        this._isDisposed = false;
	    }
	    BaseStore.prototype.addListener = function (listener) {
	        if (!this._isDisposed) {
	            this._listeners.push(listener);
	        }
	    };
	    BaseStore.prototype.removeListener = function (listener) {
	        if (!this._isDisposed) {
	            var listenerIdx = this._listeners.indexOf(listener);
	            if (listenerIdx > -1) {
	                this._listeners.splice(listenerIdx, 1);
	            }
	        }
	    };
	    BaseStore.prototype.removeAllListeners = function () {
	        this._listeners = [];
	    };
	    BaseStore.prototype.count = function () {
	        return !this._isDisposed ? this._listeners.length : 0;
	    };
	    BaseStore.prototype.emitChange = function () {
	        if (!this._isDisposed) {
	            this._listeners.forEach(function (listener) { return listener(); });
	        }
	    };
	    BaseStore.prototype.dispose = function () {
	        if (!this._isDisposed) {
	            this._listeners.splice(0);
	            this._listeners = [];
	            this._isDisposed = true;
	        }
	    };
	    return BaseStore;
	}());
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = BaseStore;


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var ManifestStore_1 = __webpack_require__(397);
	var ManifestDetails_1 = __webpack_require__(403);
	var DeveloperToolsFabric_1 = __webpack_require__(388);
	var ManifestManager_module_scss_1 = __webpack_require__(501);
	var ManifestManager_resx_1 = __webpack_require__(504);
	var ManifestManager = (function (_super) {
	    __extends(ManifestManager, _super);
	    function ManifestManager() {
	        var _this = _super.call(this) || this;
	        _this._selection = new DeveloperToolsFabric_1.Selection({
	            getKey: function (item) { return item.id; },
	            onSelectionChanged: function () {
	                var selectedModule = _this._selection.getSelection()[0];
	                if (!selectedModule) {
	                    ManifestManager._selectedManifestId = undefined;
	                }
	                else {
	                    ManifestManager._selectedManifestId = selectedModule.id;
	                }
	                _this.setState(_this.getUpdatedState());
	            }
	        });
	        _this.state = _this.getUpdatedState();
	        return _this;
	    }
	    ManifestManager.prototype.render = function () {
	        var selectedManifest = this.state.selectedManifest;
	        var manifestDetailsBox = selectedManifest
	            ? React.createElement(ManifestDetails_1.default, { manifest: selectedManifest })
	            : React.createElement("div", { className: ManifestManager_module_scss_1.default.noManifestSelectedContainer },
	                React.createElement("div", null, ManifestManager_resx_1.default.noManifestSelected));
	        var columns = [{
	                key: 'alias',
	                name: 'alias',
	                fieldName: 'alias',
	                minWidth: 100,
	                maxWidth: 150,
	                onRender: function (item) { return React.createElement("span", null, item.manifest.alias); }
	            },
	            {
	                key: 'id',
	                name: 'id',
	                fieldName: 'id',
	                minWidth: 300,
	                maxWidth: 300
	            }];
	        return React.createElement("div", { className: ManifestManager_module_scss_1.default.container },
	            React.createElement("div", { className: ManifestManager_module_scss_1.default.manifestListContainer },
	                React.createElement(DeveloperToolsFabric_1.DetailsList, { items: this.state.manifests, columns: columns, isHeaderVisible: false, selectionMode: DeveloperToolsFabric_1.SelectionMode.single, selection: this._selection, setKey: 'set', constrainMode: DeveloperToolsFabric_1.ConstrainMode.unconstrained })),
	            React.createElement("div", { className: ManifestManager_module_scss_1.default.manifestDetailsContainer }, manifestDetailsBox));
	    };
	    ManifestManager.prototype.getUpdatedState = function () {
	        var manifestMap = ManifestStore_1.default.instance.getManifestMap();
	        return {
	            manifests: (Object.keys(manifestMap)).map(function (id) { return manifestMap[id]; }),
	            selectedManifest: ManifestManager._selectedManifestId ?
	                manifestMap[ManifestManager._selectedManifestId] :
	                undefined 
	        };
	    };
	    ;
	    return ManifestManager;
	}(React.Component));
	ManifestManager._selectedManifestId = undefined;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ManifestManager;


/***/ },
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var ManifestDetails_module_scss_1 = __webpack_require__(404);
	var ManifestDetails = (function (_super) {
	    __extends(ManifestDetails, _super);
	    function ManifestDetails() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ManifestDetails.prototype.render = function () {
	        var manifestText = JSON.stringify(this.props.manifest.manifest, undefined, 2);
	        return React.createElement("div", { className: ManifestDetails_module_scss_1.default.container },
	            React.createElement("div", { className: ManifestDetails_module_scss_1.default.manifestIdHeading }, this.props.manifest.id),
	            React.createElement("textarea", { className: ManifestDetails_module_scss_1.default.manifestTextBox, readOnly: true, value: manifestText }));
	    };
	    return ManifestDetails;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ManifestDetails;


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(405);
	var styles = {
	    container: 'container_3fb808a1',
	    manifestIdHeading: 'manifestIdHeading_3fb808a1',
	    manifestTextBox: 'manifestTextBox_3fb808a1',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(406);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_3fb808a1{display:block;height:100%}.manifestIdHeading_3fb808a1{font-size:large}.manifestTextBox_3fb808a1{width:100%;height:calc(100% - 3em);resize:none;border:none;outline:0}", ""]);
	
	// exports


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(408));
	


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(409));
	var PivotItem_1 = __webpack_require__(436);
	exports.PivotItem = PivotItem_1.PivotItem;
	__export(__webpack_require__(437));
	


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var FocusZone_1 = __webpack_require__(432);
	var PivotItem_1 = __webpack_require__(436);
	var Pivot_Props_1 = __webpack_require__(437);
	var Pivot_Props_2 = __webpack_require__(437);
	__webpack_require__(438);
	var Pivot = (function (_super) {
	    __extends(Pivot, _super);
	    function Pivot(props) {
	        var _this = _super.call(this, props) || this;
	        _this._pivotId = Utilities_1.getId('Pivot');
	        var links = _this._getPivotLinks(_this.props);
	        var selectedKey;
	        if (props.initialSelectedKey) {
	            selectedKey = props.initialSelectedKey;
	        }
	        else if (props.initialSelectedIndex) {
	            selectedKey = links[props.initialSelectedIndex].itemKey;
	        }
	        else if (props.selectedKey) {
	            selectedKey = props.selectedKey;
	        }
	        else if (links.length) {
	            selectedKey = links[0].itemKey;
	        }
	        _this.state = {
	            links: links,
	            selectedKey: selectedKey,
	            selectedTabId: _this._keyToTabIds[selectedKey],
	        };
	        _this._renderLink = _this._renderLink.bind(_this);
	        return _this;
	    }
	    Pivot.prototype.componentWillReceiveProps = function (nextProps) {
	        var _this = this;
	        var links = this._getPivotLinks(nextProps);
	        this.setState(function (prevState, props) {
	            var selectedKey;
	            if (_this._isKeyValid(nextProps.selectedKey)) {
	                selectedKey = nextProps.selectedKey;
	            }
	            else if (_this._isKeyValid(prevState.selectedKey)) {
	                selectedKey = prevState.selectedKey;
	            }
	            else if (links.length) {
	                selectedKey = links[0].itemKey;
	            }
	            return {
	                links: links,
	                selectedKey: selectedKey,
	                selectedTabId: _this._keyToTabIds[selectedKey],
	            };
	        });
	    };
	    Pivot.prototype.render = function () {
	        return (React.createElement("div", null,
	            this._renderPivotLinks(),
	            this._renderPivotItem()));
	    };
	    /**
	     * Renders the set of links to route between pivots
	     */
	    Pivot.prototype._renderPivotLinks = function () {
	        return (React.createElement(FocusZone_1.FocusZone, { direction: FocusZone_1.FocusZoneDirection.horizontal },
	            React.createElement("ul", { className: Utilities_1.css('ms-Pivot', { 'ms-Pivot--large': this.props.linkSize === Pivot_Props_2.PivotLinkSize.large }, { 'ms-Pivot--tabs': this.props.linkFormat === Pivot_Props_1.PivotLinkFormat.tabs }), role: 'tablist' }, this.state.links.map(this._renderLink))));
	    };
	    /**
	     * Renders a pivot link
	     */
	    Pivot.prototype._renderLink = function (link) {
	        var itemKey = link.itemKey, itemCount = link.itemCount, itemIcon = link.itemIcon, linkText = link.linkText;
	        var tabId = this._keyToTabIds[itemKey];
	        var count;
	        if (itemCount !== undefined) {
	            count = React.createElement("span", { className: 'ms-Pivot-count' },
	                "(",
	                itemCount,
	                ")");
	        }
	        var icon;
	        if (itemIcon !== undefined) {
	            icon = React.createElement("span", { className: 'ms-Pivot-icon' },
	                React.createElement("i", { className: "ms-Icon ms-Icon--" + itemIcon }));
	        }
	        var text;
	        if (linkText !== undefined) {
	            text = React.createElement("span", { className: 'ms-Pivot-text' }, link.linkText);
	        }
	        return (React.createElement("button", { id: tabId, key: itemKey, className: Utilities_1.css('ms-Pivot-link', { 'is-selected': this.state.selectedKey === itemKey }), onClick: this._onLinkClick.bind(this, itemKey), onKeyPress: this._onKeyPress.bind(this, itemKey), "aria-label": link.ariaLabel, role: 'tab', "aria-selected": this.state.selectedKey === itemKey },
	            icon,
	            text,
	            count));
	    };
	    /**
	     * Renders the current Pivot Item
	     */
	    Pivot.prototype._renderPivotItem = function () {
	        var itemKey = this.state.selectedKey;
	        var index = this._keyToIndexMapping[itemKey];
	        var selectedTabId = this.state.selectedTabId;
	        return (React.createElement("div", { className: 'pivotItem', role: 'tabpanel', "aria-labelledby": selectedTabId }, React.Children.toArray(this.props.children)[index]));
	    };
	    /**
	     * Gets the set of PivotLinks as arrary of IPivotItemProps
	     * The set of Links is determined by child components of type PivotItem
	     */
	    Pivot.prototype._getPivotLinks = function (props) {
	        var _this = this;
	        var links = [];
	        this._keyToIndexMapping = {};
	        this._keyToTabIds = {};
	        React.Children.map(props.children, function (child, index) {
	            if (typeof child === 'object' && child.type === PivotItem_1.PivotItem) {
	                var pivotItem = child;
	                var itemKey = pivotItem.props.itemKey || index.toString();
	                links.push({
	                    linkText: pivotItem.props.linkText,
	                    ariaLabel: pivotItem.props.ariaLabel,
	                    itemKey: itemKey,
	                    itemCount: pivotItem.props.itemCount,
	                    itemIcon: pivotItem.props.itemIcon
	                });
	                _this._keyToIndexMapping[itemKey] = index;
	                _this._keyToTabIds[itemKey] = _this._pivotId + ("-Tab" + index);
	            }
	        });
	        return links;
	    };
	    /**
	     * whether the key exists in the pivot items.
	     */
	    Pivot.prototype._isKeyValid = function (itemKey) {
	        return itemKey !== undefined && this._keyToIndexMapping[itemKey] !== undefined;
	    };
	    /**
	     * Handles the onClick event on PivotLinks
	     */
	    Pivot.prototype._onLinkClick = function (itemKey, ev) {
	        ev.preventDefault();
	        this._updateSelectedItem(itemKey, ev);
	    };
	    /**
	     * Handle the onKeyPress eventon the PivotLinks
	     */
	    Pivot.prototype._onKeyPress = function (itemKey, ev) {
	        ev.preventDefault();
	        if (ev.which === Utilities_1.KeyCodes.enter) {
	            this._updateSelectedItem(itemKey);
	        }
	    };
	    /**
	     * Updates the state with the new selected index
	     */
	    Pivot.prototype._updateSelectedItem = function (itemKey, ev) {
	        this.setState({
	            selectedKey: itemKey,
	            selectedTabId: this._keyToTabIds[itemKey]
	        });
	        if (this.props.onLinkClick && this._keyToIndexMapping[itemKey] >= 0) {
	            var index = this._keyToIndexMapping[itemKey];
	            // React.Element<any> cannot directly convert to PivotItem.
	            var item = React.Children.toArray(this.props.children)[index];
	            if (typeof item === 'object' && item.type === PivotItem_1.PivotItem) {
	                this.props.onLinkClick(item, ev);
	            }
	        }
	    };
	    return Pivot;
	}(React.Component));
	exports.Pivot = Pivot;
	


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(411));
	


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(412));
	__export(__webpack_require__(413));
	__export(__webpack_require__(417));
	__export(__webpack_require__(418));
	__export(__webpack_require__(414));
	__export(__webpack_require__(419));
	__export(__webpack_require__(420));
	__export(__webpack_require__(421));
	__export(__webpack_require__(422));
	__export(__webpack_require__(423));
	__export(__webpack_require__(416));
	__export(__webpack_require__(424));
	__export(__webpack_require__(425));
	__export(__webpack_require__(426));
	__export(__webpack_require__(427));
	__export(__webpack_require__(428));
	__export(__webpack_require__(429));
	__export(__webpack_require__(430));
	__export(__webpack_require__(415));
	__export(__webpack_require__(431));
	


/***/ },
/* 412 */
/***/ function(module, exports) {

	/**
	 * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
	 * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
	 *
	 * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
	 * new instance of the class and remember to call dispose() during your code's dispose handler.
	 */
	"use strict";
	var Async = (function () {
	    function Async(parent, onError) {
	        this._timeoutIds = null;
	        this._immediateIds = null;
	        this._intervalIds = null;
	        this._animationFrameIds = null;
	        this._isDisposed = false;
	        this._parent = parent || null;
	        this._onErrorHandler = onError;
	        this._noop = function () { };
	    }
	    /**
	     * Dispose function, clears all async operations.
	     */
	    Async.prototype.dispose = function () {
	        var id;
	        this._isDisposed = true;
	        this._parent = null;
	        // Clear timeouts.
	        if (this._timeoutIds) {
	            for (id in this._timeoutIds) {
	                if (this._timeoutIds.hasOwnProperty(id)) {
	                    this.clearTimeout(id);
	                }
	            }
	            this._timeoutIds = null;
	        }
	        // Clear immediates.
	        if (this._immediateIds) {
	            for (id in this._immediateIds) {
	                if (this._immediateIds.hasOwnProperty(id)) {
	                    this.clearImmediate(id);
	                }
	            }
	            this._immediateIds = null;
	        }
	        // Clear intervals.
	        if (this._intervalIds) {
	            for (id in this._intervalIds) {
	                if (this._intervalIds.hasOwnProperty(id)) {
	                    this.clearInterval(id);
	                }
	            }
	            this._intervalIds = null;
	        }
	        // Clear animation frames.
	        if (this._animationFrameIds) {
	            for (id in this._animationFrameIds) {
	                if (this._animationFrameIds.hasOwnProperty(id)) {
	                    this.cancelAnimationFrame(id);
	                }
	            }
	            this._animationFrameIds = null;
	        }
	    };
	    /**
	     * SetTimeout override, which will auto cancel the timeout during dispose.
	     * @param callback Callback to execute.
	     * @param duration Duration in milliseconds.
	     * @return The setTimeout id.
	     */
	    Async.prototype.setTimeout = function (callback, duration) {
	        var _this = this;
	        var timeoutId = 0;
	        if (!this._isDisposed) {
	            if (!this._timeoutIds) {
	                this._timeoutIds = {};
	            }
	            /* tslint:disable:ban-native-functions */
	            timeoutId = setTimeout(function () {
	                // Time to execute the timeout, enqueue it as a foreground task to be executed.
	                try {
	                    // Now delete the record and call the callback.
	                    delete _this._timeoutIds[timeoutId];
	                    callback.apply(_this._parent);
	                }
	                catch (e) {
	                    if (_this._onErrorHandler) {
	                        _this._onErrorHandler(e);
	                    }
	                }
	            }, duration);
	            /* tslint:enable:ban-native-functions */
	            this._timeoutIds[timeoutId] = true;
	        }
	        return timeoutId;
	    };
	    /**
	     * Clears the timeout.
	     * @param id Id to cancel.
	     */
	    Async.prototype.clearTimeout = function (id) {
	        if (this._timeoutIds && this._timeoutIds[id]) {
	            /* tslint:disable:ban-native-functions */
	            clearTimeout(id);
	            delete this._timeoutIds[id];
	        }
	    };
	    /**
	     * SetImmediate override, which will auto cancel the immediate during dispose.
	     * @param callback Callback to execute.
	     * @return The setTimeout id.
	     */
	    Async.prototype.setImmediate = function (callback) {
	        var _this = this;
	        var immediateId = 0;
	        if (!this._isDisposed) {
	            if (!this._immediateIds) {
	                this._immediateIds = {};
	            }
	            /* tslint:disable:ban-native-functions */
	            var setImmediateCallback = function () {
	                // Time to execute the timeout, enqueue it as a foreground task to be executed.
	                try {
	                    // Now delete the record and call the callback.
	                    delete _this._immediateIds[immediateId];
	                    callback.apply(_this._parent);
	                }
	                catch (e) {
	                    _this._logError(e);
	                }
	            };
	            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);
	            /* tslint:enable:ban-native-functions */
	            this._immediateIds[immediateId] = true;
	        }
	        return immediateId;
	    };
	    /**
	     * Clears the immediate.
	     * @param id Id to cancel.
	     */
	    Async.prototype.clearImmediate = function (id) {
	        if (this._immediateIds && this._immediateIds[id]) {
	            /* tslint:disable:ban-native-functions */
	            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);
	            delete this._immediateIds[id];
	        }
	    };
	    /**
	     * SetInterval override, which will auto cancel the timeout during dispose.
	     * @param callback Callback to execute.
	     * @param duration Duration in milliseconds.
	     * @return The setTimeout id.
	     */
	    Async.prototype.setInterval = function (callback, duration) {
	        var _this = this;
	        var intervalId = 0;
	        if (!this._isDisposed) {
	            if (!this._intervalIds) {
	                this._intervalIds = {};
	            }
	            /* tslint:disable:ban-native-functions */
	            intervalId = setInterval(function () {
	                // Time to execute the interval callback, enqueue it as a foreground task to be executed.
	                try {
	                    callback.apply(_this._parent);
	                }
	                catch (e) {
	                    _this._logError(e);
	                }
	            }, duration);
	            /* tslint:enable:ban-native-functions */
	            this._intervalIds[intervalId] = true;
	        }
	        return intervalId;
	    };
	    /**
	     * Clears the interval.
	     * @param id Id to cancel.
	     */
	    Async.prototype.clearInterval = function (id) {
	        if (this._intervalIds && this._intervalIds[id]) {
	            /* tslint:disable:ban-native-functions */
	            clearInterval(id);
	            delete this._intervalIds[id];
	        }
	    };
	    /**
	     * Creates a function that, when executed, will only call the func function at most once per
	     * every wait milliseconds. Provide an options object to indicate that func should be invoked
	     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
	     * function will return the result of the last func call.
	     *
	     * Note: If leading and trailing options are true func will be called on the trailing edge of
	     * the timeout only if the the throttled function is invoked more than once during the wait timeout.
	     *
	     * @param func The function to throttle.
	     * @param wait The number of milliseconds to throttle executions to. Defaults to 0.
	     * @param options The options object.
	     * @param options.leading Specify execution on the leading edge of the timeout.
	     * @param options.trailing Specify execution on the trailing edge of the timeout.
	     * @return The new throttled function.
	     */
	    Async.prototype.throttle = function (func, wait, options) {
	        var _this = this;
	        if (this._isDisposed) {
	            return this._noop;
	        }
	        var waitMS = wait || 0;
	        var leading = true;
	        var trailing = true;
	        var lastExecuteTime = 0;
	        var lastResult;
	        var lastArgs;
	        var timeoutId = null;
	        if (options && typeof (options.leading) === 'boolean') {
	            leading = options.leading;
	        }
	        if (options && typeof (options.trailing) === 'boolean') {
	            trailing = options.trailing;
	        }
	        var callback = function (userCall) {
	            var now = (new Date).getTime();
	            var delta = now - lastExecuteTime;
	            var waitLength = leading ? waitMS - delta : waitMS;
	            if (delta >= waitMS && (!userCall || leading)) {
	                lastExecuteTime = now;
	                if (timeoutId) {
	                    _this.clearTimeout(timeoutId);
	                    timeoutId = null;
	                }
	                lastResult = func.apply(_this._parent, lastArgs);
	            }
	            else if (timeoutId === null && trailing) {
	                timeoutId = _this.setTimeout(callback, waitLength);
	            }
	            return lastResult;
	        };
	        var resultFunction = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            lastArgs = args;
	            return callback(true);
	        };
	        return resultFunction;
	    };
	    /**
	     * Creates a function that will delay the execution of func until after wait milliseconds have
	     * elapsed since the last time it was invoked. Provide an options object to indicate that func
	     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
	     * to the debounced function will return the result of the last func call.
	     *
	     * Note: If leading and trailing options are true func will be called on the trailing edge of
	     * the timeout only if the the debounced function is invoked more than once during the wait
	     * timeout.
	     *
	     * @param func The function to debounce.
	     * @param wait The number of milliseconds to delay.
	     * @param options The options object.
	     * @param options.leading Specify execution on the leading edge of the timeout.
	     * @param options.maxWait The maximum time func is allowed to be delayed before it's called.
	     * @param options.trailing Specify execution on the trailing edge of the timeout.
	     * @return The new debounced function.
	     */
	    Async.prototype.debounce = function (func, wait, options) {
	        var _this = this;
	        if (this._isDisposed) {
	            return this._noop;
	        }
	        var waitMS = wait || 0;
	        var leading = false;
	        var trailing = true;
	        var maxWait = null;
	        var lastCallTime = 0;
	        var lastExecuteTime = (new Date).getTime();
	        var lastResult;
	        var lastArgs;
	        var timeoutId = null;
	        if (options && typeof (options.leading) === 'boolean') {
	            leading = options.leading;
	        }
	        if (options && typeof (options.trailing) === 'boolean') {
	            trailing = options.trailing;
	        }
	        if (options && typeof (options.maxWait) === 'number' && !isNaN(options.maxWait)) {
	            maxWait = options.maxWait;
	        }
	        var callback = function (userCall) {
	            var now = (new Date).getTime();
	            var executeImmediately = false;
	            if (userCall) {
	                if (leading && now - lastCallTime >= waitMS) {
	                    executeImmediately = true;
	                }
	                lastCallTime = now;
	            }
	            var delta = now - lastCallTime;
	            var waitLength = waitMS - delta;
	            var maxWaitDelta = now - lastExecuteTime;
	            var maxWaitExpired = false;
	            if (maxWait !== null) {
	                // maxWait only matters when there is a pending callback
	                if (maxWaitDelta >= maxWait && timeoutId) {
	                    maxWaitExpired = true;
	                }
	                else {
	                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
	                }
	            }
	            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
	                if (timeoutId) {
	                    _this.clearTimeout(timeoutId);
	                    timeoutId = null;
	                }
	                lastExecuteTime = now;
	                lastResult = func.apply(_this._parent, lastArgs);
	            }
	            else if ((timeoutId === null || !userCall) && trailing) {
	                timeoutId = _this.setTimeout(callback, waitLength);
	            }
	            return lastResult;
	        };
	        var resultFunction = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            lastArgs = args;
	            return callback(true);
	        };
	        return resultFunction;
	    };
	    Async.prototype.requestAnimationFrame = function (callback) {
	        var _this = this;
	        var animationFrameId = 0;
	        if (!this._isDisposed) {
	            if (!this._animationFrameIds) {
	                this._animationFrameIds = {};
	            }
	            /* tslint:disable:ban-native-functions */
	            var animationFrameCallback = function () {
	                try {
	                    // Now delete the record and call the callback.
	                    delete _this._animationFrameIds[animationFrameId];
	                    callback.apply(_this._parent);
	                }
	                catch (e) {
	                    _this._logError(e);
	                }
	            };
	            animationFrameId = window.requestAnimationFrame ?
	                window.requestAnimationFrame(animationFrameCallback) :
	                window.setTimeout(animationFrameCallback, 0);
	            /* tslint:enable:ban-native-functions */
	            this._animationFrameIds[animationFrameId] = true;
	        }
	        return animationFrameId;
	    };
	    Async.prototype.cancelAnimationFrame = function (id) {
	        if (this._animationFrameIds && this._animationFrameIds[id]) {
	            /* tslint:disable:ban-native-functions */
	            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);
	            /* tslint:enable:ban-native-functions */
	            delete this._animationFrameIds[id];
	        }
	    };
	    Async.prototype._logError = function (e) {
	        if (this._onErrorHandler) {
	            this._onErrorHandler(e);
	        }
	    };
	    return Async;
	}());
	exports.Async = Async;
	


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EventGroup_1 = __webpack_require__(414);
	var scroll_1 = __webpack_require__(415);
	var dom_1 = __webpack_require__(416);
	var SCROLL_ITERATION_DELAY = 16;
	var SCROLL_GUTTER_HEIGHT = 100;
	var MAX_SCROLL_VELOCITY = 15;
	/**
	 * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container
	 * up/down depending on how close the mouse is to the top/bottom of the container.
	 *
	 * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.
	 */
	var AutoScroll = (function () {
	    function AutoScroll(element) {
	        this._events = new EventGroup_1.EventGroup(this);
	        this._scrollableParent = scroll_1.findScrollableParent(element);
	        this._incrementScroll = this._incrementScroll.bind(this);
	        this._scrollRect = dom_1.getRect(this._scrollableParent);
	        if (this._scrollableParent === window) {
	            this._scrollableParent = document.body;
	        }
	        if (this._scrollableParent) {
	            this._events.on(window, 'mousemove', this._onMouseMove, true);
	        }
	    }
	    AutoScroll.prototype.dispose = function () {
	        this._events.dispose();
	        this._stopScroll();
	    };
	    AutoScroll.prototype._onMouseMove = function (ev) {
	        var scrollRectTop = this._scrollRect.top;
	        var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER_HEIGHT;
	        if (ev.clientY < (scrollRectTop + SCROLL_GUTTER_HEIGHT)) {
	            this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER_HEIGHT - (ev.clientY - scrollRectTop)) / SCROLL_GUTTER_HEIGHT));
	        }
	        else if (ev.clientY > scrollClientBottom) {
	            this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((ev.clientY - scrollClientBottom) / SCROLL_GUTTER_HEIGHT));
	        }
	        else {
	            this._scrollVelocity = 0;
	        }
	        if (this._scrollVelocity) {
	            this._startScroll();
	        }
	        else {
	            this._stopScroll();
	        }
	    };
	    AutoScroll.prototype._startScroll = function () {
	        if (!this._timeoutId) {
	            this._incrementScroll();
	        }
	    };
	    AutoScroll.prototype._incrementScroll = function () {
	        this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
	        this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
	    };
	    AutoScroll.prototype._stopScroll = function () {
	        if (this._timeoutId) {
	            clearTimeout(this._timeoutId);
	            delete this._timeoutId;
	        }
	    };
	    return AutoScroll;
	}());
	exports.AutoScroll = AutoScroll;
	


/***/ },
/* 414 */
/***/ function(module, exports) {

	/* tslint:disable:no-string-literal */
	"use strict";
	/** An instance of EventGroup allows anything with a handle to it to trigger events on it.
	 *  If the target is an HTMLElement, the event will be attached to the element and can be
	 *  triggered as usual (like clicking for onclick).
	 *  The event can be triggered by calling EventGroup.raise() here. If the target is an
	 *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
	 *  handled here in EventGroup, and the handler is called in the context of the parent
	 *  (which is passed in in the constructor).
	 */
	var EventGroup = (function () {
	    /** parent: the context in which events attached to non-HTMLElements are called */
	    function EventGroup(parent) {
	        this._id = EventGroup._uniqueId++;
	        this._parent = parent;
	        this._eventRecords = [];
	    }
	    /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.
	     *  Events raised here by default have bubbling set to false and cancelable set to true.
	     *  This applies also to built-in events being raised manually here on HTMLElements,
	     *  which may lead to unexpected behavior if it differs from the defaults.
	     */
	    EventGroup.raise = function (target, eventName, eventArgs, bubbleEvent) {
	        var retVal;
	        if (EventGroup._isElement(target)) {
	            if (document.createEvent) {
	                var ev = document.createEvent('HTMLEvents');
	                ev.initEvent(eventName, bubbleEvent, true);
	                ev['args'] = eventArgs;
	                retVal = target.dispatchEvent(ev);
	            }
	            else if (document['createEventObject']) {
	                var evObj = document['createEventObject'](eventArgs);
	                // cannot set cancelBubble on evObj, fireEvent will overwrite it
	                target.fireEvent('on' + eventName, evObj);
	            }
	        }
	        else {
	            while (target && retVal !== false) {
	                var events = target.__events__;
	                var eventRecords = events ? events[eventName] : null;
	                for (var id in eventRecords) {
	                    if (eventRecords.hasOwnProperty(id)) {
	                        var eventRecordList = eventRecords[id];
	                        for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
	                            var record = eventRecordList[listIndex];
	                            if (record.objectCallback) {
	                                retVal = record.objectCallback.call(record.parent, eventArgs);
	                            }
	                        }
	                    }
	                }
	                // If the target has a parent, bubble the event up.
	                target = bubbleEvent ? target.parent : null;
	            }
	        }
	        return retVal;
	    };
	    EventGroup.isObserved = function (target, eventName) {
	        var events = target && target.__events__;
	        return !!events && !!events[eventName];
	    };
	    /** Check to see if the target has declared support of the given event. */
	    EventGroup.isDeclared = function (target, eventName) {
	        var declaredEvents = target && target.__declaredEvents;
	        return !!declaredEvents && !!declaredEvents[eventName];
	    };
	    EventGroup.stopPropagation = function (event) {
	        if (event.stopPropagation) {
	            event.stopPropagation();
	        }
	        else {
	            event.cancelBubble = true;
	        }
	    };
	    EventGroup._isElement = function (target) {
	        return !!target && (target.addEventListener || target instanceof HTMLElement);
	    };
	    EventGroup.prototype.dispose = function () {
	        if (!this._isDisposed) {
	            this._isDisposed = true;
	            this.off();
	            this._parent = null;
	        }
	    };
	    /** On the target, attach a set of events, where the events object is a name to function mapping. */
	    EventGroup.prototype.onAll = function (target, events, useCapture) {
	        for (var eventName in events) {
	            if (events.hasOwnProperty(eventName)) {
	                this.on(target, eventName, events[eventName], useCapture);
	            }
	        }
	    };
	    /** On the target, attach an event whose handler will be called in the context of the parent
	     * of this instance of EventGroup.
	     */
	    EventGroup.prototype.on = function (target, eventName, callback, useCapture) {
	        var _this = this;
	        if (eventName.indexOf(',') > -1) {
	            var events = eventName.split(/[ ,]+/);
	            for (var i = 0; i < events.length; i++) {
	                this.on(target, events[i], callback, useCapture);
	            }
	        }
	        else {
	            var parent_1 = this._parent;
	            var eventRecord = {
	                target: target,
	                eventName: eventName,
	                parent: parent_1,
	                callback: callback,
	                objectCallback: null,
	                elementCallback: null,
	                useCapture: useCapture
	            };
	            // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
	            var events = (target.__events__ = target.__events__ || {});
	            events[eventName] = events[eventName] || {
	                count: 0
	            };
	            events[eventName][this._id] = events[eventName][this._id] || [];
	            events[eventName][this._id].push(eventRecord);
	            events[eventName].count++;
	            if (EventGroup._isElement(target)) {
	                var processElementEvent = function () {
	                    var args = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        args[_i] = arguments[_i];
	                    }
	                    if (_this._isDisposed) {
	                        return;
	                    }
	                    var result;
	                    try {
	                        result = callback.apply(parent_1, args);
	                        if (result === false && args[0]) {
	                            var e = args[0];
	                            if (e.preventDefault) {
	                                e.preventDefault();
	                            }
	                            if (e.stopPropagation) {
	                                e.stopPropagation();
	                            }
	                            e.cancelBubble = true;
	                        }
	                    }
	                    catch (e) {
	                    }
	                    return result;
	                };
	                eventRecord.elementCallback = processElementEvent;
	                if (target.addEventListener) {
	                    /* tslint:disable:ban-native-functions */
	                    target.addEventListener(eventName, processElementEvent, useCapture);
	                }
	                else if (target.attachEvent) {
	                    target.attachEvent('on' + eventName, processElementEvent);
	                }
	            }
	            else {
	                var processObjectEvent = function () {
	                    var args = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        args[_i] = arguments[_i];
	                    }
	                    if (_this._isDisposed) {
	                        return;
	                    }
	                    return callback.apply(parent_1, args);
	                };
	                eventRecord.objectCallback = processObjectEvent;
	            }
	            // Remember the record locally, so that it can be removed.
	            this._eventRecords.push(eventRecord);
	        }
	    };
	    EventGroup.prototype.off = function (target, eventName, callback, useCapture) {
	        for (var i = 0; i < this._eventRecords.length; i++) {
	            var eventRecord = this._eventRecords[i];
	            if ((!target || target === eventRecord.target) &&
	                (!eventName || eventName === eventRecord.eventName) &&
	                (!callback || callback === eventRecord.callback) &&
	                ((typeof useCapture !== 'boolean') || useCapture === eventRecord.useCapture)) {
	                var events = eventRecord.target.__events__;
	                var targetArrayLookup = events[eventRecord.eventName];
	                var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
	                // We may have already target's entries, so check for null.
	                if (targetArray) {
	                    if (targetArray.length === 1 || !callback) {
	                        targetArrayLookup.count -= targetArray.length;
	                        delete events[eventRecord.eventName][this._id];
	                    }
	                    else {
	                        targetArrayLookup.count--;
	                        targetArray.splice(targetArray.indexOf(eventRecord), 1);
	                    }
	                    if (!targetArrayLookup.count) {
	                        delete events[eventRecord.eventName];
	                    }
	                }
	                if (eventRecord.elementCallback) {
	                    if (eventRecord.target.removeEventListener) {
	                        eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.useCapture);
	                    }
	                    else if (eventRecord.target.detachEvent) {
	                        eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);
	                    }
	                }
	                this._eventRecords.splice(i--, 1);
	            }
	        }
	    };
	    /** Trigger the given event in the context of this instance of EventGroup. */
	    EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {
	        return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
	    };
	    /** Declare an event as being supported by this instance of EventGroup. */
	    EventGroup.prototype.declare = function (event) {
	        var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
	        if (typeof event === 'string') {
	            declaredEvents[event] = true;
	        }
	        else {
	            for (var i = 0; i < event.length; i++) {
	                declaredEvents[event[i]] = true;
	            }
	        }
	    };
	    return EventGroup;
	}());
	EventGroup._uniqueId = 0;
	exports.EventGroup = EventGroup;
	


/***/ },
/* 415 */
/***/ function(module, exports) {

	"use strict";
	var _scrollbarWidth;
	exports.DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';
	/** Calculates the width of a scrollbar for the browser/os. */
	function getScrollbarWidth() {
	    if (_scrollbarWidth === undefined) {
	        var scrollDiv = document.createElement('div');
	        scrollDiv.style.setProperty('width', '100px');
	        scrollDiv.style.setProperty('height', '100px');
	        scrollDiv.style.setProperty('overflow', 'scroll');
	        scrollDiv.style.setProperty('position', 'absolute');
	        scrollDiv.style.setProperty('top', '-9999px');
	        document.body.appendChild(scrollDiv);
	        // Get the scrollbar width
	        _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
	        // Delete the DIV
	        document.body.removeChild(scrollDiv);
	    }
	    return _scrollbarWidth;
	}
	exports.getScrollbarWidth = getScrollbarWidth;
	/**
	 * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns
	 * document.body.
	 */
	function findScrollableParent(startingElement) {
	    var el = startingElement;
	    // First do a quick scan for the scrollable attribute.
	    while (el && el !== document.body) {
	        if (el.getAttribute(exports.DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {
	            return el;
	        }
	        el = el.parentElement;
	    }
	    // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.
	    el = startingElement;
	    while (el && el !== document.body) {
	        if (el.getAttribute(exports.DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {
	            var styles = getComputedStyle(el);
	            var overflowY = styles ? styles.getPropertyValue('overflow-y') : '';
	            if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {
	                return el;
	            }
	        }
	        el = el.parentElement;
	    }
	    // Fall back to window scroll.
	    if (!el || el === document.body) {
	        el = window;
	    }
	    return el;
	}
	exports.findScrollableParent = findScrollableParent;
	


/***/ },
/* 416 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Sets the virtual parent of an element.
	 * Pass `undefined` as the `parent` to clear the virtual parent.
	 *
	 * @export
	 * @param {HTMLElement} child
	 * @param {HTMLElement} parent
	 */
	function setVirtualParent(child, parent) {
	    var virtualChild = child;
	    var virtualParent = parent;
	    if (!virtualChild._virtual) {
	        virtualChild._virtual = {
	            children: []
	        };
	    }
	    var oldParent = virtualChild._virtual.parent;
	    if (oldParent && oldParent !== parent) {
	        // Remove the child from its old parent.
	        var index = oldParent._virtual.children.indexOf(virtualChild);
	        if (index > -1) {
	            oldParent._virtual.children.splice(index, 1);
	        }
	    }
	    virtualChild._virtual.parent = virtualParent || undefined;
	    if (virtualParent) {
	        if (!virtualParent._virtual) {
	            virtualParent._virtual = {
	                children: []
	            };
	        }
	        virtualParent._virtual.children.push(virtualChild);
	    }
	}
	exports.setVirtualParent = setVirtualParent;
	function getVirtualParent(child) {
	    var parent;
	    if (child && isVirtualElement(child)) {
	        parent = child._virtual.parent;
	    }
	    return parent;
	}
	exports.getVirtualParent = getVirtualParent;
	/**
	 * Gets the element which is the parent of a given element.
	 * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over
	 * real DOM parent when present.
	 *
	 * @export
	 * @param {HTMLElement} child
	 * @param {boolean} [allowVirtualParents=true]
	 * @returns {HTMLElement}
	 */
	function getParent(child, allowVirtualParents) {
	    if (allowVirtualParents === void 0) { allowVirtualParents = true; }
	    return child && (allowVirtualParents && getVirtualParent(child) ||
	        child.parentNode && child.parentNode);
	}
	exports.getParent = getParent;
	/**
	 * Determines whether or not a parent element contains a given child element.
	 * If `allowVirtualParents` is true, this method may return `true` if the child
	 * has the parent in its virtual element hierarchy.
	 *
	 * @export
	 * @param {HTMLElement} parent
	 * @param {HTMLElement} child
	 * @param {boolean} [allowVirtualParents=true]
	 * @returns {boolean}
	 */
	function elementContains(parent, child, allowVirtualParents) {
	    if (allowVirtualParents === void 0) { allowVirtualParents = true; }
	    var isContained = false;
	    if (parent && child) {
	        if (allowVirtualParents) {
	            isContained = false;
	            while (child) {
	                var nextParent = getParent(child);
	                if (nextParent === parent) {
	                    isContained = true;
	                    break;
	                }
	                child = nextParent;
	            }
	        }
	        else if (parent.contains) {
	            isContained = parent.contains(child);
	        }
	    }
	    return isContained;
	}
	exports.elementContains = elementContains;
	var _isSSR = false;
	/** Helper to set ssr mode to simulate no window object returned from getWindow helper. */
	function setSSR(isEnabled) {
	    _isSSR = isEnabled;
	}
	exports.setSSR = setSSR;
	/** Helper to get the window object. */
	function getWindow(rootElement) {
	    if (_isSSR) {
	        return undefined;
	    }
	    else {
	        return (rootElement &&
	            rootElement.ownerDocument &&
	            rootElement.ownerDocument.defaultView ?
	            rootElement.ownerDocument.defaultView :
	            window);
	    }
	}
	exports.getWindow = getWindow;
	/** Helper to get the document object. */
	function getDocument(rootElement) {
	    if (_isSSR) {
	        return undefined;
	    }
	    else {
	        return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;
	    }
	}
	exports.getDocument = getDocument;
	/** Helper to get bounding client rect, works with window. */
	function getRect(element) {
	    var rect;
	    if (element) {
	        if (element === window) {
	            rect = {
	                left: 0,
	                top: 0,
	                width: window.innerWidth,
	                height: window.innerHeight,
	                right: window.innerWidth,
	                bottom: window.innerHeight
	            };
	        }
	        else if (element.getBoundingClientRect) {
	            rect = element.getBoundingClientRect();
	        }
	    }
	    return rect;
	}
	exports.getRect = getRect;
	/**
	 * Determines whether or not an element has the virtual hierarchy extension.
	 *
	 * @param {(HTMLElement | IVirtualElement)} element
	 * @returns {element is IVirtualElement}
	 */
	function isVirtualElement(element) {
	    return element && !!element._virtual;
	}
	


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Async_1 = __webpack_require__(412);
	var EventGroup_1 = __webpack_require__(414);
	var BaseComponent = (function (_super) {
	    __extends(BaseComponent, _super);
	    /**
	     * BaseComponent constructor
	     * @param {P} props The props for the component.
	     * @param {Object} deprecatedProps The map of deprecated prop names to new names, where the key is the old name and the
	     * value is the new name. If a prop is removed rather than renamed, leave the value undefined.
	     */
	    function BaseComponent(props, deprecatedProps) {
	        var _this = _super.call(this, props) || this;
	        if (deprecatedProps) {
	            for (var propName in deprecatedProps) {
	                if (propName in props) {
	                    _warnDeprecation(_this, propName, deprecatedProps[propName]);
	                }
	            }
	        }
	        _makeAllSafe(_this, BaseComponent.prototype, [
	            'componentWillMount',
	            'componentDidMount',
	            'shouldComponentUpdate',
	            'componentWillUpdate',
	            'componentWillReceiveProps',
	            'render',
	            'componentDidUpdate',
	            'componentWillUnmount'
	        ]);
	        return _this;
	    }
	    /** If we have disposables, dispose them automatically on unmount. */
	    BaseComponent.prototype.componentWillUnmount = function () {
	        if (this.__disposables) {
	            for (var i = 0, len = this._disposables.length; i < len; i++) {
	                var disposable = this.__disposables[i];
	                if (disposable.dispose) {
	                    disposable.dispose();
	                }
	            }
	            this.__disposables = null;
	        }
	    };
	    Object.defineProperty(BaseComponent.prototype, "className", {
	        /** Gets the object's class name. */
	        get: function () {
	            var funcNameRegex = /function (.{1,})\(/;
	            var results = (funcNameRegex).exec((this).constructor.toString());
	            return (results && results.length > 1) ? results[1] : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseComponent.prototype, "_disposables", {
	        /** Allows subclasses to push things to this._disposables to be auto disposed. */
	        get: function () {
	            if (!this.__disposables) {
	                this.__disposables = [];
	            }
	            return this.__disposables;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseComponent.prototype, "_async", {
	        /**
	         * Gets the async instance associated with the component, created on demand. The async instance gives
	         * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
	         * will be cleared/ignored automatically after unmounting. The helpers within the async object also
	         * preserve the this pointer so that you don't need to "bind" the callbacks.
	         */
	        get: function () {
	            if (!this.__async) {
	                this.__async = new Async_1.Async(this);
	                this._disposables.push(this.__async);
	            }
	            return this.__async;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseComponent.prototype, "_events", {
	        /**
	         * Gets the event group instance assocaited with the component, created on demand. The event instance
	         * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
	         * will be automatically disconnected after unmounting. The helpers within the events object also
	         * preserve the this reference so that you don't need to "bind" the callbacks.
	         */
	        get: function () {
	            if (!this.__events) {
	                this.__events = new EventGroup_1.EventGroup(this);
	                this._disposables.push(this.__events);
	            }
	            return this.__events;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Helper to return a memoized ref resolver function.
	     * @params refName Name of the member to assign the ref to.
	     *
	     * @examples
	     * class Foo extends BaseComponent<...> {
	     *   private _root: HTMLElement;
	     *
	     *   public render() {
	     *     return <div ref={ this._resolveRef('_root') } />
	     *   }
	     * }
	     */
	    BaseComponent.prototype._resolveRef = function (refName) {
	        var _this = this;
	        if (!this.__resolves) {
	            this.__resolves = {};
	        }
	        if (!this.__resolves[refName]) {
	            this.__resolves[refName] = function (ref) {
	                return _this[refName] = ref;
	            };
	        }
	        return this.__resolves[refName];
	    };
	    return BaseComponent;
	}(React.Component));
	exports.BaseComponent = BaseComponent;
	/**
	 * Helper to override a given method with a wrapper method that can try/catch the original, but also
	 * ensures that the BaseComponent's methods are called before the subclass's. This ensures that
	 * componentWillUnmount in the base is called and that things in the _disposables array are disposed.
	 */
	function _makeAllSafe(obj, prototype, methodNames) {
	    for (var i = 0, len = methodNames.length; i < len; i++) {
	        _makeSafe(obj, prototype, methodNames[i]);
	    }
	}
	function _makeSafe(obj, prototype, methodName) {
	    var classMethod = obj[methodName];
	    var prototypeMethod = prototype[methodName];
	    if (classMethod || prototypeMethod) {
	        obj[methodName] = function () {
	            var retVal;
	            try {
	                if (prototypeMethod) {
	                    retVal = prototypeMethod.apply(this, arguments);
	                }
	                if (classMethod) {
	                    retVal = classMethod.apply(this, arguments);
	                }
	            }
	            catch (e) {
	                var errorMessage = "Exception in " + obj.className + "." + methodName + "(): " + (typeof e === 'string' ? e : e.stack);
	                if (BaseComponent.onError) {
	                    BaseComponent.onError(errorMessage, e);
	                }
	            }
	            return retVal;
	        };
	    }
	}
	function _warnDeprecation(obj, propertyName, newPropertyName) {
	    if (console && console.warn) {
	        var deprecationMessage = obj.className + " property '" + propertyName + "' was used but has been deprecated.";
	        if (newPropertyName) {
	            deprecationMessage += " Use '" + newPropertyName + "' instead.";
	        }
	        console.warn(deprecationMessage);
	    }
	}
	BaseComponent.onError = function (errorMessage) {
	    console.error(errorMessage);
	    throw errorMessage;
	};
	


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	/**
	 * Utility component for delaying the render of a child component after a given delay. This component
	 * requires a single child component; don't pass in many components. Wrap multiple components in a DIV
	 * if necessary.
	 *
	 * @example
	 * <DelayedRender delay={ 3000 }>
	 *  <div className='foo-List-loadingSpinner'>
	 *    <p>I am loading</p>
	 *    <Spinner />
	 *  </div>
	 * </DelayedRender>
	 */
	var DelayedRender = (function (_super) {
	    __extends(DelayedRender, _super);
	    function DelayedRender(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            isRendered: false
	        };
	        return _this;
	    }
	    DelayedRender.prototype.componentDidMount = function () {
	        var _this = this;
	        var delay = this.props.delay;
	        this._timeoutId = setTimeout(function () {
	            _this.setState({
	                isRendered: true
	            });
	        }, delay);
	    };
	    DelayedRender.prototype.componentWillUnmount = function () {
	        clearTimeout(this._timeoutId);
	    };
	    DelayedRender.prototype.render = function () {
	        return this.state.isRendered ? React.Children.only(this.props.children) : null;
	    };
	    return DelayedRender;
	}(React.Component));
	DelayedRender.defaultProps = {
	    delay: 0
	};
	exports.DelayedRender = DelayedRender;
	


/***/ },
/* 419 */
/***/ function(module, exports) {

	"use strict";
	var KeyCodes;
	(function (KeyCodes) {
	    KeyCodes[KeyCodes["a"] = 65] = "a";
	    KeyCodes[KeyCodes["backspace"] = 8] = "backspace";
	    KeyCodes[KeyCodes["comma"] = 188] = "comma";
	    KeyCodes[KeyCodes["del"] = 46] = "del";
	    KeyCodes[KeyCodes["down"] = 40] = "down";
	    KeyCodes[KeyCodes["end"] = 35] = "end";
	    KeyCodes[KeyCodes["enter"] = 13] = "enter";
	    KeyCodes[KeyCodes["escape"] = 27] = "escape";
	    KeyCodes[KeyCodes["home"] = 36] = "home";
	    KeyCodes[KeyCodes["left"] = 37] = "left";
	    KeyCodes[KeyCodes["pageDown"] = 34] = "pageDown";
	    KeyCodes[KeyCodes["pageUp"] = 33] = "pageUp";
	    KeyCodes[KeyCodes["right"] = 39] = "right";
	    KeyCodes[KeyCodes["semicolon"] = 186] = "semicolon";
	    KeyCodes[KeyCodes["space"] = 32] = "space";
	    KeyCodes[KeyCodes["tab"] = 9] = "tab";
	    KeyCodes[KeyCodes["up"] = 38] = "up";
	})(KeyCodes = exports.KeyCodes || (exports.KeyCodes = {}));
	


/***/ },
/* 420 */
/***/ function(module, exports) {

	"use strict";
	var Rectangle = (function () {
	    function Rectangle(left, right, top, bottom) {
	        if (left === void 0) { left = 0; }
	        if (right === void 0) { right = 0; }
	        if (top === void 0) { top = 0; }
	        if (bottom === void 0) { bottom = 0; }
	        this.top = top;
	        this.bottom = bottom;
	        this.left = left;
	        this.right = right;
	    }
	    Object.defineProperty(Rectangle.prototype, "width", {
	        /**
	         * Calculated automatically by subtracting the right from left
	         */
	        get: function () {
	            return this.right - this.left;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "height", {
	        /**
	         * Calculated automatically by subtracting the bottom from top.
	         */
	        get: function () {
	            return this.bottom - this.top;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Tests if another rect is approximately equal to this rect (within 4 decimal places.)
	     */
	    Rectangle.prototype.equals = function (rect) {
	        // I'm fixing it to 4 decimal places because it allows enough precision and will handle cases when something should be rounded,
	        // like .999999 should round to 1.
	        return (parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&
	            parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&
	            parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&
	            parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4)));
	    };
	    return Rectangle;
	}());
	exports.Rectangle = Rectangle;
	


/***/ },
/* 421 */
/***/ function(module, exports) {

	"use strict";
	function findIndex(array, cb) {
	    var index = -1;
	    for (var i = 0; array && i < array.length; i++) {
	        if (cb(array[i], i)) {
	            index = i;
	            break;
	        }
	    }
	    return index;
	}
	exports.findIndex = findIndex;
	function createArray(size, getItem) {
	    var array = [];
	    for (var i = 0; i < size; i++) {
	        array.push(getItem(i));
	    }
	    return array;
	}
	exports.createArray = createArray;
	


/***/ },
/* 422 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Autobind is a utility for binding methods in a class. This simplifies tagging methods as being "bound" to the this pointer
	 * so that they can be used in scenarios that simply require a function callback.
	 *
	 * @example
	 * import { autobind } from '../utilities/autobind';
	 *
	 * public class Foo {
	 *   @autobind
	 *   method() {
	 *   }
	 * }
	 */
	function autobind(target, key, descriptor) {
	    var fn = descriptor.value;
	    var defining = false;
	    return {
	        configurable: true,
	        get: function () {
	            if (defining || this === fn.prototype || this.hasOwnProperty(key)) {
	                return fn;
	            }
	            // Bind method only once, and update the property to return the bound value from now on
	            var fnBound = fn.bind(this);
	            defining = true;
	            Object.defineProperty(this, key, {
	                configurable: true,
	                writable: true,
	                enumerable: true,
	                value: fnBound
	            });
	            defining = false;
	            return fnBound;
	        },
	        set: function (newValue) {
	            Object.defineProperty(this, key, {
	                configurable: true,
	                writable: true,
	                enumerable: true,
	                value: newValue
	            });
	        }
	    };
	}
	exports.autobind = autobind;
	


/***/ },
/* 423 */
/***/ function(module, exports) {

	"use strict";
	function css() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var classes = [];
	    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
	        var arg = args_1[_a];
	        if (arg) {
	            if (typeof arg === 'string') {
	                classes.push(arg);
	            }
	            else {
	                for (var key in arg) {
	                    if (arg[key]) {
	                        classes.push(key);
	                    }
	                }
	            }
	        }
	    }
	    return classes.join(' ');
	}
	exports.css = css;
	


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	/* tslint:disable:no-string-literal */
	"use strict";
	var dom_1 = __webpack_require__(416);
	var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
	var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
	var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
	function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
	    return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
	}
	exports.getFirstFocusable = getFirstFocusable;
	function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
	    return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
	}
	exports.getLastFocusable = getLastFocusable;
	/**
	 * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
	 * @return True if focus was set, false if it was not.
	 * @param {HTMLElement} rootElement - element to start the search for a focusable child.
	 */
	function focusFirstChild(rootElement) {
	    var element = getNextElement(rootElement, rootElement, true, false, false, true);
	    if (element) {
	        element.focus();
	        return true;
	    }
	    return false;
	}
	exports.focusFirstChild = focusFirstChild;
	/** Traverse to find the previous element. */
	function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones) {
	    if (!currentElement ||
	        currentElement === rootElement) {
	        return null;
	    }
	    var isCurrentElementVisible = isElementVisible(currentElement);
	    // Check its children.
	    if (traverseChildren && (includeElementsInFocusZones || !isElementFocusZone(currentElement)) && isCurrentElementVisible) {
	        var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones);
	        if (childMatch) {
	            return childMatch;
	        }
	    }
	    // Check the current node, if it's not the first traversal.
	    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
	        return currentElement;
	    }
	    // Check its previous sibling.
	    var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones);
	    if (siblingMatch) {
	        return siblingMatch;
	    }
	    // Check its parent.
	    if (!suppressParentTraversal) {
	        return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones);
	    }
	    return null;
	}
	exports.getPreviousElement = getPreviousElement;
	/** Traverse to find the next focusable element. */
	function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones) {
	    if (!currentElement ||
	        (currentElement === rootElement && suppressChildTraversal)) {
	        return null;
	    }
	    var isCurrentElementVisible = isElementVisible(currentElement);
	    // Check the current node, if it's not the first traversal.
	    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
	        return currentElement;
	    }
	    // Check its children.
	    if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !isElementFocusZone(currentElement))) {
	        var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones);
	        if (childMatch) {
	            return childMatch;
	        }
	    }
	    if (currentElement === rootElement) {
	        return null;
	    }
	    // Check its sibling.
	    var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones);
	    if (siblingMatch) {
	        return siblingMatch;
	    }
	    if (!suppressParentTraversal) {
	        return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones);
	    }
	    return null;
	}
	exports.getNextElement = getNextElement;
	function isElementVisible(element) {
	    // If the element is not valid, return false.
	    if (!element || !element.getAttribute) {
	        return false;
	    }
	    var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
	    // If the element is explicitly marked with the visibility attribute, return that value as boolean.
	    if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
	        return visibilityAttribute === 'true';
	    }
	    // Fallback to other methods of determining actual visibility.
	    return (element.offsetHeight !== 0 ||
	        element.offsetParent !== null ||
	        element.isVisible === true); // used as a workaround for testing.
	}
	exports.isElementVisible = isElementVisible;
	function isElementTabbable(element) {
	    // If this element is null or is disabled, it is not considered tabbable.
	    if (!element || element.disabled) {
	        return false;
	    }
	    // In IE, element.tabIndex is default to 0. We need to use element get tabIndex attribute to get the correct tabIndex
	    var tabIndex = -1;
	    if (element && element.getAttribute) {
	        tabIndex = parseInt(element.getAttribute('tabIndex'), 10);
	    }
	    var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
	    return (!!element && isFocusableAttribute !== 'false' &&
	        (element.tagName === 'A' ||
	            (element.tagName === 'BUTTON') ||
	            (element.tagName === 'INPUT') ||
	            (element.tagName === 'TEXTAREA') ||
	            (tabIndex >= 0) ||
	            (element.getAttribute && (isFocusableAttribute === 'true') ||
	                element.getAttribute('role') === 'button')));
	}
	exports.isElementTabbable = isElementTabbable;
	function isElementFocusZone(element) {
	    return element && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE);
	}
	exports.isElementFocusZone = isElementFocusZone;
	function doesElementContainFocus(element) {
	    var currentActiveElement = dom_1.getDocument(element).activeElement;
	    if (currentActiveElement && dom_1.elementContains(element, currentActiveElement)) {
	        return true;
	    }
	    return false;
	}
	exports.doesElementContainFocus = doesElementContainFocus;
	


/***/ },
/* 425 */
/***/ function(module, exports) {

	"use strict";
	var REACT_LIFECYCLE_EXCLUSIONS = [
	    'setState',
	    'render',
	    'componentWillMount',
	    'componentDidMount',
	    'componentWillReceiveProps',
	    'shouldComponentUpdate',
	    'componentWillUpdate',
	    'componentDidUpdate',
	    'componentWillUnmount'
	];
	/**
	 * Allows you to hoist methods, except those in an exclusion set from a source object into a destination object.
	 * @param destination The instance of the object to hoist the methods onto.
	 * @param source The instance of the object where the methods are hoisted from.
	 * @param exclusions (Optional) What methods to exclude from being hoisted.
	 * @returns {string[]} An array of names of methods that were hoisted.
	 */
	function hoistMethods(destination, source, exclusions) {
	    if (exclusions === void 0) { exclusions = REACT_LIFECYCLE_EXCLUSIONS; }
	    var hoisted = [];
	    var _loop_1 = function (methodName) {
	        if (typeof source[methodName] === 'function' &&
	            destination[methodName] === undefined &&
	            (!exclusions || exclusions.indexOf(methodName) === -1)) {
	            hoisted.push(methodName);
	            /* tslint:disable:no-function-expression */
	            destination[methodName] = function () { source[methodName].apply(source, arguments); };
	        }
	    };
	    for (var methodName in source) {
	        _loop_1(methodName);
	    }
	    return hoisted;
	}
	exports.hoistMethods = hoistMethods;
	/**
	 * Provides a method for convenience to unhoist hoisted methods.
	 * @param {any} source The source object upon which methods were hoisted.
	 * @param {string[]} methodNames An array of method names to unhoist.
	 */
	function unhoistMethods(source, methodNames) {
	    methodNames
	        .forEach(function (methodName) { return delete source[methodName]; });
	}
	exports.unhoistMethods = unhoistMethods;
	


/***/ },
/* 426 */
/***/ function(module, exports) {

	"use strict";
	function getDistanceBetweenPoints(point1, point2) {
	    var distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
	    return distance;
	}
	exports.getDistanceBetweenPoints = getDistanceBetweenPoints;
	


/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	// Initialize global window id.
	var CURRENT_ID_PROPERTY = '__currentId__';
	var _global = (typeof window !== 'undefined' && window) || process;
	if (_global[CURRENT_ID_PROPERTY] === undefined) {
	    _global[CURRENT_ID_PROPERTY] = 0;
	}
	function checkProperties(a, b) {
	    for (var propName in a) {
	        if (a.hasOwnProperty(propName)) {
	            if (!b.hasOwnProperty(propName) || (b[propName] !== a[propName])) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	// Compare a to b and b to a
	function shallowCompare(a, b) {
	    return checkProperties(a, b) && checkProperties(b, a);
	}
	exports.shallowCompare = shallowCompare;
	/**
	 * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more
	 * objects as arguments and they will be merged sequentially into the target. Note that this will
	 * shallow merge; it will not create new cloned values for target members.
	 *
	 * @params target {Object} Target object to merge following object arguments into.
	 * @params args {Object} One or more objects that will be mixed into the target in the order they are provided.
	 * @returns Resulting merged target.
	 */
	function assign(target) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    return filteredAssign.apply(this, [null, target].concat(args));
	}
	exports.assign = assign;
	/**
	 * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter
	 * the resulting merges. This allows for scenarios where you want to merge "everything except that one thing"
	 * or "properties that start with data-". Note that this will shallow merge; it will not create new cloned
	 * values for target members.
	 *
	 * @params filteredAssign {Function} A callback function that tests if the property should be assigned.
	 * @params target {Object} Target object to merge following object arguments into.
	 * @params args {Object} One or more objects that will be mixed into the target in the order they are provided.
	 * @returns Resulting merged target.
	 */
	function filteredAssign(isAllowed, target) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	    }
	    target = target || {};
	    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
	        var sourceObject = args_1[_a];
	        if (sourceObject) {
	            for (var propName in sourceObject) {
	                if (sourceObject.hasOwnProperty(propName) &&
	                    !isAllowed || isAllowed(propName)) {
	                    target[propName] = sourceObject[propName];
	                }
	            }
	        }
	    }
	    return target;
	}
	exports.filteredAssign = filteredAssign;
	/** Generates a unique id in the global scope (this spans across duplicate copies of the same library.) */
	function getId(prefix) {
	    var index = _global[CURRENT_ID_PROPERTY]++;
	    return (prefix || '') + index;
	}
	exports.getId = getId;
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var object_1 = __webpack_require__(427);
	exports.baseElementEvents = [
	    'onCopy',
	    'onCut',
	    'onPaste',
	    'onCompositionEnd',
	    'onCompositionStart',
	    'onCompositionUpdate',
	    'onFocus',
	    'onFocusCapture',
	    'onBlur',
	    'onBlurCapture',
	    'onChange',
	    'onInput',
	    'onSubmit',
	    'onLoad',
	    'onError',
	    'onKeyDown',
	    'onKeyDownCapture',
	    'onKeyPress',
	    'onKeyUp',
	    'onAbort',
	    'onCanPlay',
	    'onCanPlayThrough',
	    'onDurationChange',
	    'onEmptied',
	    'onEncrypted',
	    'onEnded',
	    'onLoadedData',
	    'onLoadedMetadata',
	    'onLoadStart',
	    'onPause',
	    'onPlay',
	    'onPlaying',
	    'onProgress',
	    'onRateChange',
	    'onSeeked',
	    'onSeeking',
	    'onStalled',
	    'onSuspend',
	    'onTimeUpdate',
	    'onVolumeChange',
	    'onWaiting',
	    'onClick',
	    'onClickCapture',
	    'onContextMenu',
	    'onDoubleClick',
	    'onDrag',
	    'onDragEnd',
	    'onDragEnter',
	    'onDragExit',
	    'onDragLeave',
	    'onDragOver',
	    'onDragStart',
	    'onDrop',
	    'onMouseDown',
	    'onMouseDownCapture',
	    'onMouseEnter',
	    'onMouseLeave',
	    'onMouseMove',
	    'onMouseOut',
	    'onMouseOver',
	    'onMouseUp',
	    'onMouseUpCapture',
	    'onSelect',
	    'onTouchCancel',
	    'onTouchEnd',
	    'onTouchMove',
	    'onTouchStart',
	    'onScroll',
	    'onWheel'
	];
	exports.baseElementProperties = [
	    'defaultChecked',
	    'defaultValue',
	    'accept',
	    'acceptCharset',
	    'accessKey',
	    'action',
	    'allowFullScreen',
	    'allowTransparency',
	    'alt',
	    'async',
	    'autoComplete',
	    'autoFocus',
	    'autoPlay',
	    'capture',
	    'cellPadding',
	    'cellSpacing',
	    'charSet',
	    'challenge',
	    'checked',
	    'children',
	    'classID',
	    'className',
	    'cols',
	    'colSpan',
	    'content',
	    'contentEditable',
	    'contextMenu',
	    'controls',
	    'coords',
	    'crossOrigin',
	    'data',
	    'dateTime',
	    'default',
	    'defer',
	    'dir',
	    'download',
	    'draggable',
	    'encType',
	    'form',
	    'formAction',
	    'formEncType',
	    'formMethod',
	    'formNoValidate',
	    'formTarget',
	    'frameBorder',
	    'headers',
	    'height',
	    'hidden',
	    'high',
	    'hrefLang',
	    'htmlFor',
	    'httpEquiv',
	    'icon',
	    'id',
	    'inputMode',
	    'integrity',
	    'is',
	    'keyParams',
	    'keyType',
	    'kind',
	    'label',
	    'lang',
	    'list',
	    'loop',
	    'low',
	    'manifest',
	    'marginHeight',
	    'marginWidth',
	    'max',
	    'maxLength',
	    'media',
	    'mediaGroup',
	    'method',
	    'min',
	    'minLength',
	    'multiple',
	    'muted',
	    'name',
	    'noValidate',
	    'open',
	    'optimum',
	    'pattern',
	    'placeholder',
	    'poster',
	    'preload',
	    'radioGroup',
	    'readOnly',
	    'rel',
	    'required',
	    'role',
	    'rows',
	    'rowSpan',
	    'sandbox',
	    'scope',
	    'scoped',
	    'scrolling',
	    'seamless',
	    'selected',
	    'shape',
	    'size',
	    'sizes',
	    'span',
	    'spellCheck',
	    'src',
	    'srcDoc',
	    'srcLang',
	    'srcSet',
	    'start',
	    'step',
	    'style',
	    'summary',
	    'tabIndex',
	    'title',
	    'type',
	    'useMap',
	    'value',
	    'width',
	    'wmode',
	    'wrap'
	];
	exports.htmlElementProperties = exports.baseElementProperties.concat(exports.baseElementEvents);
	exports.anchorProperties = exports.htmlElementProperties.concat([
	    'href',
	    'target'
	]);
	exports.buttonProperties = exports.htmlElementProperties.concat([
	    'disabled'
	]);
	exports.divProperties = exports.htmlElementProperties.concat(['align', 'noWrap']);
	exports.inputProperties = exports.buttonProperties;
	exports.textAreaProperties = exports.buttonProperties;
	exports.imageProperties = exports.divProperties;
	/**
	 * Gets native supported props for an html element provided the allowance set. Use one of the property
	 * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
	 * props set. Note that all data- and aria- prefixed attributes will be allowed.
	 * NOTE: getNativeProps should always be applied first when adding props to a react component. The
	 * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
	 * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
	 * the component after an onClick function is added, then the getNativeProps onClick will override it.
	 * @param props The unfiltered input props
	 * @param allowedPropsNames The array of allowed propnames.
	 * @returns The filtered props
	 */
	function getNativeProps(props, allowedPropNames, excludedPropNames) {
	    return object_1.filteredAssign(function (propName) {
	        return ((!excludedPropNames || excludedPropNames.indexOf(propName) < 0) && ((propName.indexOf('data-') === 0) ||
	            (propName.indexOf('aria-') === 0) ||
	            (allowedPropNames.indexOf(propName) >= 0)));
	    }, {}, props);
	}
	exports.getNativeProps = getNativeProps;
	


/***/ },
/* 429 */
/***/ function(module, exports) {

	"use strict";
	var _baseUrl = '';
	/** Sets the current base url used for fetching images. */
	function getResourceUrl(url) {
	    return _baseUrl + url;
	}
	exports.getResourceUrl = getResourceUrl;
	/** Gets the current base url used for fetching images. */
	function setBaseUrl(baseUrl) {
	    _baseUrl = baseUrl;
	}
	exports.setBaseUrl = setBaseUrl;
	/** Gets the current runtime language. */
	function getLanguage() {
	    return 'en-us';
	}
	exports.getLanguage = getLanguage;
	


/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var KeyCodes_1 = __webpack_require__(419);
	var dom_1 = __webpack_require__(416);
	// Default to undefined so that we initialize on first read.
	var _isRTL;
	/**
	 * Gets the rtl state of the page (returns true if in rtl.)
	 */
	function getRTL() {
	    if (_isRTL === undefined) {
	        var doc = dom_1.getDocument();
	        if (doc) {
	            _isRTL = document.documentElement.getAttribute('dir') === 'rtl';
	        }
	        else {
	            throw new Error('getRTL was called in a server environment without setRTL being called first. ' +
	                'Call setRTL to set the correct direction first.');
	        }
	    }
	    return _isRTL;
	}
	exports.getRTL = getRTL;
	/**
	 * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
	 */
	function setRTL(isRTL) {
	    var doc = dom_1.getDocument();
	    if (doc) {
	        doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
	    }
	    _isRTL = isRTL;
	}
	exports.setRTL = setRTL;
	/**
	 * Returns the given key, but flips right/left arrows if necessary.
	 */
	function getRTLSafeKeyCode(key) {
	    if (getRTL()) {
	        if (key === KeyCodes_1.KeyCodes.left) {
	            key = KeyCodes_1.KeyCodes.right;
	        }
	        else if (key === KeyCodes_1.KeyCodes.right) {
	            key = KeyCodes_1.KeyCodes.left;
	        }
	    }
	    return key;
	}
	exports.getRTLSafeKeyCode = getRTLSafeKeyCode;
	


/***/ },
/* 431 */
/***/ function(module, exports) {

	"use strict";
	// Regex that finds { and } so they can be removed on a lookup for string format
	var FORMAT_ARGS_REGEX = /[\{\}]/g;
	// Regex that finds {#} so it can be replaced by the arguments in string format
	var FORMAT_REGEX = /\{\d+\}/g;
	/**
	 * String Format is like C# string format.
	 * Usage Example: "hello {0}!".format("mike") will return "hello mike!"
	 * Calling format on a string with less arguments than specified in the format is invalid
	 * Example "I love {0} every {1}".format("CXP") will result in a Debug Exception.
	 */
	function format(s) {
	    'use strict';
	    var values = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        values[_i - 1] = arguments[_i];
	    }
	    var args = values;
	    // Callback match function
	    function replace_func(match) {
	        // looks up in the args
	        var replacement = args[match.replace(FORMAT_ARGS_REGEX, '')];
	        // catches undefined in nondebug and null in debug and nondebug
	        if (replacement === null || replacement === undefined) {
	            replacement = '';
	        }
	        return replacement;
	    }
	    return (s.replace(FORMAT_REGEX, replace_func));
	}
	exports.format = format;
	


/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(433));
	


/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(434));
	__export(__webpack_require__(435));
	


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var FocusZone_Props_1 = __webpack_require__(435);
	var Utilities_1 = __webpack_require__(410);
	var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
	var IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';
	var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
	var TABINDEX = 'tabindex';
	var _allInstances = {};
	var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
	var FocusZone = (function (_super) {
	    __extends(FocusZone, _super);
	    function FocusZone(props) {
	        var _this = _super.call(this, props) || this;
	        _this._id = Utilities_1.getId('FocusZone');
	        _allInstances[_this._id] = _this;
	        _this._focusAlignment = {
	            left: 0,
	            top: 0
	        };
	        return _this;
	    }
	    FocusZone.prototype.componentDidMount = function () {
	        var windowElement = this.refs.root.ownerDocument.defaultView;
	        var parentElement = Utilities_1.getParent(this.refs.root);
	        while (parentElement &&
	            parentElement !== document.body &&
	            parentElement.nodeType === 1) {
	            if (Utilities_1.isElementFocusZone(parentElement)) {
	                this._isInnerZone = true;
	                break;
	            }
	            parentElement = Utilities_1.getParent(parentElement);
	        }
	        this._events.on(windowElement, 'keydown', this._onKeyDownCapture, true);
	        // Assign initial tab indexes so that we can set initial focus as appropriate.
	        this._updateTabIndexes();
	        if (this.props.defaultActiveElement) {
	            this._activeElement = Utilities_1.getDocument().querySelector(this.props.defaultActiveElement);
	        }
	    };
	    FocusZone.prototype.componentWillUnmount = function () {
	        delete _allInstances[this._id];
	    };
	    FocusZone.prototype.render = function () {
	        var _a = this.props, rootProps = _a.rootProps, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;
	        return (React.createElement("div", __assign({}, rootProps, { className: Utilities_1.css('ms-FocusZone', className), ref: 'root', "data-focuszone-id": this._id, "aria-labelledby": ariaLabelledBy, onKeyDown: this._onKeyDown, onFocus: this._onFocus }, { onMouseDownCapture: this._onMouseDown }), this.props.children));
	    };
	    /**
	     * Sets focus to the first tabbable item in the zone.
	     * @returns True if focus could be set to an active element, false if no operation was taken.
	     */
	    FocusZone.prototype.focus = function () {
	        if (this._activeElement && Utilities_1.elementContains(this.refs.root, this._activeElement)) {
	            this._activeElement.focus();
	            return true;
	        }
	        else {
	            var firstChild = this.refs.root.firstChild;
	            return this.focusElement(Utilities_1.getNextElement(this.refs.root, firstChild, true));
	        }
	    };
	    /**
	     * Sets focus to a specific child element within the zone. This can be used in conjunction with
	     * onBeforeFocus to created delayed focus scenarios (like animate the scroll position to the correct
	     * location and then focus.)
	     * @param {HTMLElement} element The child element within the zone to focus.
	     * @returns True if focus could be set to an active element, false if no operation was taken.
	     */
	    FocusZone.prototype.focusElement = function (element) {
	        var onBeforeFocus = this.props.onBeforeFocus;
	        if (onBeforeFocus && !onBeforeFocus(element)) {
	            return false;
	        }
	        if (element) {
	            if (this._activeElement) {
	                this._activeElement.tabIndex = -1;
	            }
	            this._activeElement = element;
	            if (element) {
	                if (!this._focusAlignment) {
	                    this._setFocusAlignment(element, true, true);
	                }
	                this._activeElement.tabIndex = 0;
	                element.focus();
	                return true;
	            }
	        }
	        return false;
	    };
	    FocusZone.prototype._onFocus = function (ev) {
	        var onActiveElementChanged = this.props.onActiveElementChanged;
	        if (this._isImmediateDescendantOfZone(ev.target)) {
	            this._activeElement = ev.target;
	            this._setFocusAlignment(this._activeElement);
	        }
	        else {
	            var parentElement = ev.target;
	            while (parentElement && parentElement !== this.refs.root) {
	                if (Utilities_1.isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {
	                    this._activeElement = parentElement;
	                    break;
	                }
	                parentElement = Utilities_1.getParent(parentElement);
	            }
	        }
	        if (onActiveElementChanged) {
	            onActiveElementChanged(this._activeElement, ev);
	        }
	    };
	    /**
	     * Handle global tab presses so that we can patch tabindexes on the fly.
	     */
	    FocusZone.prototype._onKeyDownCapture = function (ev) {
	        if (ev.which === Utilities_1.KeyCodes.tab) {
	            this._updateTabIndexes();
	        }
	    };
	    FocusZone.prototype._onMouseDown = function (ev) {
	        var disabled = this.props.disabled;
	        if (disabled) {
	            return;
	        }
	        var target = ev.target;
	        var path = [];
	        while (target && target !== this.refs.root) {
	            path.push(target);
	            target = Utilities_1.getParent(target);
	        }
	        while (path.length) {
	            target = path.pop();
	            if (Utilities_1.isElementFocusZone(target)) {
	                break;
	            }
	            else if (target && Utilities_1.isElementTabbable(target)) {
	                target.tabIndex = 0;
	                this._setFocusAlignment(target, true, true);
	            }
	        }
	    };
	    /**
	     * Handle the keystrokes.
	     */
	    FocusZone.prototype._onKeyDown = function (ev) {
	        var _a = this.props, direction = _a.direction, disabled = _a.disabled, isInnerZoneKeystroke = _a.isInnerZoneKeystroke;
	        if (disabled) {
	            return;
	        }
	        if (isInnerZoneKeystroke &&
	            this._isImmediateDescendantOfZone(ev.target) &&
	            isInnerZoneKeystroke(ev)) {
	            // Try to focus
	            var innerZone = this._getFirstInnerZone();
	            if (!innerZone || !innerZone.focus()) {
	                return;
	            }
	        }
	        else {
	            switch (ev.which) {
	                case Utilities_1.KeyCodes.left:
	                    if (direction !== FocusZone_Props_1.FocusZoneDirection.vertical && this._moveFocusLeft()) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.right:
	                    if (direction !== FocusZone_Props_1.FocusZoneDirection.vertical && this._moveFocusRight()) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.up:
	                    if (direction !== FocusZone_Props_1.FocusZoneDirection.horizontal && this._moveFocusUp()) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.down:
	                    if (direction !== FocusZone_Props_1.FocusZoneDirection.horizontal && this._moveFocusDown()) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.home:
	                    var firstChild = this.refs.root.firstChild;
	                    if (this.focusElement(Utilities_1.getNextElement(this.refs.root, firstChild, true))) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.end:
	                    var lastChild = this.refs.root.lastChild;
	                    if (this.focusElement(Utilities_1.getPreviousElement(this.refs.root, lastChild, true, true, true))) {
	                        break;
	                    }
	                    return;
	                case Utilities_1.KeyCodes.enter:
	                    if (this._tryInvokeClickForFocusable(ev.target)) {
	                        break;
	                    }
	                    return;
	                default:
	                    return;
	            }
	        }
	        ev.preventDefault();
	        ev.stopPropagation();
	    };
	    /**
	     * Walk up the dom try to find a focusable element.
	     */
	    FocusZone.prototype._tryInvokeClickForFocusable = function (target) {
	        do {
	            if (target.tagName === 'BUTTON' || target.tagName === 'A') {
	                return false;
	            }
	            if (this._isImmediateDescendantOfZone(target) &&
	                target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
	                target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
	                Utilities_1.EventGroup.raise(target, 'click', null, true);
	                return true;
	            }
	            target = Utilities_1.getParent(target);
	        } while (target !== this.refs.root);
	        return false;
	    };
	    /**
	     * Traverse to find first child zone.
	     */
	    FocusZone.prototype._getFirstInnerZone = function (rootElement) {
	        rootElement = rootElement || this._activeElement || this.refs.root;
	        var child = rootElement.firstElementChild;
	        while (child) {
	            if (Utilities_1.isElementFocusZone(child)) {
	                return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
	            }
	            var match = this._getFirstInnerZone(child);
	            if (match) {
	                return match;
	            }
	            child = child.nextElementSibling;
	        }
	        return null;
	    };
	    FocusZone.prototype._moveFocus = function (isForward, getDistanceFromCenter, ev) {
	        var element = this._activeElement;
	        var candidateDistance = -1;
	        var candidateElement;
	        var changedFocus = false;
	        var isBidirectional = this.props.direction === FocusZone_Props_1.FocusZoneDirection.bidirectional;
	        if (!element) {
	            return false;
	        }
	        if (this._isElementInput(element)) {
	            if (!this._shouldInputLoseFocus(element, isForward)) {
	                return false;
	            }
	        }
	        var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
	        do {
	            element = isForward ?
	                Utilities_1.getNextElement(this.refs.root, element) :
	                Utilities_1.getPreviousElement(this.refs.root, element);
	            if (isBidirectional) {
	                if (element) {
	                    var targetRect = element.getBoundingClientRect();
	                    var elementDistance = getDistanceFromCenter(activeRect, targetRect);
	                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
	                        candidateDistance = elementDistance;
	                        candidateElement = element;
	                    }
	                    if (candidateDistance >= 0 && elementDistance < 0) {
	                        break;
	                    }
	                }
	            }
	            else {
	                candidateElement = element;
	                break;
	            }
	        } while (element);
	        // Focus the closest candidate
	        if (candidateElement && candidateElement !== this._activeElement) {
	            changedFocus = true;
	            this.focusElement(candidateElement);
	        }
	        else if (this.props.isCircularNavigation) {
	            if (isForward) {
	                return this.focusElement(Utilities_1.getNextElement(this.refs.root, this.refs.root.firstElementChild, true));
	            }
	            else {
	                return this.focusElement(Utilities_1.getPreviousElement(this.refs.root, this.refs.root.lastElementChild, true, true, true));
	            }
	        }
	        return changedFocus;
	    };
	    FocusZone.prototype._moveFocusDown = function () {
	        var targetTop = -1;
	        var leftAlignment = this._focusAlignment.left;
	        if (this._moveFocus(true, function (activeRect, targetRect) {
	            var distance = -1;
	            // ClientRect values can be floats that differ by very small fractions of a decimal.
	            // If the difference between top and bottom are within a pixel then we should treat
	            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
	            // but without Math.Floor they will be handled incorrectly.
	            var targetRectTop = Math.floor(targetRect.top);
	            var activeRectBottom = Math.floor(activeRect.bottom);
	            if ((targetTop === -1 && targetRectTop >= activeRectBottom) ||
	                (targetRectTop === targetTop)) {
	                targetTop = targetRectTop;
	                if (leftAlignment >= targetRect.left && leftAlignment <= (targetRect.left + targetRect.width)) {
	                    distance = 0;
	                }
	                else {
	                    distance = Math.abs((targetRect.left + (targetRect.width / 2)) - leftAlignment);
	                }
	            }
	            return distance;
	        })) {
	            this._setFocusAlignment(this._activeElement, false, true);
	            return true;
	        }
	        return false;
	    };
	    FocusZone.prototype._moveFocusUp = function () {
	        var targetTop = -1;
	        var leftAlignment = this._focusAlignment.left;
	        if (this._moveFocus(false, function (activeRect, targetRect) {
	            var distance = -1;
	            // ClientRect values can be floats that differ by very small fractions of a decimal.
	            // If the difference between top and bottom are within a pixel then we should treat
	            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
	            // but without Math.Floor they will be handled incorrectly.
	            var targetRectBottom = Math.floor(targetRect.bottom);
	            var targetRectTop = Math.floor(targetRect.top);
	            var activeRectTop = Math.floor(activeRect.top);
	            if ((targetTop === -1 && targetRectBottom <= activeRectTop) ||
	                (targetRectTop === targetTop)) {
	                targetTop = targetRectTop;
	                if (leftAlignment >= targetRect.left && leftAlignment <= (targetRect.left + targetRect.width)) {
	                    distance = 0;
	                }
	                else {
	                    distance = Math.abs((targetRect.left + (targetRect.width / 2)) - leftAlignment);
	                }
	            }
	            return distance;
	        })) {
	            this._setFocusAlignment(this._activeElement, false, true);
	            return true;
	        }
	        return false;
	    };
	    FocusZone.prototype._moveFocusLeft = function () {
	        var _this = this;
	        var targetTop = -1;
	        var topAlignment = this._focusAlignment.top;
	        if (this._moveFocus(Utilities_1.getRTL(), function (activeRect, targetRect) {
	            var distance = -1;
	            if ((targetTop === -1 &&
	                targetRect.right <= activeRect.right &&
	                (_this.props.direction === FocusZone_Props_1.FocusZoneDirection.horizontal || targetRect.top === activeRect.top)) ||
	                (targetRect.top === targetTop)) {
	                targetTop = targetRect.top;
	                distance = Math.abs((targetRect.top + (targetRect.height / 2)) - topAlignment);
	            }
	            return distance;
	        })) {
	            this._setFocusAlignment(this._activeElement, true, false);
	            return true;
	        }
	        return false;
	    };
	    FocusZone.prototype._moveFocusRight = function () {
	        var _this = this;
	        var targetTop = -1;
	        var topAlignment = this._focusAlignment.top;
	        if (this._moveFocus(!Utilities_1.getRTL(), function (activeRect, targetRect) {
	            var distance = -1;
	            if ((targetTop === -1 &&
	                targetRect.left >= activeRect.left &&
	                (_this.props.direction === FocusZone_Props_1.FocusZoneDirection.horizontal || targetRect.top === activeRect.top)) ||
	                (targetRect.top === targetTop)) {
	                targetTop = targetRect.top;
	                distance = Math.abs((targetRect.top + (targetRect.height / 2)) - topAlignment);
	            }
	            return distance;
	        })) {
	            this._setFocusAlignment(this._activeElement, true, false);
	            return true;
	        }
	        return false;
	    };
	    FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {
	        if (this.props.direction === FocusZone_Props_1.FocusZoneDirection.bidirectional &&
	            (!this._focusAlignment || isHorizontal || isVertical)) {
	            var rect = element.getBoundingClientRect();
	            var left = rect.left + (rect.width / 2);
	            var top_1 = rect.top + (rect.height / 2);
	            if (!this._focusAlignment) {
	                this._focusAlignment = { left: left, top: top_1 };
	            }
	            if (isHorizontal) {
	                this._focusAlignment.left = left;
	            }
	            if (isVertical) {
	                this._focusAlignment.top = top_1;
	            }
	        }
	    };
	    FocusZone.prototype._isImmediateDescendantOfZone = function (element) {
	        var parentElement = Utilities_1.getParent(element);
	        while (parentElement && parentElement !== this.refs.root && parentElement !== document.body) {
	            if (Utilities_1.isElementFocusZone(parentElement)) {
	                return false;
	            }
	            parentElement = Utilities_1.getParent(parentElement);
	        }
	        return true;
	    };
	    FocusZone.prototype._updateTabIndexes = function (element) {
	        if (!element) {
	            element = this.refs.root;
	            if (this._activeElement && !Utilities_1.elementContains(element, this._activeElement)) {
	                this._activeElement = null;
	            }
	        }
	        var childNodes = element.children;
	        for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
	            var child = childNodes[childIndex];
	            if (!Utilities_1.isElementFocusZone(child)) {
	                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
	                if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {
	                    child.setAttribute(TABINDEX, '-1');
	                }
	                if (Utilities_1.isElementTabbable(child)) {
	                    if (this.props.disabled) {
	                        child.setAttribute(TABINDEX, '-1');
	                    }
	                    else if (!this._isInnerZone && (!this._activeElement || this._activeElement === child)) {
	                        this._activeElement = child;
	                        if (child.getAttribute(TABINDEX) !== '0') {
	                            child.setAttribute(TABINDEX, '0');
	                        }
	                    }
	                    else if (child.getAttribute(TABINDEX) !== '-1') {
	                        child.setAttribute(TABINDEX, '-1');
	                    }
	                }
	                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
	                    // Disgusting IE hack. Sad face.
	                    child.setAttribute('focusable', 'false');
	                }
	                this._updateTabIndexes(child);
	            }
	        }
	    };
	    FocusZone.prototype._isElementInput = function (element) {
	        if (element && element.tagName && element.tagName.toLowerCase() === 'input') {
	            return true;
	        }
	        return false;
	    };
	    FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {
	        if (element &&
	            element.type &&
	            ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
	            var selectionStart = element.selectionStart;
	            var selectionEnd = element.selectionEnd;
	            var isRangeSelected = selectionStart !== selectionEnd;
	            var inputValue = element.value;
	            // We shouldn't lose focus in the following cases:
	            // 1. There is range selected.
	            // 2. When selection start is larger than 0 and it is backward.
	            // 3. when selection start is not the end of lenght and it is forward.
	            if (isRangeSelected ||
	                (selectionStart > 0 && !isForward) ||
	                (selectionStart !== inputValue.length && isForward)) {
	                return false;
	            }
	        }
	        return true;
	    };
	    return FocusZone;
	}(Utilities_1.BaseComponent));
	FocusZone.defaultProps = {
	    isCircularNavigation: false,
	    direction: FocusZone_Props_1.FocusZoneDirection.bidirectional
	};
	__decorate([
	    Utilities_1.autobind
	], FocusZone.prototype, "_onFocus", null);
	__decorate([
	    Utilities_1.autobind
	], FocusZone.prototype, "_onMouseDown", null);
	__decorate([
	    Utilities_1.autobind
	], FocusZone.prototype, "_onKeyDown", null);
	exports.FocusZone = FocusZone;
	


/***/ },
/* 435 */
/***/ function(module, exports) {

	"use strict";
	var FocusZoneDirection;
	(function (FocusZoneDirection) {
	    /** Only react to up/down arrows. */
	    FocusZoneDirection[FocusZoneDirection["vertical"] = 0] = "vertical";
	    /** Only react to left/right arrows. */
	    FocusZoneDirection[FocusZoneDirection["horizontal"] = 1] = "horizontal";
	    /** React to all arrows. */
	    FocusZoneDirection[FocusZoneDirection["bidirectional"] = 2] = "bidirectional";
	})(FocusZoneDirection = exports.FocusZoneDirection || (exports.FocusZoneDirection = {}));
	


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var PivotItem = (function (_super) {
	    __extends(PivotItem, _super);
	    function PivotItem() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PivotItem.prototype.render = function () {
	        return (React.createElement("div", null, this.props.children));
	    };
	    return PivotItem;
	}(React.Component));
	exports.PivotItem = PivotItem;
	


/***/ },
/* 437 */
/***/ function(module, exports) {

	"use strict";
	var PivotLinkFormat;
	(function (PivotLinkFormat) {
	    /**
	     * Display Pivot Links as links
	     */
	    PivotLinkFormat[PivotLinkFormat["links"] = 0] = "links";
	    /**
	     * Display Pivot Links as Tabs
	     */
	    PivotLinkFormat[PivotLinkFormat["tabs"] = 1] = "tabs";
	})(PivotLinkFormat = exports.PivotLinkFormat || (exports.PivotLinkFormat = {}));
	var PivotLinkSize;
	(function (PivotLinkSize) {
	    /**
	     * Display Link using normal font size
	     */
	    PivotLinkSize[PivotLinkSize["normal"] = 0] = "normal";
	    /**
	     * Display links using large font size
	     */
	    PivotLinkSize[PivotLinkSize["large"] = 1] = "large";
	})(PivotLinkSize = exports.PivotLinkSize || (exports.PivotLinkSize = {}));
	


/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Pivot{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;box-sizing:border-box;margin:0;padding:0;box-shadow:none;font-size:14px;font-weight:400;position:relative;color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";white-space:nowrap}.ms-Pivot-links{font-size:0;height:40px;list-style-type:none;padding:0;white-space:nowrap}.ms-Pivot-link{color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": ";display:inline-block;font-size:14px;font-weight:400;line-height:40px;padding:0 8px;text-align:center;position:relative;background-color:transparent;border:0}html[dir=ltr] .ms-Pivot-link{margin-right:8px}html[dir=rtl] .ms-Pivot-link{margin-left:8px}.ms-Pivot-link:hover{cursor:pointer}.ms-Pivot-link:focus{outline:0}.ms-Pivot-link::before{background-color:transparent;bottom:0;content:'';height:2px;left:8px;position:absolute;right:8px;-webkit-transition:background-color 267ms cubic-bezier(.1,.25,.75,.9);transition:background-color 267ms cubic-bezier(.1,.25,.75,.9)}.ms-Pivot-link::after{color:transparent;content:attr(title);display:block;font-weight:700;height:1px;overflow:hidden;visibility:hidden}.ms-Pivot-link .ms-Pivot-count,.ms-Pivot-link .ms-Pivot-text{display:inline-block;vertical-align:top}html[dir=ltr] .ms-Pivot-link .ms-Pivot-icon+.ms-Pivot-text{margin-left:4px}html[dir=rtl] .ms-Pivot-link .ms-Pivot-icon+.ms-Pivot-text{margin-right:4px}html[dir=ltr] .ms-Pivot-link .ms-Pivot-count{margin-left:4px}html[dir=rtl] .ms-Pivot-link .ms-Pivot-count{margin-right:4px}.ms-Pivot-link.is-selected{font-weight:600}.ms-Pivot-link.is-selected::before{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Pivot-link.is-disabled{color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": "}.ms-Fabric.is-focusVisible .ms-Pivot-link:focus{outline:1px solid " }, { "theme": "neutralSecondaryAlt", "defaultValue": "#767676" }, { "rawString": "}.ms-Pivot-link.ms-Pivot-link--overflow{color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-Pivot-link.ms-Pivot-link--overflow.is-selected{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Pivot-link.ms-Pivot-link--overflow:focus:not(.is-selected),.ms-Pivot-link.ms-Pivot-link--overflow:hover:not(.is-selected){color:" }, { "theme": "neutralDark", "defaultValue": "#212121" }, { "rawString": "}.ms-Pivot-link.ms-Pivot-link--overflow:active{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Pivot-ellipsis{font-size:15px;position:relative;top:0}.ms-Pivot-content{display:none;margin-top:20px}.ms-Pivot.ms-Pivot--large .ms-Pivot-link{font-size:17px}.ms-Pivot.ms-Pivot--large .ms-Pivot-link.ms-Pivot-link--overflow::after{font-size:17px}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link{height:40px;line-height:40px;background-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";padding:0 10px;vertical-align:top}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link::-moz-focus-inner{border:0}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-Pivot.ms-Pivot--tabs .ms-Pivot-link:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}html[dir=ltr] .ms-Pivot.ms-Pivot--tabs .ms-Pivot-link{margin-right:0}html[dir=rtl] .ms-Pivot.ms-Pivot--tabs .ms-Pivot-link{margin-left:0}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link:focus:not(.is-selected):not(.ms-Pivot-link--overflow),.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link:hover:not(.is-selected):not(.ms-Pivot-link--overflow){color:" }, { "theme": "black", "defaultValue": "#000000" }, { "rawString": "}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link:active{color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": ";background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.is-selected{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": ";font-weight:300}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.is-selected::before{background-color:transparent;-webkit-transition:none;transition:none}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.ms-Pivot-link--overflow:focus:not(.is-selected),.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.ms-Pivot-link--overflow:hover:not(.is-selected){background-color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.ms-Pivot-link--overflow:active{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Fabric.is-focusVisible .ms-Pivot.ms-Pivot--tabs .ms-Pivot-link:focus:before{height:auto;background:0 0;-webkit-transition:none;transition:none}@media screen and (-ms-high-contrast:active){.ms-Pivot.ms-Pivot--tabs .ms-Pivot-link.is-selected{font-weight:600}}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(440));
	


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(441));
	__export(__webpack_require__(442));
	


/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var Spinner_Props_1 = __webpack_require__(442);
	__webpack_require__(443);
	var Spinner = (function (_super) {
	    __extends(Spinner, _super);
	    function Spinner() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Spinner.prototype.render = function () {
	        var _a = this.props, type = _a.type, label = _a.label, className = _a.className;
	        return (React.createElement("div", { className: Utilities_1.css('ms-Spinner', className) },
	            React.createElement("div", { className: Utilities_1.css('ms-Spinner-circle', { 'ms-Spinner--normal': type === Spinner_Props_1.SpinnerType.normal }, { 'ms-Spinner--large': type === Spinner_Props_1.SpinnerType.large }) }),
	            label && (React.createElement("div", { className: 'ms-Spinner-label' }, label))));
	    };
	    return Spinner;
	}(React.Component));
	Spinner.defaultProps = {
	    type: Spinner_Props_1.SpinnerType.normal
	};
	exports.Spinner = Spinner;
	


/***/ },
/* 442 */
/***/ function(module, exports) {

	"use strict";
	var SpinnerType;
	(function (SpinnerType) {
	    SpinnerType[SpinnerType["normal"] = 0] = "normal";
	    SpinnerType[SpinnerType["large"] = 1] = "large";
	})(SpinnerType = exports.SpinnerType || (exports.SpinnerType = {}));
	


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": "@-webkit-keyframes ms-Spinner-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes ms-Spinner-spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.ms-Spinner>.ms-Spinner-circle{margin:auto;box-sizing:border-box;border-radius:50%;width:100%;height:100%;border:1.5px solid " }, { "theme": "themeLight", "defaultValue": "#c7e0f4" }, { "rawString": ";border-top-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";-webkit-animation:ms-Spinner-spin 1.3s infinite cubic-bezier(.53,.21,.29,.67);animation:ms-Spinner-spin 1.3s infinite cubic-bezier(.53,.21,.29,.67)}.ms-Spinner>.ms-Spinner-circle.ms-Spinner--normal{width:20px;height:20px}.ms-Spinner>.ms-Spinner-circle.ms-Spinner--large{width:28px;height:28px}.ms-Spinner>.ms-Spinner-label{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";margin-top:10px;text-align:center}@media screen and (-ms-high-contrast:active){.ms-Spinner>.ms-Spinner-circle{border-top-style:none}}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(445));
	


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(446));
	__export(__webpack_require__(447));
	__export(__webpack_require__(448));
	__export(__webpack_require__(452));
	__export(__webpack_require__(454));
	__export(__webpack_require__(449));
	__export(__webpack_require__(458));
	__export(__webpack_require__(456));
	


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var BaseButton = (function (_super) {
	    __extends(BaseButton, _super);
	    function BaseButton(props, rootClassName, deprecationMap) {
	        var _this = _super.call(this, props, { 'rootProps': null }) || this;
	        /**
	         * _baseClassName can be overridden by subclasses to provide a unique class prefix to the class name used for
	         * sub parts of the render template.
	         */
	        _this._baseClassName = 'ms-Button';
	        /**
	         * _variantClassName can be overridden by subclasses to add an extra default class name to the root element.
	         */
	        _this._variantClassName = '';
	        _this._labelId = Utilities_1.getId();
	        _this._descriptionId = Utilities_1.getId();
	        _this._ariaDescriptionId = Utilities_1.getId();
	        return _this;
	    }
	    BaseButton.prototype.render = function () {
	        var _a = this.props, className = _a.className, description = _a.description, ariaLabel = _a.ariaLabel, ariaDescription = _a.ariaDescription, href = _a.href, disabled = _a.disabled;
	        var _b = this, _ariaDescriptionId = _b._ariaDescriptionId, _labelId = _b._labelId, _descriptionId = _b._descriptionId;
	        var renderAsAnchor = !!href;
	        var tag = renderAsAnchor ? 'a' : 'button';
	        var nativeProps = Utilities_1.getNativeProps(this.props.rootProps || this.props, renderAsAnchor ? Utilities_1.anchorProperties : Utilities_1.buttonProperties, [
	            'disabled' // Let disabled buttons be focused and styled as disabled.
	        ]);
	        // Check for ariaDescription, description or aria-describedby in the native props to determine source of aria-describedby
	        // otherwise default to null.
	        var ariaDescribedBy;
	        if (ariaDescription) {
	            ariaDescribedBy = _ariaDescriptionId;
	        }
	        else if (description) {
	            ariaDescribedBy = _descriptionId;
	        }
	        else if (nativeProps['aria-describedby']) {
	            ariaDescribedBy = nativeProps['aria-describedby'];
	        }
	        else {
	            ariaDescribedBy = null;
	        }
	        var buttonProps = Utilities_1.assign(nativeProps, {
	            className: Utilities_1.css(className, this._baseClassName, this._variantClassName, { 'disabled': disabled }),
	            ref: this._resolveRef('_buttonElement'),
	            'aria-label': ariaLabel,
	            'aria-labelledby': ariaLabel ? null : _labelId,
	            'aria-describedby': ariaDescribedBy
	        });
	        return this.onRenderContent(tag, buttonProps);
	    };
	    BaseButton.prototype.focus = function () {
	        if (this._buttonElement) {
	            this._buttonElement.focus();
	        }
	    };
	    BaseButton.prototype.onRenderContent = function (tag, buttonProps) {
	        return React.createElement(tag, buttonProps, this.onRenderIcon(), this.onRenderLabel(), this.onRenderDescription(), this.onRenderAriaDescription(), this.onRenderChildren());
	    };
	    BaseButton.prototype.onRenderIcon = function () {
	        var icon = this.props.icon;
	        return icon ? (React.createElement("span", { className: this._baseClassName + "-icon" },
	            React.createElement("i", { className: "ms-Icon ms-Icon--" + icon }))) : (null);
	    };
	    BaseButton.prototype.onRenderLabel = function () {
	        var _a = this.props, children = _a.children, label = _a.label;
	        // For backwards compat, we should continue to take in the label content from children.
	        if (label === undefined && typeof (children) === 'string') {
	            label = children;
	        }
	        return label ? (React.createElement("span", { className: this._baseClassName + "-label", id: this._labelId }, label)) : (null);
	    };
	    BaseButton.prototype.onRenderChildren = function () {
	        var _a = this.props, children = _a.children, label = _a.label;
	        // There is no label and the label will be rendered, we don't want the label to appear twice.
	        // If there is a label and the children are of type string it was likely intentional and both
	        // should render.
	        if (label === undefined && typeof (children) === 'string') {
	            return null;
	        }
	        return children;
	    };
	    BaseButton.prototype.onRenderDescription = function () {
	        var description = this.props.description;
	        // ms-Button-description is only shown when the button type is compound.
	        // In other cases it will not be displayed.
	        return description ? (React.createElement("span", { className: this._baseClassName + "-description", id: this._descriptionId }, description)) : (null);
	    };
	    BaseButton.prototype.onRenderAriaDescription = function () {
	        var ariaDescription = this.props.ariaDescription;
	        // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
	        // otherwise it will be assigned to descriptionSpan.
	        return ariaDescription ? (React.createElement("span", { className: 'ms-u-screenReaderOnly', id: this._ariaDescriptionId }, ariaDescription)) : (null);
	    };
	    return BaseButton;
	}(Utilities_1.BaseComponent));
	exports.BaseButton = BaseButton;
	


/***/ },
/* 447 */
/***/ function(module, exports) {

	"use strict";
	var ElementType;
	(function (ElementType) {
	    /** <button> element. */
	    ElementType[ElementType["button"] = 0] = "button";
	    /** <a> element. */
	    ElementType[ElementType["anchor"] = 1] = "anchor";
	})(ElementType = exports.ElementType || (exports.ElementType = {}));
	var ButtonType;
	(function (ButtonType) {
	    ButtonType[ButtonType["normal"] = 0] = "normal";
	    ButtonType[ButtonType["primary"] = 1] = "primary";
	    ButtonType[ButtonType["hero"] = 2] = "hero";
	    ButtonType[ButtonType["compound"] = 3] = "compound";
	    ButtonType[ButtonType["command"] = 4] = "command";
	    ButtonType[ButtonType["icon"] = 5] = "icon";
	    ButtonType[ButtonType["default"] = 6] = "default";
	})(ButtonType = exports.ButtonType || (exports.ButtonType = {}));
	


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	/* tslint:disable:no-unused-variable */
	var React = __webpack_require__(386);
	/* tslint:enable:no-unused-variable */
	var Utilities_1 = __webpack_require__(410);
	var Button_Props_1 = __webpack_require__(447);
	var DefaultButton_1 = __webpack_require__(449);
	var CommandButton_1 = __webpack_require__(452);
	var CompoundButton_1 = __webpack_require__(454);
	var IconButton_1 = __webpack_require__(456);
	var PrimaryButton_1 = __webpack_require__(458);
	/**
	 * @deprecated
	 * This class is deprecated. Use the individual *Button components instead.
	 */
	var Button = (function (_super) {
	    __extends(Button, _super);
	    function Button() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Button.prototype.render = function () {
	        var props = this.props;
	        switch (props.buttonType) {
	            case Button_Props_1.ButtonType.command:
	                return React.createElement(CommandButton_1.CommandButton, __assign({}, props, { ref: this._resolveRef('_button') }));
	            case Button_Props_1.ButtonType.compound:
	                return React.createElement(CompoundButton_1.CompoundButton, __assign({}, props, { ref: this._resolveRef('_button') }));
	            case Button_Props_1.ButtonType.icon:
	                return React.createElement(IconButton_1.IconButton, __assign({}, props, { ref: this._resolveRef('_button') }));
	            case Button_Props_1.ButtonType.primary:
	                return React.createElement(PrimaryButton_1.PrimaryButton, __assign({}, props, { ref: this._resolveRef('_button') }));
	            default:
	                return React.createElement(DefaultButton_1.DefaultButton, __assign({}, props, { ref: this._resolveRef('_button') }));
	        }
	    };
	    Button.prototype.focus = function () {
	        if (this._button) {
	            this._button.focus();
	        }
	    };
	    return Button;
	}(Utilities_1.BaseComponent));
	exports.Button = Button;
	


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseButton_1 = __webpack_require__(446);
	__webpack_require__(450);
	__webpack_require__(451);
	var DefaultButton = (function (_super) {
	    __extends(DefaultButton, _super);
	    function DefaultButton() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._variantClassName = 'ms-Button--default';
	        return _this;
	    }
	    DefaultButton.prototype.onRenderDescription = function () {
	        return null;
	    };
	    return DefaultButton;
	}(BaseButton_1.BaseButton));
	exports.DefaultButton = DefaultButton;
	


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button.ms-Button--default{background-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";border:1px solid " }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";min-width:80px;color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": "}.ms-Button.ms-Button--default .ms-Button-icon,.ms-Button.ms-Button--default .ms-Button-label{height:32px;line-height:32px}.ms-Button.ms-Button--default:hover{background-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": ";border-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": ";color:" }, { "theme": "black", "defaultValue": "#000000" }, { "rawString": "}.ms-Button.ms-Button--default:focus{background-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": ";border-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";outline:1px solid transparent;color:" }, { "theme": "black", "defaultValue": "#000000" }, { "rawString": "}.ms-Button.ms-Button--default:active{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Button.ms-Button--default .ms-Button-label{font-weight:600;font-size:14px}.ms-Button.ms-Button--default.disabled,.ms-Button.ms-Button--default:disabled{background-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";border-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";cursor:default;pointer-events:none;color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": "}.ms-Button.ms-Button--default.disabled:focus,.ms-Button.ms-Button--default.disabled:hover,.ms-Button.ms-Button--default:disabled:focus,.ms-Button.ms-Button--default:disabled:hover{outline:0}.ms-Fabric.is-focusVisible .ms-Button:focus{color:" }, { "theme": "black", "defaultValue": "#000000" }, { "rawString": "}.ms-Fabric.is-focusVisible .ms-Button:focus:before{border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;font-size:14px;font-weight:400;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-width:0;text-decoration:none;text-align:center;cursor:pointer;display:inline-block;padding:0 16px}.ms-Button::-moz-focus-inner{border:0}.ms-Button{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-Button:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}@media screen and (-ms-high-contrast:active){.ms-Button{color:#1AEBFF;border-color:#1AEBFF}}@media screen and (-ms-high-contrast:black-on-white){.ms-Button{color:#37006E;border-color:#37006E}}.ms-Button-icon{margin:0 4px;width:16px;vertical-align:top;display:inline-block}.ms-Button-label{margin:0 4px;vertical-align:top;display:inline-block}.ms-Button--hero{background-color:transparent;border:0;height:auto}.ms-Button--hero .ms-Button-icon{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";display:inline-block;padding-top:5px;font-size:20px;line-height:1}html[dir=ltr] .ms-Button--hero .ms-Button-icon{margin-right:8px}html[dir=rtl] .ms-Button--hero .ms-Button-icon{margin-left:8px}.ms-Button--hero .ms-Button-label{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";font-size:21px;font-weight:100;vertical-align:top}.ms-Button--hero:focus,.ms-Button--hero:hover{background-color:transparent}.ms-Button--hero:focus .ms-Button-icon,.ms-Button--hero:hover .ms-Button-icon{color:" }, { "theme": "themeDark", "defaultValue": "#005a9e" }, { "rawString": "}.ms-Button--hero:focus .ms-Button-label,.ms-Button--hero:hover .ms-Button-label{color:" }, { "theme": "themeDarker", "defaultValue": "#004578" }, { "rawString": "}.ms-Button--hero:active .ms-Button-icon{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button--hero:active .ms-Button-label{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button--hero.is-disabled .ms-Button-icon,.ms-Button--hero:disabled .ms-Button-icon{color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": "}.ms-Button--hero.is-disabled .ms-Button-label,.ms-Button--hero:disabled .ms-Button-label{color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseButton_1 = __webpack_require__(446);
	__webpack_require__(453);
	__webpack_require__(451);
	var CommandButton = (function (_super) {
	    __extends(CommandButton, _super);
	    function CommandButton() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._variantClassName = 'ms-Button--command';
	        return _this;
	    }
	    CommandButton.prototype.onRenderDescription = function () {
	        return null;
	    };
	    return CommandButton;
	}(BaseButton_1.BaseButton));
	exports.CommandButton = CommandButton;
	


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button.ms-Button--command{background-color:transparent;border:none;padding:0 4px}html[dir=ltr] .ms-Button.ms-Button--command{text-align:left}html[dir=rtl] .ms-Button.ms-Button--command{text-align:right}.ms-Button.ms-Button--command .ms-Button-icon,.ms-Button.ms-Button--command .ms-Button-label{height:40px;line-height:40px}.ms-Button.ms-Button--command .ms-Button-label{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;font-size:14px;font-weight:400;font-weight:400;color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": "}.ms-Button.ms-Button--command .ms-Button-icon{vertical-align:top;color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";display:inline-block;font-size:16px;position:relative}.ms-Button.ms-Button--command:focus,.ms-Button.ms-Button--command:hover{background-color:transparent}.ms-Button.ms-Button--command:focus,.ms-Button.ms-Button--command:focus .ms-Button-icon,.ms-Button.ms-Button--command:focus .ms-Button-label,.ms-Button.ms-Button--command:hover,.ms-Button.ms-Button--command:hover .ms-Button-icon,.ms-Button.ms-Button--command:hover .ms-Button-label{color:" }, { "theme": "themeDarker", "defaultValue": "#004578" }, { "rawString": "}.ms-Button.ms-Button--command:active,.ms-Button.ms-Button--command:active .ms-Button-icon,.ms-Button.ms-Button--command:active .ms-Button-label{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button.ms-Button--command.disabled,.ms-Button.ms-Button--command:disabled{background-color:transparent}.ms-Button.ms-Button--command.disabled .ms-Button-icon,.ms-Button.ms-Button--command.disabled .ms-Button-label,.ms-Button.ms-Button--command:disabled .ms-Button-icon,.ms-Button.ms-Button--command:disabled .ms-Button-label{color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseButton_1 = __webpack_require__(446);
	__webpack_require__(455);
	__webpack_require__(451);
	var CompoundButton = (function (_super) {
	    __extends(CompoundButton, _super);
	    function CompoundButton() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._variantClassName = 'ms-Button--compound';
	        return _this;
	    }
	    CompoundButton.prototype.onRenderIcon = function () {
	        return null;
	    };
	    return CompoundButton;
	}(BaseButton_1.BaseButton));
	exports.CompoundButton = CompoundButton;
	


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button.ms-Button--compound{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;width:100%;max-width:280px;min-height:72px;padding:16px 20px;background:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": "}html[dir=ltr] .ms-Button.ms-Button--compound{text-align:left}html[dir=rtl] .ms-Button.ms-Button--compound{text-align:right}.ms-Button.ms-Button--compound .ms-Button-label{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;font-size:14px;font-weight:400;display:block;font-weight:600;color:" }, { "theme": "black", "defaultValue": "#000000" }, { "rawString": ";margin:0 0 2px}.ms-Button.ms-Button--compound .ms-Button-description{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;font-size:12px;font-weight:400;color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": ";display:block}.ms-Button.ms-Button--compound:hover{background-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": ";border-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": "}.ms-Button.ms-Button--compound:hover .ms-Button-description{color:" }, { "theme": "neutralDark", "defaultValue": "#212121" }, { "rawString": "}.ms-Button.ms-Button--compound:focus{border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";background-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": "}.ms-Button.ms-Button--compound:focus .ms-Button-label{color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": "}.ms-Button.ms-Button--compound:focus .ms-Button-description{color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-Button.ms-Button--compound:active{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button.ms-Button--compound:active .ms-Button-description,.ms-Button.ms-Button--compound:active .ms-Button-label{color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Button.ms-Button--compound.disabled .ms-Button-description,.ms-Button.ms-Button--compound.disabled .ms-Button-label,.ms-Button.ms-Button--compound:disabled .ms-Button-description,.ms-Button.ms-Button--compound:disabled .ms-Button-label{color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseButton_1 = __webpack_require__(446);
	__webpack_require__(457);
	__webpack_require__(451);
	var IconButton = (function (_super) {
	    __extends(IconButton, _super);
	    function IconButton() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._variantClassName = 'ms-Button--icon';
	        return _this;
	    }
	    IconButton.prototype.onRenderLabel = function () {
	        return null;
	    };
	    IconButton.prototype.onRenderDescription = function () {
	        return null;
	    };
	    IconButton.prototype.onRenderChildren = function () {
	        return null;
	    };
	    return IconButton;
	}(BaseButton_1.BaseButton));
	exports.IconButton = IconButton;
	


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button.ms-Button--icon{background-color:transparent;color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": ";padding:0 4px;font-size:16px}.ms-Button.ms-Button--icon::-moz-focus-inner{border:0}.ms-Button.ms-Button--icon{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-Button.ms-Button--icon:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-Button.ms-Button--icon .ms-Button-icon,.ms-Button.ms-Button--icon .ms-Button-label{height:32px;line-height:32px}.ms-Button.ms-Button--icon:active,.ms-Button.ms-Button--icon:hover{background-color:transparent;color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": "}.ms-Button.ms-Button--icon:focus{background-color:transparent}.ms-Button.ms-Button--icon.disabled,.ms-Button.ms-Button--icon:disabled{color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": ";background-color:transparent}@media screen and (-ms-high-contrast:active){.ms-Button.ms-Button--icon{color:" }, { "theme": "yellowLight", "defaultValue": "#fff100" }, { "rawString": "}}@media screen and (-ms-high-contrast:black-on-white){.ms-Button.ms-Button--icon{color:" }, { "theme": "blueMid", "defaultValue": "#00188f" }, { "rawString": "}}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseButton_1 = __webpack_require__(446);
	__webpack_require__(459);
	__webpack_require__(451);
	var PrimaryButton = (function (_super) {
	    __extends(PrimaryButton, _super);
	    function PrimaryButton() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._variantClassName = 'ms-Button--primary';
	        return _this;
	    }
	    PrimaryButton.prototype.onRenderDescription = function () {
	        return null;
	    };
	    return PrimaryButton;
	}(BaseButton_1.BaseButton));
	exports.PrimaryButton = PrimaryButton;
	


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Button.ms-Button--primary{min-width:80px;background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Button.ms-Button--primary::-moz-focus-inner{border:0}.ms-Button.ms-Button--primary{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-Button.ms-Button--primary:focus:after{content:'';position:absolute;top:1px;right:1px;bottom:1px;left:1px;pointer-events:none;border:1px solid " }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Button.ms-Button--primary .ms-Button-icon,.ms-Button.ms-Button--primary .ms-Button-label{height:32px;line-height:32px}.ms-Button.ms-Button--primary .ms-Button-label{font-weight:600;font-size:14px}.ms-Button.ms-Button--primary:hover{background-color:" }, { "theme": "themeDark", "defaultValue": "#005a9e" }, { "rawString": ";border-color:" }, { "theme": "themeDark", "defaultValue": "#005a9e" }, { "rawString": "}.ms-Button.ms-Button--primary:focus{background-color:" }, { "theme": "themeDark", "defaultValue": "#005a9e" }, { "rawString": ";border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button.ms-Button--primary:active{background-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";border-color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Button.ms-Button--primary.disabled,.ms-Button.ms-Button--primary:disabled{background-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";border-color:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": ";cursor:default;pointer-events:none;color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": "}.ms-Button.ms-Button--primary.disabled:focus,.ms-Button.ms-Button--primary.disabled:hover,.ms-Button.ms-Button--primary:disabled:focus,.ms-Button.ms-Button--primary:disabled:hover{outline:0}.ms-Fabric.is-focusVisible .ms-Button--primary:focus{color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Fabric.is-focusVisible .ms-Button--primary:focus:before{border-color:" }, { "theme": "themeLighter", "defaultValue": "#deecf9" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(461));
	


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(462));
	__export(__webpack_require__(467));
	__export(__webpack_require__(468));
	__export(__webpack_require__(475));
	__export(__webpack_require__(476));
	


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(463));
	__export(__webpack_require__(464));
	__export(__webpack_require__(465));
	__export(__webpack_require__(466));
	


/***/ },
/* 463 */
/***/ function(module, exports) {

	"use strict";
	exports.SELECTION_CHANGE = 'change';
	var SelectionMode;
	(function (SelectionMode) {
	    SelectionMode[SelectionMode["none"] = 0] = "none";
	    SelectionMode[SelectionMode["single"] = 1] = "single";
	    SelectionMode[SelectionMode["multiple"] = 2] = "multiple";
	})(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));
	var SelectionDirection;
	(function (SelectionDirection) {
	    SelectionDirection[SelectionDirection["horizontal"] = 0] = "horizontal";
	    SelectionDirection[SelectionDirection["vertical"] = 1] = "vertical";
	})(SelectionDirection = exports.SelectionDirection || (exports.SelectionDirection = {}));
	


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var interfaces_1 = __webpack_require__(463);
	var Utilities_1 = __webpack_require__(410);
	var Selection = (function () {
	    function Selection(options) {
	        if (options === void 0) { options = {}; }
	        var onSelectionChanged = options.onSelectionChanged, getKey = options.getKey, _a = options.canSelectItem, canSelectItem = _a === void 0 ? function (item) { return true; } : _a;
	        this.getKey = getKey || (function (item, index) { return (item ? item.key : String(index)); });
	        this._changeEventSuppressionCount = 0;
	        this._exemptedCount = 0;
	        this._anchoredIndex = 0;
	        this._unselectableCount = 0;
	        this.setItems([], true);
	        this._onSelectionChanged = onSelectionChanged;
	        this.canSelectItem = canSelectItem;
	    }
	    Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {
	        this._changeEventSuppressionCount += isEnabled ? -1 : 1;
	        if (this._changeEventSuppressionCount === 0 && this._hasChanged) {
	            this._hasChanged = false;
	            if (!suppressChange) {
	                this._change();
	            }
	        }
	    };
	    /**
	     * Selection needs the items, call this method to set them. If the set
	     * of items is the same, this will re-evaluate selection and index maps.
	     * Otherwise, shouldClear should be set to true, so that selection is
	     * cleared.
	     */
	    Selection.prototype.setItems = function (items, shouldClear) {
	        if (shouldClear === void 0) { shouldClear = true; }
	        var newKeyToIndexMap = {};
	        var newUnselectableIndices = {};
	        var hasSelectionChanged = false;
	        this.setChangeEvents(false);
	        // Reset the unselectable count.
	        this._unselectableCount = 0;
	        // Build lookup table for quick selection evaluation.
	        for (var i = 0; i < items.length; i++) {
	            var item = items[i];
	            if (item) {
	                newKeyToIndexMap[this.getKey(item, i)] = i;
	            }
	            newUnselectableIndices[i] = item && !this.canSelectItem(item);
	            if (newUnselectableIndices[i]) {
	                this._unselectableCount++;
	            }
	        }
	        if (shouldClear) {
	            this.setAllSelected(false);
	        }
	        // Check the exemption list for discrepencies.
	        var newExemptedIndicies = {};
	        for (var indexProperty in this._exemptedIndices) {
	            if (this._exemptedIndices.hasOwnProperty(indexProperty)) {
	                var index = Number(indexProperty);
	                var item = this._items[index];
	                var exemptKey = item ? this.getKey(item, Number(index)) : undefined;
	                var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;
	                if (newIndex === undefined) {
	                    // We don't know the index of the item any more so it's either moved or removed.
	                    // In this case we reset the entire selection.
	                    this.setAllSelected(false);
	                    break;
	                }
	                else {
	                    // We know the new index of the item. update the existing exemption table.
	                    newExemptedIndicies[newIndex] = true;
	                    hasSelectionChanged = hasSelectionChanged || (newIndex !== index);
	                }
	            }
	        }
	        this._exemptedIndices = newExemptedIndicies;
	        this._keyToIndexMap = newKeyToIndexMap;
	        this._unselectableIndices = newUnselectableIndices;
	        this._items = items || [];
	        if (hasSelectionChanged) {
	            this._change();
	        }
	        this.setChangeEvents(true);
	    };
	    Selection.prototype.getItems = function () {
	        return this._items;
	    };
	    Selection.prototype.getSelection = function () {
	        if (!this._selectedItems) {
	            this._selectedItems = [];
	            for (var i = 0; i < this._items.length; i++) {
	                if (this.isIndexSelected(i)) {
	                    this._selectedItems.push(this._items[i]);
	                }
	            }
	        }
	        return this._selectedItems;
	    };
	    Selection.prototype.getSelectedCount = function () {
	        return this._isAllSelected ? (this._items.length - this._exemptedCount - this._unselectableCount) : (this._exemptedCount);
	    };
	    Selection.prototype.isRangeSelected = function (fromIndex, count) {
	        var endIndex = fromIndex + count;
	        for (var i = fromIndex; i < endIndex; i++) {
	            if (!this.isIndexSelected(i)) {
	                return false;
	            }
	        }
	        return true;
	    };
	    Selection.prototype.isAllSelected = function () {
	        var selectableCount = this._items.length - this._unselectableCount;
	        return ((this.count > 0) &&
	            (this._isAllSelected && this._exemptedCount === 0) ||
	            (!this._isAllSelected && (this._exemptedCount === selectableCount) && selectableCount > 0));
	    };
	    Selection.prototype.isKeySelected = function (key) {
	        var index = this._keyToIndexMap[key];
	        return this.isIndexSelected(index);
	    };
	    Selection.prototype.isIndexSelected = function (index) {
	        return !!((this.count > 0) &&
	            (this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index]) ||
	            (!this._isAllSelected && this._exemptedIndices[index]));
	    };
	    Selection.prototype.setAllSelected = function (isAllSelected) {
	        var selectableCount = this._items ? (this._items.length - this._unselectableCount) : 0;
	        if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {
	            this._exemptedIndices = {};
	            this._exemptedCount = 0;
	            this._isAllSelected = isAllSelected;
	            this._updateCount();
	        }
	    };
	    Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {
	        var index = this._keyToIndexMap[key];
	        if (index >= 0) {
	            this.setIndexSelected(index, isSelected, shouldAnchor);
	        }
	    };
	    Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {
	        // Clamp the index.
	        index = Math.min(Math.max(0, index), this._items.length - 1);
	        // No-op on out of bounds selections.
	        if (index < 0 || index >= this._items.length) {
	            return;
	        }
	        var isExempt = this._exemptedIndices[index];
	        var hasChanged = false;
	        var canSelect = !this._unselectableIndices[index];
	        if (canSelect) {
	            // Determine if we need to remove the exemption.
	            if (isExempt && ((isSelected && this._isAllSelected) ||
	                (!isSelected && !this._isAllSelected))) {
	                hasChanged = true;
	                delete this._exemptedIndices[index];
	                this._exemptedCount--;
	            }
	            // Determine if we need to add the exemption.
	            if (!isExempt && ((isSelected && !this._isAllSelected) ||
	                (!isSelected && this._isAllSelected))) {
	                hasChanged = true;
	                this._exemptedIndices[index] = true;
	                this._exemptedCount++;
	            }
	            if (shouldAnchor) {
	                this._anchoredIndex = index;
	            }
	        }
	        if (hasChanged) {
	            this._updateCount();
	        }
	    };
	    Selection.prototype.selectToKey = function (key, clearSelection) {
	        this.selectToIndex(this._keyToIndexMap[key], clearSelection);
	    };
	    Selection.prototype.selectToIndex = function (index, clearSelection) {
	        var anchorIndex = this._anchoredIndex || 0;
	        var startIndex = Math.min(index, anchorIndex);
	        var endIndex = Math.max(index, anchorIndex);
	        this.setChangeEvents(false);
	        if (clearSelection) {
	            this.setAllSelected(false);
	        }
	        for (; startIndex <= endIndex; startIndex++) {
	            this.setIndexSelected(startIndex, true, false);
	        }
	        this.setChangeEvents(true);
	    };
	    Selection.prototype.toggleAllSelected = function () {
	        this.setAllSelected(!this.isAllSelected());
	    };
	    Selection.prototype.toggleKeySelected = function (key) {
	        this.setKeySelected(key, !this.isKeySelected(key), true);
	    };
	    Selection.prototype.toggleIndexSelected = function (index) {
	        this.setIndexSelected(index, !this.isIndexSelected(index), true);
	    };
	    Selection.prototype.toggleRangeSelected = function (fromIndex, count) {
	        var isRangeSelected = this.isRangeSelected(fromIndex, count);
	        var endIndex = fromIndex + count;
	        this.setChangeEvents(false);
	        for (var i = fromIndex; i < endIndex; i++) {
	            this.setIndexSelected(i, !isRangeSelected, false);
	        }
	        this.setChangeEvents(true);
	    };
	    Selection.prototype._updateCount = function () {
	        this.count = this.getSelectedCount();
	        this._change();
	    };
	    Selection.prototype._change = function () {
	        if (this._changeEventSuppressionCount === 0) {
	            this._selectedItems = null;
	            Utilities_1.EventGroup.raise(this, interfaces_1.SELECTION_CHANGE);
	            if (this._onSelectionChanged) {
	                this._onSelectionChanged();
	            }
	        }
	        else {
	            this._hasChanged = true;
	        }
	    };
	    return Selection;
	}());
	exports.Selection = Selection;
	


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var interfaces_1 = __webpack_require__(463);
	var SelectionLayout = (function () {
	    function SelectionLayout(direction) {
	        this._direction = direction;
	    }
	    SelectionLayout.prototype.getItemIndexAbove = function (focusIndex, items) {
	        return (this._direction === interfaces_1.SelectionDirection.vertical) ? Math.max(0, focusIndex - 1) : focusIndex;
	    };
	    SelectionLayout.prototype.getItemIndexBelow = function (focusIndex, items) {
	        return (this._direction === interfaces_1.SelectionDirection.vertical) ? Math.min(items.length - 1, focusIndex + 1) : focusIndex;
	    };
	    SelectionLayout.prototype.getItemIndexLeft = function (focusIndex, items) {
	        return (this._direction === interfaces_1.SelectionDirection.vertical) ? focusIndex : Math.max(0, focusIndex - 1);
	    };
	    SelectionLayout.prototype.getItemIndexRight = function (focusIndex, items) {
	        return (this._direction === interfaces_1.SelectionDirection.vertical) ? focusIndex : Math.min(items.length - 1, focusIndex + 1);
	    };
	    return SelectionLayout;
	}());
	exports.SelectionLayout = SelectionLayout;
	


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var SelectionLayout_1 = __webpack_require__(465);
	var interfaces_1 = __webpack_require__(463);
	// Selection definitions:
	//
	// Anchor index: the point from which a range selection starts.
	// Focus index: the point from which layout movement originates from.
	//
	// These two can differ. Tests:
	//
	// If you start at index 5
	// Shift click to index 10
	//    The focus is 10, the anchor is 5.
	// If you shift click at index 0
	//    The anchor remains at 5, the items between 0 and 5 are selected and everything else is cleared.
	// If you click index 8
	//    The anchor and focus are set to 8.
	var SELECTION_DISABLED_ATTRIBUTE_NAME = 'data-selection-disabled';
	var SELECTION_INDEX_ATTRIBUTE_NAME = 'data-selection-index';
	var SELECTION_TOGGLE_ATTRIBUTE_NAME = 'data-selection-toggle';
	var SELECTION_INVOKE_ATTRIBUTE_NAME = 'data-selection-invoke';
	var SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME = 'data-selection-all-toggle';
	var SelectionZone = (function (_super) {
	    __extends(SelectionZone, _super);
	    function SelectionZone() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    SelectionZone.prototype.componentDidMount = function () {
	        var win = Utilities_1.getWindow(this.refs.root);
	        var scrollElement = Utilities_1.findScrollableParent(this.refs.root);
	        // Track the latest modifier keys globally.
	        this._events.on(win, 'keydown keyup', this._updateModifiers);
	        this._events.on(scrollElement, 'click', this._tryClearOnEmptyClick);
	    };
	    SelectionZone.prototype.render = function () {
	        return (React.createElement("div", __assign({ className: 'ms-SelectionZone', ref: 'root', onKeyDown: this._onKeyDown, onMouseDown: this._onMouseDown, onClick: this._onClick, onDoubleClick: this._onDoubleClick, onContextMenu: this._onContextMenu }, {
	            onMouseDownCapture: this.ignoreNextFocus,
	            onFocusCapture: this._onFocus
	        }), this.props.children));
	    };
	    /**
	     * In some cases, the consuming scenario requires to set focus on a row without having SelectionZone
	     * react to the event. Note that focus events in IE <= 11 will occur asynchronously after .focus() has
	     * been called on an element, so we need a flag to store the idea that we will bypass the "next"
	     * focus event that occurs. This method does that.
	     */
	    SelectionZone.prototype.ignoreNextFocus = function () {
	        this._shouldIgnoreFocus = true;
	    };
	    /**
	     * When we focus an item, for single/multi select scenarios, we should try to select it immediately
	     * as long as the focus did not originate from a mouse down/touch event. For those cases, we handle them
	     * specially.
	     */
	    SelectionZone.prototype._onFocus = function (ev) {
	        var target = ev.target;
	        var _a = this.props, selection = _a.selection, selectionMode = _a.selectionMode;
	        var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;
	        if (this._shouldIgnoreFocus || selectionMode === interfaces_1.SelectionMode.none) {
	            this._shouldIgnoreFocus = false;
	            return;
	        }
	        var isToggle = this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME);
	        var itemRoot = this._findItemRoot(target);
	        if (!isToggle && itemRoot) {
	            var index = this._getItemIndex(itemRoot);
	            if (isToggleModifierPressed) {
	                // set anchor only.
	                selection.setIndexSelected(index, selection.isIndexSelected(index), true);
	            }
	            else {
	                this._onItemSurfaceClick(ev, index);
	            }
	        }
	    };
	    SelectionZone.prototype._onMouseDown = function (ev) {
	        this._updateModifiers(ev);
	        var target = ev.target;
	        var itemRoot = this._findItemRoot(target);
	        while (target !== this.refs.root) {
	            if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
	                break;
	            }
	            else if (itemRoot) {
	                if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
	                    break;
	                }
	                else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
	                    this._onInvokeMouseDown(ev, this._getItemIndex(itemRoot));
	                    break;
	                }
	                else if (target === itemRoot) {
	                    break;
	                }
	            }
	            target = Utilities_1.getParent(target);
	        }
	    };
	    SelectionZone.prototype._onClick = function (ev) {
	        this._updateModifiers(ev);
	        var target = ev.target;
	        var itemRoot = this._findItemRoot(target);
	        // No-op if selection is disabled
	        if (this._isSelectionDisabled(target)) {
	            return;
	        }
	        while (target !== this.refs.root) {
	            if (this._hasAttribute(target, SELECTALL_TOGGLE_ALL_ATTRIBUTE_NAME)) {
	                this._onToggleAllClick(ev);
	                break;
	            }
	            else if (itemRoot) {
	                var index = this._getItemIndex(itemRoot);
	                if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
	                    if (this._isShiftPressed) {
	                        this._onItemSurfaceClick(ev, index);
	                    }
	                    else {
	                        this._onToggleClick(ev, index);
	                    }
	                    break;
	                }
	                else if (this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
	                    this._onInvokeClick(ev, index);
	                    break;
	                }
	                else if (target === itemRoot) {
	                    this._onItemSurfaceClick(ev, index);
	                    break;
	                }
	            }
	            target = Utilities_1.getParent(target);
	        }
	    };
	    SelectionZone.prototype._onContextMenu = function (ev) {
	        var target = ev.target;
	        var _a = this.props, onItemContextMenu = _a.onItemContextMenu, selection = _a.selection;
	        if (onItemContextMenu) {
	            var itemRoot = this._findItemRoot(target);
	            if (itemRoot) {
	                var index = this._getItemIndex(itemRoot);
	                onItemContextMenu(selection.getItems()[index], index, ev.nativeEvent);
	                ev.preventDefault();
	            }
	        }
	    };
	    SelectionZone.prototype._isSelectionDisabled = function (target) {
	        while (target !== this.refs.root) {
	            if (this._hasAttribute(target, SELECTION_DISABLED_ATTRIBUTE_NAME)) {
	                return true;
	            }
	            target = Utilities_1.getParent(target);
	        }
	        return false;
	    };
	    /**
	     * In multi selection, if you double click within an item's root (but not within the invoke element or input elements),
	     * we should execute the invoke handler.
	     */
	    SelectionZone.prototype._onDoubleClick = function (ev) {
	        var target = ev.target;
	        if (this._isSelectionDisabled(target)) {
	            return;
	        }
	        var _a = this.props, selectionMode = _a.selectionMode, onItemInvoked = _a.onItemInvoked;
	        var itemRoot = this._findItemRoot(target);
	        if (itemRoot && onItemInvoked && selectionMode !== interfaces_1.SelectionMode.none && !this._isInputElement(target)) {
	            var index = this._getItemIndex(itemRoot);
	            while (target !== this.refs.root) {
	                if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME) ||
	                    this._hasAttribute(target, SELECTION_INVOKE_ATTRIBUTE_NAME)) {
	                    break;
	                }
	                else if (target === itemRoot) {
	                    this._onInvokeClick(ev, index);
	                    break;
	                }
	                target = Utilities_1.getParent(target);
	            }
	            target = Utilities_1.getParent(target);
	        }
	    };
	    SelectionZone.prototype._onKeyDown = function (ev) {
	        this._updateModifiers(ev);
	        var target = ev.target;
	        if (this._isSelectionDisabled(target)) {
	            return;
	        }
	        var _a = this.props, selection = _a.selection, selectionMode = _a.selectionMode;
	        var isSelectAllKey = ev.which === Utilities_1.KeyCodes.a && (this._isCtrlPressed || this._isMetaPressed);
	        var isClearSelectionKey = ev.which === Utilities_1.KeyCodes.escape;
	        // Ignore key downs from input elements.
	        if (this._isInputElement(target)) {
	            return;
	        }
	        // If ctrl-a is pressed, select all (if all are not already selected.)
	        if (isSelectAllKey && selectionMode === interfaces_1.SelectionMode.multiple && !selection.isAllSelected()) {
	            selection.setAllSelected(true);
	            ev.stopPropagation();
	            ev.preventDefault();
	            return;
	        }
	        // If escape is pressed, clear selection (if any are selected.)
	        if (isClearSelectionKey && selection.getSelectedCount() > 0) {
	            selection.setAllSelected(false);
	            ev.stopPropagation();
	            ev.preventDefault();
	            return;
	        }
	        var itemRoot = this._findItemRoot(target);
	        // If a key was pressed within an item, we should treat "enters" as invokes and "space" as toggle
	        if (itemRoot) {
	            var index = this._getItemIndex(itemRoot);
	            while (target !== this.refs.root) {
	                if (this._hasAttribute(target, SELECTION_TOGGLE_ATTRIBUTE_NAME)) {
	                    // For toggle elements, assuming they are rendered as buttons, they will generate a click event,
	                    // so we can no-op for any keydowns in this case.
	                    break;
	                }
	                else if (target === itemRoot) {
	                    if (ev.which === Utilities_1.KeyCodes.enter) {
	                        this._onInvokeClick(ev, index);
	                    }
	                    else if (ev.which === Utilities_1.KeyCodes.space) {
	                        this._onToggleClick(ev, index);
	                    }
	                    break;
	                }
	                target = Utilities_1.getParent(target);
	            }
	        }
	    };
	    SelectionZone.prototype._onToggleAllClick = function (ev) {
	        var _a = this.props, selection = _a.selection, selectionMode = _a.selectionMode;
	        if (selectionMode === interfaces_1.SelectionMode.multiple) {
	            selection.toggleAllSelected();
	            ev.stopPropagation();
	            ev.preventDefault();
	        }
	    };
	    SelectionZone.prototype._onToggleClick = function (ev, index) {
	        var _a = this.props, selection = _a.selection, selectionMode = _a.selectionMode;
	        if (selectionMode === interfaces_1.SelectionMode.multiple) {
	            selection.toggleIndexSelected(index);
	        }
	        else if (selectionMode === interfaces_1.SelectionMode.single) {
	            var isSelected = selection.isIndexSelected(index);
	            selection.setChangeEvents(false);
	            selection.setAllSelected(false);
	            selection.setIndexSelected(index, !isSelected, true);
	            selection.setChangeEvents(true);
	        }
	        else {
	            return;
	        }
	        ev.stopPropagation();
	        // NOTE: ev.preventDefault is not called for toggle clicks, because this will kill the browser behavior
	        // for checkboxes if you use a checkbox for the toggle.
	    };
	    SelectionZone.prototype._onInvokeClick = function (ev, index) {
	        var _a = this.props, selection = _a.selection, onItemInvoked = _a.onItemInvoked;
	        if (onItemInvoked) {
	            onItemInvoked(selection.getItems()[index], index, ev.nativeEvent);
	            ev.preventDefault();
	            ev.stopPropagation();
	        }
	    };
	    SelectionZone.prototype._onItemSurfaceClick = function (ev, index) {
	        var _a = this.props, selection = _a.selection, selectionMode = _a.selectionMode;
	        var isToggleModifierPressed = this._isCtrlPressed || this._isMetaPressed;
	        if (selectionMode === interfaces_1.SelectionMode.multiple) {
	            if (this._isShiftPressed) {
	                selection.selectToIndex(index, !isToggleModifierPressed);
	            }
	            else if (isToggleModifierPressed) {
	                selection.toggleIndexSelected(index);
	            }
	            else {
	                this._clearAndSelectIndex(index);
	            }
	        }
	        else if (selectionMode === interfaces_1.SelectionMode.single) {
	            this._clearAndSelectIndex(index);
	        }
	    };
	    SelectionZone.prototype._onInvokeMouseDown = function (ev, index) {
	        var selection = this.props.selection;
	        // Only do work if item is not selected.
	        if (selection.isIndexSelected(index)) {
	            return;
	        }
	        this._clearAndSelectIndex(index);
	    };
	    SelectionZone.prototype._tryClearOnEmptyClick = function (ev) {
	        if (!this.props.selectionPreservedOnEmptyClick &&
	            this._isNonHandledClick(ev.target)) {
	            this.props.selection.setAllSelected(false);
	        }
	    };
	    SelectionZone.prototype._clearAndSelectIndex = function (index) {
	        var selection = this.props.selection;
	        var isAlreadySingleSelected = selection.getSelectedCount() === 1 && selection.isIndexSelected(index);
	        if (!isAlreadySingleSelected) {
	            selection.setChangeEvents(false);
	            selection.setAllSelected(false);
	            selection.setIndexSelected(index, true, true);
	            selection.setChangeEvents(true);
	        }
	    };
	    /**
	     * We need to track the modifier key states so that when focus events occur, which do not contain
	     * modifier states in the Event object, we know how to behave.
	     */
	    SelectionZone.prototype._updateModifiers = function (ev) {
	        this._isShiftPressed = ev.shiftKey;
	        this._isCtrlPressed = ev.ctrlKey;
	        this._isMetaPressed = ev.metaKey;
	    };
	    SelectionZone.prototype._findItemRoot = function (target) {
	        var selection = this.props.selection;
	        while (target !== this.refs.root) {
	            var indexValue = target.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME);
	            var index = Number(indexValue);
	            if (indexValue !== null && index >= 0 && index < selection.getItems().length) {
	                break;
	            }
	            target = Utilities_1.getParent(target);
	        }
	        if (target === this.refs.root) {
	            return undefined;
	        }
	        return target;
	    };
	    SelectionZone.prototype._getItemIndex = function (itemRoot) {
	        return Number(itemRoot.getAttribute(SELECTION_INDEX_ATTRIBUTE_NAME));
	    };
	    SelectionZone.prototype._hasAttribute = function (element, attributeName) {
	        var isToggle = false;
	        while (!isToggle && element !== this.refs.root) {
	            isToggle = element.getAttribute(attributeName) === 'true';
	            element = Utilities_1.getParent(element);
	        }
	        return isToggle;
	    };
	    SelectionZone.prototype._isInputElement = function (element) {
	        return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';
	    };
	    SelectionZone.prototype._isNonHandledClick = function (element) {
	        var doc = Utilities_1.getDocument();
	        if (doc && element) {
	            while (element && element !== doc.documentElement) {
	                if (Utilities_1.isElementTabbable(element)) {
	                    return false;
	                }
	                element = Utilities_1.getParent(element);
	            }
	        }
	        return true;
	    };
	    return SelectionZone;
	}(Utilities_1.BaseComponent));
	SelectionZone.defaultProps = {
	    layout: new SelectionLayout_1.SelectionLayout(interfaces_1.SelectionDirection.vertical),
	    isMultiSelectEnabled: true,
	    isSelectedOnFocus: true,
	    selectionMode: interfaces_1.SelectionMode.multiple
	};
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "ignoreNextFocus", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onFocus", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onMouseDown", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onClick", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onContextMenu", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onDoubleClick", null);
	__decorate([
	    Utilities_1.autobind
	], SelectionZone.prototype, "_onKeyDown", null);
	exports.SelectionZone = SelectionZone;
	


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var DetailsList_Props_1 = __webpack_require__(468);
	var DetailsHeader_1 = __webpack_require__(469);
	var DetailsRow_1 = __webpack_require__(475);
	var FocusZone_1 = __webpack_require__(432);
	var GroupedList_1 = __webpack_require__(481);
	var List_1 = __webpack_require__(493);
	var withViewport_1 = __webpack_require__(497);
	var index_1 = __webpack_require__(462);
	var DragDropHelper_1 = __webpack_require__(499);
	__webpack_require__(500);
	var MIN_COLUMN_WIDTH = 100; // this is the global min width
	var CHECKBOX_WIDTH = 36;
	var GROUP_EXPAND_WIDTH = 36;
	var DEFAULT_INNER_PADDING = 16;
	var DEFAULT_RENDERED_WINDOWS_AHEAD = 2;
	var DEFAULT_RENDERED_WINDOWS_BEHIND = 2;
	var DetailsList = (function (_super) {
	    __extends(DetailsList, _super);
	    function DetailsList(props) {
	        var _this = _super.call(this, props) || this;
	        _this._activeRows = {};
	        _this._columnOverrides = {};
	        _this._onColumnIsSizingChanged = _this._onColumnIsSizingChanged.bind(_this);
	        _this._onColumnResized = _this._onColumnResized.bind(_this);
	        _this._onColumnAutoResized = _this._onColumnAutoResized.bind(_this);
	        _this._onRowDidMount = _this._onRowDidMount.bind(_this);
	        _this._onRowWillUnmount = _this._onRowWillUnmount.bind(_this);
	        _this._onToggleCollapse = _this._onToggleCollapse.bind(_this);
	        _this._onActiveRowChanged = _this._onActiveRowChanged.bind(_this);
	        _this._onHeaderKeyDown = _this._onHeaderKeyDown.bind(_this);
	        _this._onContentKeyDown = _this._onContentKeyDown.bind(_this);
	        _this._onRenderCell = _this._onRenderCell.bind(_this);
	        _this._onGroupExpandStateChanged = _this._onGroupExpandStateChanged.bind(_this);
	        _this.state = {
	            lastWidth: 0,
	            adjustedColumns: _this._getAdjustedColumns(props),
	            layoutMode: props.layoutMode,
	            isSizing: false,
	            isDropping: false,
	            isCollapsed: props.groupProps && props.groupProps.isAllGroupsCollapsed,
	            isSomeGroupExpanded: props.groupProps && !props.groupProps.isAllGroupsCollapsed
	        };
	        _this._events = new Utilities_1.EventGroup(_this);
	        _this._selection = props.selection || new index_1.Selection({ onSelectionChanged: null, getKey: props.getKey });
	        _this._selection.setItems(props.items, false);
	        _this._dragDropHelper = props.dragDropEvents ? new DragDropHelper_1.DragDropHelper({ selection: _this._selection }) : null;
	        _this._initialFocusedIndex = props.initialFocusedIndex;
	        return _this;
	    }
	    DetailsList.prototype.componentWillUnmount = function () {
	        this._events.dispose();
	        if (this._dragDropHelper) {
	            this._dragDropHelper.dispose();
	        }
	    };
	    DetailsList.prototype.componentDidUpdate = function (prevProps, prevState) {
	        if (this.props.onDidUpdate) {
	            this.props.onDidUpdate(this);
	        }
	    };
	    DetailsList.prototype.componentWillReceiveProps = function (newProps) {
	        var _a = this.props, checkboxVisibility = _a.checkboxVisibility, items = _a.items, setKey = _a.setKey, selectionMode = _a.selectionMode, columns = _a.columns, viewport = _a.viewport;
	        var layoutMode = this.state.layoutMode;
	        var shouldResetSelection = (newProps.setKey !== setKey) || newProps.setKey === undefined;
	        var shouldForceUpdates = false;
	        if (newProps.layoutMode !== this.props.layoutMode) {
	            layoutMode = newProps.layoutMode;
	            this.setState({ layoutMode: layoutMode });
	            shouldForceUpdates = true;
	        }
	        if (shouldResetSelection) {
	            this._initialFocusedIndex = newProps.initialFocusedIndex;
	        }
	        if (newProps.items !== items) {
	            this._selection.setItems(newProps.items, shouldResetSelection);
	        }
	        if (newProps.checkboxVisibility !== checkboxVisibility ||
	            newProps.columns !== columns ||
	            newProps.viewport.width !== viewport.width) {
	            shouldForceUpdates = true;
	        }
	        this._adjustColumns(newProps, true, layoutMode);
	        if (newProps.selectionMode !== selectionMode) {
	            shouldForceUpdates = true;
	        }
	        if (shouldForceUpdates) {
	            this._forceListUpdates();
	        }
	    };
	    DetailsList.prototype.render = function () {
	        var _this = this;
	        var _a = this.props, ariaLabelForListHeader = _a.ariaLabelForListHeader, ariaLabelForSelectAllCheckbox = _a.ariaLabelForSelectAllCheckbox, className = _a.className, checkboxVisibility = _a.checkboxVisibility, constrainMode = _a.constrainMode, dragDropEvents = _a.dragDropEvents, groups = _a.groups, groupProps = _a.groupProps, items = _a.items, isHeaderVisible = _a.isHeaderVisible, onItemInvoked = _a.onItemInvoked, onItemContextMenu = _a.onItemContextMenu, onColumnHeaderClick = _a.onColumnHeaderClick, onColumnHeaderContextMenu = _a.onColumnHeaderContextMenu, selectionMode = _a.selectionMode, selectionPreservedOnEmptyClick = _a.selectionPreservedOnEmptyClick, ariaLabel = _a.ariaLabel, ariaLabelForGrid = _a.ariaLabelForGrid, rowElementEventMap = _a.rowElementEventMap, _b = _a.shouldApplyApplicationRole, shouldApplyApplicationRole = _b === void 0 ? false : _b;
	        var _c = this.state, adjustedColumns = _c.adjustedColumns, isCollapsed = _c.isCollapsed, layoutMode = _c.layoutMode, isSizing = _c.isSizing, isSomeGroupExpanded = _c.isSomeGroupExpanded;
	        var _d = this, selection = _d._selection, dragDropHelper = _d._dragDropHelper;
	        var groupNestingDepth = this._getGroupNestingDepth();
	        var additionalListProps = {
	            renderedWindowsAhead: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_AHEAD,
	            renderedWindowsBehind: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_BEHIND
	        };
	        var selectAllVisibility = DetailsHeader_1.SelectAllVisibility.none; // for SelectionMode.none
	        if (selectionMode === index_1.SelectionMode.single) {
	            selectAllVisibility = DetailsHeader_1.SelectAllVisibility.hidden;
	        }
	        if (selectionMode === index_1.SelectionMode.multiple) {
	            // if isCollapsedGroupSelectVisible is false, disable select all when the list has all collapsed groups
	            var isCollapsedGroupSelectVisible = groupProps && groupProps.headerProps && groupProps.headerProps.isCollapsedGroupSelectVisible;
	            if (isCollapsedGroupSelectVisible === undefined) {
	                isCollapsedGroupSelectVisible = true;
	            }
	            var isSelectAllVisible = isCollapsedGroupSelectVisible || !groups || isSomeGroupExpanded;
	            selectAllVisibility = isSelectAllVisible ? DetailsHeader_1.SelectAllVisibility.visible : DetailsHeader_1.SelectAllVisibility.hidden;
	        }
	        if (checkboxVisibility === DetailsList_Props_1.CheckboxVisibility.hidden) {
	            selectAllVisibility = DetailsHeader_1.SelectAllVisibility.none;
	        }
	        return (
	        // If shouldApplyApplicationRole is true, role application will be applied to make arrow keys work
	        // with JAWS.
	        React.createElement("div", { ref: 'root', className: Utilities_1.css('ms-DetailsList', className, {
	                'is-fixed': layoutMode === DetailsList_Props_1.DetailsListLayoutMode.fixedColumns,
	                'is-horizontalConstrained': constrainMode === DetailsList_Props_1.ConstrainMode.horizontalConstrained
	            }), "data-automationid": 'DetailsList', "data-is-scrollable": 'false', "aria-label": ariaLabel, role: shouldApplyApplicationRole ? 'application' : '' },
	            React.createElement("div", { role: 'grid', "aria-label": ariaLabelForGrid },
	                React.createElement("div", { onKeyDown: this._onHeaderKeyDown, role: 'presentation' }, isHeaderVisible && (React.createElement(DetailsHeader_1.DetailsHeader, { ref: 'header', selectionMode: selectionMode, layoutMode: layoutMode, selection: selection, columns: adjustedColumns, onColumnClick: onColumnHeaderClick, onColumnContextMenu: onColumnHeaderContextMenu, onColumnResized: this._onColumnResized, onColumnIsSizingChanged: this._onColumnIsSizingChanged, onColumnAutoResized: this._onColumnAutoResized, groupNestingDepth: groupNestingDepth, isAllCollapsed: isCollapsed, onToggleCollapseAll: this._onToggleCollapse, ariaLabel: ariaLabelForListHeader, ariaLabelForSelectAllCheckbox: ariaLabelForSelectAllCheckbox, selectAllVisibility: selectAllVisibility }))),
	                React.createElement("div", { ref: 'contentContainer', onKeyDown: this._onContentKeyDown, role: 'presentation' },
	                    React.createElement(FocusZone_1.FocusZone, { ref: 'focusZone', direction: FocusZone_1.FocusZoneDirection.vertical, isInnerZoneKeystroke: function (ev) { return (ev.which === Utilities_1.getRTLSafeKeyCode(Utilities_1.KeyCodes.right)); }, onActiveElementChanged: this._onActiveRowChanged },
	                        React.createElement(index_1.SelectionZone, { ref: 'selectionZone', selection: selection, selectionPreservedOnEmptyClick: selectionPreservedOnEmptyClick, selectionMode: selectionMode, onItemInvoked: onItemInvoked, onItemContextMenu: onItemContextMenu }, groups ? (React.createElement(GroupedList_1.GroupedList, { groups: groups, groupProps: groupProps, items: items, onRenderCell: this._onRenderCell, selection: selection, selectionMode: selectionMode, dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: rowElementEventMap, listProps: additionalListProps, onGroupExpandStateChanged: this._onGroupExpandStateChanged, ref: 'groupedList' })) : (React.createElement(List_1.List, __assign({ items: items, onRenderCell: function (item, itemIndex) { return _this._onRenderCell(0, item, itemIndex); } }, additionalListProps, { ref: 'list' })))))))));
	    };
	    DetailsList.prototype.forceUpdate = function () {
	        _super.prototype.forceUpdate.call(this);
	        this._forceListUpdates();
	    };
	    DetailsList.prototype._onRenderRow = function (props) {
	        return React.createElement(DetailsRow_1.DetailsRow, __assign({}, props));
	    };
	    DetailsList.prototype._onRenderCell = function (nestingDepth, item, index) {
	        var _a = this.props, dragDropEvents = _a.dragDropEvents, eventsToRegister = _a.rowElementEventMap, onRenderMissingItem = _a.onRenderMissingItem, onRenderItemColumn = _a.onRenderItemColumn, _b = _a.onRenderRow, onRenderRow = _b === void 0 ? this._onRenderRow : _b, selectionMode = _a.selectionMode, viewport = _a.viewport, checkboxVisibility = _a.checkboxVisibility, getRowAriaLabel = _a.getRowAriaLabel, checkButtonAriaLabel = _a.checkButtonAriaLabel;
	        var selection = this._selection;
	        var dragDropHelper = this._dragDropHelper;
	        var columns = this.state.adjustedColumns;
	        if (!item) {
	            if (onRenderMissingItem) {
	                onRenderMissingItem(index);
	            }
	            return null;
	        }
	        return onRenderRow({
	            item: item,
	            itemIndex: index,
	            columns: columns,
	            groupNestingDepth: nestingDepth,
	            selectionMode: selectionMode,
	            selection: selection,
	            onDidMount: this._onRowDidMount,
	            onWillUnmount: this._onRowWillUnmount,
	            onRenderItemColumn: onRenderItemColumn,
	            eventsToRegister: eventsToRegister,
	            dragDropEvents: dragDropEvents,
	            dragDropHelper: dragDropHelper,
	            viewport: viewport,
	            checkboxVisibility: checkboxVisibility,
	            getRowAriaLabel: getRowAriaLabel,
	            checkButtonAriaLabel: checkButtonAriaLabel
	        }, this._onRenderRow);
	    };
	    DetailsList.prototype._onGroupExpandStateChanged = function (isSomeGroupExpanded) {
	        this.setState({ isSomeGroupExpanded: isSomeGroupExpanded });
	    };
	    DetailsList.prototype._onColumnIsSizingChanged = function (column, isSizing) {
	        this.setState({ isSizing: isSizing });
	    };
	    DetailsList.prototype._onHeaderKeyDown = function (ev) {
	        if (ev.which === Utilities_1.KeyCodes.down) {
	            if (this.refs.focusZone && this.refs.focusZone.focus()) {
	                ev.preventDefault();
	                ev.stopPropagation();
	            }
	        }
	    };
	    DetailsList.prototype._onContentKeyDown = function (ev) {
	        if (ev.which === Utilities_1.KeyCodes.up) {
	            if (this.refs.header && this.refs.header.focus()) {
	                ev.preventDefault();
	                ev.stopPropagation();
	            }
	        }
	    };
	    DetailsList.prototype._getGroupNestingDepth = function () {
	        var groups = this.props.groups;
	        var level = 0;
	        var groupsInLevel = groups;
	        while (groupsInLevel && groupsInLevel.length > 0) {
	            level++;
	            groupsInLevel = groupsInLevel[0].children;
	        }
	        return level;
	    };
	    DetailsList.prototype._onRowDidMount = function (row) {
	        var onRowDidMount = this.props.onRowDidMount;
	        var index = row.props.itemIndex;
	        this._activeRows[index] = row; // this is used for column auto resize
	        // Set focus to the row if it should receive focus.
	        if (this._initialFocusedIndex !== undefined && index === this._initialFocusedIndex) {
	            if (this.refs.selectionZone) {
	                this.refs.selectionZone.ignoreNextFocus();
	            }
	            row.focus();
	            delete this._initialFocusedIndex;
	        }
	        if (onRowDidMount) {
	            onRowDidMount(row.props.item, index);
	        }
	    };
	    DetailsList.prototype._onRowWillUnmount = function (row) {
	        var onRowWillUnmount = this.props.onRowWillUnmount;
	        var index = row.props.itemIndex;
	        delete this._activeRows[index];
	        this._events.off(row.refs.root);
	        if (onRowWillUnmount) {
	            onRowWillUnmount(row.props.item, index);
	        }
	    };
	    DetailsList.prototype._onToggleCollapse = function (collapsed) {
	        this.setState({
	            isCollapsed: collapsed
	        });
	        if (this.refs.groupedList) {
	            this.refs.groupedList.toggleCollapseAll(collapsed);
	        }
	    };
	    DetailsList.prototype._forceListUpdates = function () {
	        if (this.refs.groupedList) {
	            this.refs.groupedList.forceUpdate();
	        }
	        if (this.refs.list) {
	            this.refs.list.forceUpdate();
	        }
	    };
	    DetailsList.prototype._adjustColumns = function (newProps, forceUpdate, layoutMode) {
	        var adjustedColumns = this._getAdjustedColumns(newProps, forceUpdate, layoutMode);
	        var viewportWidth = this.props.viewport.width;
	        if (adjustedColumns) {
	            this.setState({
	                adjustedColumns: adjustedColumns,
	                lastWidth: viewportWidth,
	                layoutMode: layoutMode
	            });
	        }
	    };
	    /** Returns adjusted columns, given the viewport size and layout mode. */
	    DetailsList.prototype._getAdjustedColumns = function (newProps, forceUpdate, layoutMode) {
	        var _this = this;
	        var newColumns = newProps.columns, newItems = newProps.items, viewportWidth = newProps.viewport.width, selectionMode = newProps.selectionMode;
	        if (layoutMode === undefined) {
	            layoutMode = newProps.layoutMode;
	        }
	        var columns = this.props ? this.props.columns : [];
	        var lastWidth = this.state ? this.state.lastWidth : -1;
	        var lastSelectionMode = this.state ? this.state.lastSelectionMode : undefined;
	        if (viewportWidth !== undefined) {
	            if (!forceUpdate &&
	                lastWidth === viewportWidth &&
	                lastSelectionMode === selectionMode &&
	                (!columns || newColumns === columns)) {
	                return;
	            }
	        }
	        else {
	            viewportWidth = this.props.viewport.width;
	        }
	        newColumns = newColumns || buildColumns(newItems, true);
	        var adjustedColumns;
	        if (layoutMode === DetailsList_Props_1.DetailsListLayoutMode.fixedColumns) {
	            adjustedColumns = this._getFixedColumns(newColumns);
	        }
	        else {
	            adjustedColumns = this._getJustifiedColumns(newColumns, viewportWidth);
	        }
	        // Preserve adjusted column calculated widths.
	        adjustedColumns.forEach(function (column) {
	            var overrides = _this._columnOverrides[column.key] = _this._columnOverrides[column.key] || {};
	            overrides.calculatedWidth = column.calculatedWidth;
	        });
	        return adjustedColumns;
	    };
	    /** Builds a set of columns based on the given columns mixed with the current overrides. */
	    DetailsList.prototype._getFixedColumns = function (newColumns) {
	        var _this = this;
	        return newColumns.map(function (column) {
	            var newColumn = Utilities_1.assign({}, column, _this._columnOverrides[column.key]);
	            if (!newColumn.calculatedWidth) {
	                newColumn.calculatedWidth = newColumn.maxWidth || newColumn.minWidth || MIN_COLUMN_WIDTH;
	            }
	            return newColumn;
	        });
	    };
	    /** Builds a set of columns to fix within the viewport width. */
	    DetailsList.prototype._getJustifiedColumns = function (newColumns, viewportWidth) {
	        var _a = this.props, selectionMode = _a.selectionMode, groups = _a.groups;
	        var outerPadding = DEFAULT_INNER_PADDING;
	        var rowCheckWidth = (selectionMode !== index_1.SelectionMode.none) ? CHECKBOX_WIDTH : 0;
	        var groupExpandWidth = groups ? GROUP_EXPAND_WIDTH : 0;
	        var totalWidth = 0; // offset because we have one less inner padding.
	        var availableWidth = viewportWidth - outerPadding - rowCheckWidth - groupExpandWidth;
	        var adjustedColumns = newColumns.map(function (column, i) {
	            var newColumn = Utilities_1.assign({}, column, {
	                calculatedWidth: column.minWidth || MIN_COLUMN_WIDTH
	            });
	            totalWidth += newColumn.calculatedWidth + (i > 0 ? DEFAULT_INNER_PADDING : 0);
	            return newColumn;
	        });
	        var lastIndex = adjustedColumns.length - 1;
	        // Remove collapsable columns.
	        while (lastIndex > 1 && totalWidth > availableWidth) {
	            var column = adjustedColumns[lastIndex];
	            if (column.isCollapsable) {
	                totalWidth -= column.calculatedWidth + DEFAULT_INNER_PADDING;
	                adjustedColumns.splice(lastIndex, 1);
	            }
	            lastIndex--;
	        }
	        // Then expand columns starting at the beginning, until we've filled the width.
	        for (var i = 0; i < adjustedColumns.length && totalWidth < availableWidth; i++) {
	            var column = adjustedColumns[i];
	            var maxWidth = column.maxWidth;
	            var minWidth = column.minWidth || maxWidth || MIN_COLUMN_WIDTH;
	            var spaceLeft = availableWidth - totalWidth;
	            var increment = maxWidth ? Math.min(spaceLeft, maxWidth - minWidth) : spaceLeft;
	            // Add remaining space to the last column.
	            if (i === (adjustedColumns.length - 1)) {
	                increment = spaceLeft;
	            }
	            column.calculatedWidth += increment;
	            totalWidth += increment;
	        }
	        // Mark the last column as not resizable to avoid extra scrolling issues.
	        if (adjustedColumns.length) {
	            adjustedColumns[adjustedColumns.length - 1].isResizable = false;
	        }
	        return adjustedColumns;
	    };
	    DetailsList.prototype._onColumnResized = function (resizingColumn, newWidth) {
	        this._columnOverrides[resizingColumn.key].calculatedWidth = Math.max(resizingColumn.minWidth || MIN_COLUMN_WIDTH, newWidth);
	        this._adjustColumns(this.props, true, DetailsList_Props_1.DetailsListLayoutMode.fixedColumns);
	        this._forceListUpdates();
	    };
	    /**
	     * Callback function when double clicked on the details header column resizer
	     * which will measure the column cells of all the active rows and resize the
	     * column to the max cell width.
	     *
	     * @private
	     * @param {IColumn} column (double clicked column definition)
	     * @param {number} columnIndex (double clicked column index)
	     * @todo min width 100 should be changed to const value and should be consistent with the value used on _onSizerMove method in DetailsHeader
	     */
	    DetailsList.prototype._onColumnAutoResized = function (column, columnIndex) {
	        var _this = this;
	        var max = 0;
	        var count = 0;
	        var totalCount = Object.keys(this._activeRows).length;
	        for (var key in this._activeRows) {
	            if (this._activeRows.hasOwnProperty(key)) {
	                var currentRow = this._activeRows[key];
	                currentRow.measureCell(columnIndex, function (width) {
	                    max = Math.max(max, width);
	                    count++;
	                    if (count === totalCount) {
	                        _this._onColumnResized(column, max);
	                    }
	                });
	            }
	        }
	    };
	    /**
	     * Call back function when an element in FocusZone becomes active. It will transalate it into item
	     * and call onActiveItemChanged callback if specified.
	     *
	     * @private
	     * @param {el} row element that became active in Focus Zone
	     * @param {ev} focus event from Focus Zone
	     */
	    DetailsList.prototype._onActiveRowChanged = function (el, ev) {
	        var _a = this.props, items = _a.items, onActiveItemChanged = _a.onActiveItemChanged;
	        if (!onActiveItemChanged || !el) {
	            return;
	        }
	        var index = Number(el.getAttribute('data-item-index'));
	        if (index >= 0) {
	            onActiveItemChanged(items[index], index, ev);
	        }
	    };
	    ;
	    return DetailsList;
	}(React.Component));
	DetailsList.defaultProps = {
	    layoutMode: DetailsList_Props_1.DetailsListLayoutMode.justified,
	    selectionMode: index_1.SelectionMode.multiple,
	    constrainMode: DetailsList_Props_1.ConstrainMode.horizontalConstrained,
	    checkboxVisibility: DetailsList_Props_1.CheckboxVisibility.onHover,
	    isHeaderVisible: true
	};
	__decorate([
	    Utilities_1.autobind
	], DetailsList.prototype, "_onRenderRow", null);
	DetailsList = __decorate([
	    withViewport_1.withViewport
	], DetailsList);
	exports.DetailsList = DetailsList;
	function buildColumns(items, canResizeColumns, onColumnClick, sortedColumnKey, isSortedDescending, groupedColumnKey, isMultiline) {
	    var columns = [];
	    if (items && items.length) {
	        var firstItem = items[0];
	        var isFirstColumn = true;
	        for (var propName in firstItem) {
	            if (firstItem.hasOwnProperty(propName)) {
	                columns.push({
	                    key: propName,
	                    name: propName,
	                    fieldName: propName,
	                    minWidth: MIN_COLUMN_WIDTH,
	                    maxWidth: 300,
	                    isCollapsable: !!columns.length,
	                    isMultiline: (isMultiline === undefined) ? false : isMultiline,
	                    isSorted: sortedColumnKey === propName,
	                    isSortedDescending: !!isSortedDescending,
	                    isRowHeader: false,
	                    columnActionsMode: DetailsList_Props_1.ColumnActionsMode.clickable,
	                    isResizable: canResizeColumns,
	                    onColumnClick: onColumnClick,
	                    isGrouped: groupedColumnKey === propName
	                });
	                isFirstColumn = false;
	            }
	        }
	    }
	    return columns;
	}
	exports.buildColumns = buildColumns;
	


/***/ },
/* 468 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Enum to describe how a particular column header behaves.... This enum is used to
	 * to specify the property IColumn:columnActionsMode.
	 * If IColumn:columnActionsMode is undefined, then it's equivalent to ColumnActionsMode.clickable
	 */
	var ColumnActionsMode;
	(function (ColumnActionsMode) {
	    /**
	     * Renders the column header as disabled.
	     */
	    ColumnActionsMode[ColumnActionsMode["disabled"] = 0] = "disabled";
	    /**
	     * Renders the column header is clickable.
	     */
	    ColumnActionsMode[ColumnActionsMode["clickable"] = 1] = "clickable";
	    /**
	     * Renders the column header ias clickable and displays the dropdown cheveron.
	     */
	    ColumnActionsMode[ColumnActionsMode["hasDropdown"] = 2] = "hasDropdown";
	})(ColumnActionsMode = exports.ColumnActionsMode || (exports.ColumnActionsMode = {}));
	var ConstrainMode;
	(function (ConstrainMode) {
	    /** If specified, lets the content grow which allows the page to manage scrolling. */
	    ConstrainMode[ConstrainMode["unconstrained"] = 0] = "unconstrained";
	    /**
	     * If specified, constrains the list to the given layout space.
	     */
	    ConstrainMode[ConstrainMode["horizontalConstrained"] = 1] = "horizontalConstrained";
	})(ConstrainMode = exports.ConstrainMode || (exports.ConstrainMode = {}));
	var DetailsListLayoutMode;
	(function (DetailsListLayoutMode) {
	    /**
	     * Lets the user resize columns and makes not attempt to fit them.
	     */
	    DetailsListLayoutMode[DetailsListLayoutMode["fixedColumns"] = 0] = "fixedColumns";
	    /**
	     * Manages which columns are visible, tries to size them according to their min/max rules and drops
	     * off columns that can't fit and have isCollapsable set.
	     */
	    DetailsListLayoutMode[DetailsListLayoutMode["justified"] = 1] = "justified";
	})(DetailsListLayoutMode = exports.DetailsListLayoutMode || (exports.DetailsListLayoutMode = {}));
	var CheckboxVisibility;
	(function (CheckboxVisibility) {
	    /**
	     * Visible on hover.
	     */
	    CheckboxVisibility[CheckboxVisibility["onHover"] = 0] = "onHover";
	    /**
	     * Visible always.
	     */
	    CheckboxVisibility[CheckboxVisibility["always"] = 1] = "always";
	    /**
	     * Hide checkboxes.
	     */
	    CheckboxVisibility[CheckboxVisibility["hidden"] = 2] = "hidden";
	})(CheckboxVisibility = exports.CheckboxVisibility || (exports.CheckboxVisibility = {}));
	


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var DetailsList_Props_1 = __webpack_require__(468);
	var FocusZone_1 = __webpack_require__(432);
	var Check_1 = __webpack_require__(470);
	var GroupSpacer_1 = __webpack_require__(472);
	var interfaces_1 = __webpack_require__(463);
	__webpack_require__(474);
	var MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button
	var MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button
	var INNER_PADDING = 16;
	var SelectAllVisibility;
	(function (SelectAllVisibility) {
	    SelectAllVisibility[SelectAllVisibility["none"] = 0] = "none";
	    SelectAllVisibility[SelectAllVisibility["hidden"] = 1] = "hidden";
	    SelectAllVisibility[SelectAllVisibility["visible"] = 2] = "visible";
	})(SelectAllVisibility = exports.SelectAllVisibility || (exports.SelectAllVisibility = {}));
	var DetailsHeader = (function (_super) {
	    __extends(DetailsHeader, _super);
	    function DetailsHeader(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            columnResizeDetails: null,
	            groupNestingDepth: _this.props.groupNestingDepth,
	            isAllCollapsed: _this.props.isAllCollapsed
	        };
	        _this._onToggleCollapseAll = _this._onToggleCollapseAll.bind(_this);
	        _this._onSelectAllClicked = _this._onSelectAllClicked.bind(_this);
	        return _this;
	    }
	    DetailsHeader.prototype.componentDidMount = function () {
	        var selection = this.props.selection;
	        this._events.on(selection, interfaces_1.SELECTION_CHANGE, this._onSelectionChanged);
	        this._events.on(this.refs.root, 'mousedown', this._onSizerDown);
	    };
	    DetailsHeader.prototype.componentWillReceiveProps = function (newProps) {
	        var groupNestingDepth = this.state.groupNestingDepth;
	        if (newProps.groupNestingDepth !== groupNestingDepth) {
	            this.setState({ groupNestingDepth: newProps.groupNestingDepth });
	        }
	    };
	    DetailsHeader.prototype.render = function () {
	        var _this = this;
	        var _a = this.props, columns = _a.columns, ariaLabel = _a.ariaLabel, ariaLabelForSelectAllCheckbox = _a.ariaLabelForSelectAllCheckbox, selectAllVisibility = _a.selectAllVisibility;
	        var _b = this.state, isAllSelected = _b.isAllSelected, columnResizeDetails = _b.columnResizeDetails, isSizing = _b.isSizing, groupNestingDepth = _b.groupNestingDepth, isAllCollapsed = _b.isAllCollapsed;
	        return (React.createElement("div", { role: 'row', "aria-label": ariaLabel, className: Utilities_1.css('ms-DetailsHeader', {
	                'is-allSelected': isAllSelected,
	                'is-selectAllHidden': selectAllVisibility === SelectAllVisibility.hidden,
	                'is-resizingColumn': !!columnResizeDetails && isSizing
	            }), onMouseMove: this._onMove.bind(this), onMouseUp: this._onUp.bind(this), ref: 'root', "data-automationid": 'DetailsHeader' },
	            React.createElement(FocusZone_1.FocusZone, { ref: 'focusZone', direction: FocusZone_1.FocusZoneDirection.horizontal },
	                React.createElement("div", { className: 'ms-DetailsHeader-cellWrapper', role: 'columnheader' }, (selectAllVisibility === SelectAllVisibility.visible) ? (React.createElement("button", { className: 'ms-DetailsHeader-cell is-check', onClick: this._onSelectAllClicked, "aria-label": ariaLabelForSelectAllCheckbox, "aria-pressed": isAllSelected },
	                    React.createElement(Check_1.Check, { checked: isAllSelected }))) : null),
	                groupNestingDepth > 0 ? (React.createElement("button", { className: 'ms-DetailsHeader-cell', onClick: this._onToggleCollapseAll },
	                    React.createElement("i", { className: Utilities_1.css('ms-DetailsHeader-collapseButton ms-Icon ms-Icon--ChevronDown', {
	                            'is-collapsed': isAllCollapsed
	                        }) }))) : (null),
	                GroupSpacer_1.GroupSpacer({ count: groupNestingDepth - 1 }),
	                columns.map(function (column, columnIndex) { return (React.createElement("div", { key: column.key, className: 'ms-DetailsHeader-cellSizeWrapper' },
	                    React.createElement("div", { className: 'ms-DetailsHeader-cellWrapper', role: 'columnheader' },
	                        React.createElement("button", { key: column.fieldName, disabled: column.columnActionsMode === DetailsList_Props_1.ColumnActionsMode.disabled, className: Utilities_1.css('ms-DetailsHeader-cell', column.headerClassName, {
	                                'is-actionable': column.columnActionsMode !== DetailsList_Props_1.ColumnActionsMode.disabled,
	                                'is-empty': !column.name,
	                                'is-icon-visible': column.isSorted || column.isGrouped || column.isFiltered
	                            }), style: { width: column.calculatedWidth + INNER_PADDING }, onClick: _this._onColumnClick.bind(_this, column), onContextMenu: _this._onColumnContextMenu.bind(_this, column), "aria-haspopup": column.columnActionsMode === DetailsList_Props_1.ColumnActionsMode.hasDropdown, "aria-label": column.ariaLabel || column.name, "aria-sort": column.isSorted ? (column.isSortedDescending ? 'descending' : 'ascending') : 'none', "data-automationid": 'ColumnsHeaderColumn', "data-item-key": column.key },
	                            column.isFiltered && (React.createElement("i", { className: 'ms-Icon ms-Icon--filter' })),
	                            column.isSorted && (React.createElement("i", { className: Utilities_1.css('ms-Icon', {
	                                    'ms-Icon--SortUp': !column.isSortedDescending,
	                                    'ms-Icon--SortDown': column.isSortedDescending
	                                }) })),
	                            column.isGrouped && (React.createElement("i", { className: 'ms-Icon ms-Icon--GroupedDescending' })),
	                            column.iconClassName && (React.createElement("i", { className: 'ms-Icon ' + column.iconClassName })),
	                            column.name,
	                            column.columnActionsMode === DetailsList_Props_1.ColumnActionsMode.hasDropdown && (React.createElement("i", { className: 'ms-DetailsHeader-filterChevron ms-Icon ms-Icon--ChevronDown' })))),
	                    (column.isResizable) ? (React.createElement("div", { "data-sizer-index": columnIndex, className: Utilities_1.css('ms-DetailsHeader-cell is-sizer', {
	                            'is-resizing': columnResizeDetails && columnResizeDetails.columnIndex === columnIndex && isSizing
	                        }), onDoubleClick: _this._onSizerDoubleClick.bind(_this, columnIndex) })) : (null))); }))));
	    };
	    /** Set focus to the active thing in the focus area. */
	    DetailsHeader.prototype.focus = function () {
	        return this.refs.focusZone.focus();
	    };
	    /**
	     * double click on the column sizer will auto ajust column width
	     * to fit the longest content among current rendered rows.
	     *
	     * @private
	     * @param {number} columnIndex (index of the column user double clicked)
	     * @param {React.MouseEvent} ev (mouse double click event)
	     */
	    DetailsHeader.prototype._onSizerDoubleClick = function (columnIndex, ev) {
	        var _a = this.props, onColumnAutoResized = _a.onColumnAutoResized, columns = _a.columns;
	        if (onColumnAutoResized) {
	            onColumnAutoResized(columns[columnIndex], columnIndex);
	        }
	    };
	    /**
	     * Called when the select all toggle is clicked.
	     */
	    DetailsHeader.prototype._onSelectAllClicked = function () {
	        var selection = this.props.selection;
	        selection.toggleAllSelected();
	    };
	    /**
	     * mouse move event handler in the header
	     * it will set isSizing state to true when user clicked on the sizer and move the mouse.
	     *
	     * @private
	     * @param {React.MouseEvent} ev (mouse move event)
	     */
	    DetailsHeader.prototype._onMove = function (ev) {
	        var 
	        // use buttons property here since ev.button in some edge case is not upding well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        _a = ev.buttons, 
	        // use buttons property here since ev.button in some edge case is not upding well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;
	        var _b = this.props, onColumnIsSizingChanged = _b.onColumnIsSizingChanged, columns = _b.columns;
	        var _c = this.state, columnResizeDetails = _c.columnResizeDetails, isSizing = _c.isSizing;
	        if (columnResizeDetails) {
	            if (buttons !== MOUSEMOVE_PRIMARY_BUTTON) {
	                // cancel mouse down event and return early when the primary button is not pressed
	                this._onUp(ev);
	                return;
	            }
	            if (!isSizing && ev.clientX !== columnResizeDetails.originX) {
	                isSizing = true;
	                this._events.on(window, 'mousemove', this._onSizerMove, true);
	                this._events.on(window, 'mouseup', this._onSizerUp, true);
	                this.setState({ isSizing: isSizing });
	                if (onColumnIsSizingChanged) {
	                    onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], true);
	                }
	            }
	        }
	    };
	    /**
	     * mouse up event handler in the header
	     * clear the resize related state.
	     * This is to ensure we can catch double click event
	     *
	     * @private
	     * @param {React.MouseEvent} ev (mouse up event)
	     */
	    DetailsHeader.prototype._onUp = function (ev) {
	        this.setState({
	            columnResizeDetails: null,
	            isSizing: false
	        });
	    };
	    DetailsHeader.prototype._onSizerDown = function (ev) {
	        var columnIndexAttr = ev.target.getAttribute('data-sizer-index');
	        var columnIndex = Number(columnIndexAttr);
	        var columns = this.props.columns;
	        if (columnIndexAttr === null || ev.button !== MOUSEDOWN_PRIMARY_BUTTON) {
	            // Ignore anything except the primary button.
	            return;
	        }
	        this.setState({
	            columnResizeDetails: {
	                columnIndex: columnIndex,
	                columnMinWidth: columns[columnIndex].calculatedWidth,
	                originX: ev.clientX
	            }
	        });
	        ev.preventDefault();
	        ev.stopPropagation();
	    };
	    DetailsHeader.prototype._onSelectionChanged = function () {
	        var isAllSelected = this.props.selection.isAllSelected();
	        if (this.state.isAllSelected !== isAllSelected) {
	            this.setState({
	                isAllSelected: isAllSelected
	            });
	        }
	    };
	    DetailsHeader.prototype._onSizerMove = function (ev) {
	        var 
	        // use buttons property here since ev.button in some edge case is not upding well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        _a = ev.buttons, 
	        // use buttons property here since ev.button in some edge case is not upding well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;
	        var columnResizeDetails = this.state.columnResizeDetails;
	        if (columnResizeDetails) {
	            if (buttons !== MOUSEMOVE_PRIMARY_BUTTON) {
	                // cancel mouse down event and return early when the primary button is not pressed
	                this._onSizerUp();
	                return;
	            }
	            var _b = this.props, onColumnResized = _b.onColumnResized, columns = _b.columns;
	            if (onColumnResized) {
	                var movement = ev.clientX - columnResizeDetails.originX;
	                if (Utilities_1.getRTL()) {
	                    movement = -movement;
	                }
	                onColumnResized(columns[columnResizeDetails.columnIndex], columnResizeDetails.columnMinWidth + movement);
	            }
	        }
	    };
	    DetailsHeader.prototype._onSizerUp = function () {
	        var _a = this.props, columns = _a.columns, onColumnIsSizingChanged = _a.onColumnIsSizingChanged;
	        var columnResizeDetails = this.state.columnResizeDetails;
	        this._events.off(window);
	        this.setState({
	            columnResizeDetails: null,
	            isSizing: false
	        });
	        if (onColumnIsSizingChanged) {
	            onColumnIsSizingChanged(columns[columnResizeDetails.columnIndex], false);
	        }
	    };
	    DetailsHeader.prototype._onColumnClick = function (column, ev) {
	        var onColumnClick = this.props.onColumnClick;
	        if (column.onColumnClick) {
	            column.onColumnClick(ev, column);
	        }
	        if (onColumnClick) {
	            onColumnClick(ev, column);
	        }
	    };
	    DetailsHeader.prototype._onColumnContextMenu = function (column, ev) {
	        var onColumnContextMenu = this.props.onColumnContextMenu;
	        if (column.onContextMenu) {
	            column.onColumnContextMenu(column, ev);
	        }
	        if (onColumnContextMenu) {
	            onColumnContextMenu(column, ev);
	        }
	    };
	    DetailsHeader.prototype._onToggleCollapseAll = function () {
	        var onToggleCollapseAll = this.props.onToggleCollapseAll;
	        var newCollapsed = !this.state.isAllCollapsed;
	        this.setState({
	            isAllCollapsed: newCollapsed
	        });
	        if (onToggleCollapseAll) {
	            onToggleCollapseAll(newCollapsed);
	        }
	    };
	    return DetailsHeader;
	}(Utilities_1.BaseComponent));
	DetailsHeader.defaultProps = {
	    isSelectAllVisible: SelectAllVisibility.visible
	};
	exports.DetailsHeader = DetailsHeader;
	


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	__webpack_require__(471);
	var Check = (function (_super) {
	    __extends(Check, _super);
	    function Check() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Check.prototype.shouldComponentUpdate = function (newProps) {
	        return this.props.isChecked !== newProps.isChecked || this.props.checked !== newProps.checked;
	    };
	    Check.prototype.render = function () {
	        var _a = this.props, isChecked = _a.isChecked, checked = _a.checked;
	        return (React.createElement("div", { className: Utilities_1.css('ms-Check', {
	                'is-checked': isChecked || checked
	            }) },
	            React.createElement("div", { className: 'ms-Icon ms-Check-background' }),
	            React.createElement("i", { className: 'ms-Check-check ms-Icon ms-Icon--CheckMark' })));
	    };
	    return Check;
	}(React.Component));
	Check.defaultProps = {
	    isChecked: false
	};
	exports.Check = Check;
	


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Check{line-height:1;width:24px;height:24px;vertical-align:top;position:relative;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ms-Check.is-checked .ms-Check-background:before{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Check.is-checked .ms-Check-background:after{color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Check.is-checked .ms-Check-check{opacity:1;color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": ";font-weight:900;font-size:12px}.ms-Check:hover .ms-Check-check{opacity:1}.ms-Check-check{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": ";opacity:0}.ms-Check-background{position:relative;height:24px;width:24px}.ms-Check-background:before{content:'\\E91F';color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}.ms-Check-background:after{content:'\\EA3A';color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": "}.ms-Check-background:after,.ms-Check-background:before{left:50%;top:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:24px;height:24px;width:24px;position:absolute}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-unused-variable */
	var React = __webpack_require__(386);
	/* tslint:enable:no-unused-variable */
	__webpack_require__(473);
	var SPACER_WIDTH = 36;
	exports.GroupSpacer = function (props) {
	    return props.count > 0 && React.createElement("span", { className: 'ms-GroupSpacer', style: { width: props.count * SPACER_WIDTH } });
	};
	


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-GroupSpacer{display:inline-block}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-DetailsHeader{display:inline-block;min-width:100%;height:36px;line-height:36px;white-space:nowrap;padding-bottom:1px;border-bottom:1px solid " }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": ";cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html[dir=ltr] .ms-DetailsHeader.is-selectAllHidden{padding-left:36px}html[dir=rtl] .ms-DetailsHeader.is-selectAllHidden{padding-right:36px}.ms-DetailsHeader-cell.is-check .ms-Check-background{opacity:0}.ms-DetailsHeader-cell.is-check:hover .ms-Check-background,.ms-DetailsHeader.is-allSelected .ms-Check-background{opacity:1}.ms-DetailsHeader-cellWrapper{display:inline-block;position:relative}.ms-DetailsHeader-cellSizeWrapper{display:inline-block;vertical-align:top}.ms-DetailsHeader-cell{color:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": ";font-weight:400;position:relative;display:inline-block;box-sizing:border-box;padding:0 8px;border:none;line-height:inherit;margin:0;height:36px;vertical-align:top;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.ms-DetailsHeader-cell::-moz-focus-inner{border:0}.ms-DetailsHeader-cell{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-DetailsHeader-cell:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}html[dir=ltr] .ms-DetailsHeader-cell{text-align:left}html[dir=rtl] .ms-DetailsHeader-cell{text-align:right}html[dir=ltr] .ms-DetailsHeader-cell{text-align:left}html[dir=rtl] .ms-DetailsHeader-cell{text-align:right}.ms-DetailsHeader-cell.is-check{position:relative;padding:6px;margin:0}.ms-DetailsHeader-cell.is-actionable{color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-DetailsHeader-cell.is-actionable:hover{color:" }, { "theme": "neutralPrimary", "defaultValue": "#333333" }, { "rawString": ";background:" }, { "theme": "neutralLighterAlt", "defaultValue": "#f8f8f8" }, { "rawString": "}.ms-DetailsHeader-cell.is-actionable:active{background:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": "}.ms-DetailsHeader-cell.is-sizer{position:absolute;width:16px;cursor:ew-resize;bottom:0;top:0;height:inherit;background:0 0}html[dir=ltr] .ms-DetailsHeader-cell.is-sizer{margin-left:-10px}html[dir=rtl] .ms-DetailsHeader-cell.is-sizer{margin-right:-10px}.ms-DetailsHeader-cell.is-empty{text-overflow:clip}.ms-DetailsHeader-cell.is-sizer:after{content:'';position:absolute;left:50%;top:0;bottom:0;width:1px;background:" }, { "theme": "neutralTertiaryAlt", "defaultValue": "#c8c8c8" }, { "rawString": ";opacity:0}.ms-DetailsHeader-cell.is-sizer.is-resizing:after,.ms-DetailsHeader-cell.is-sizer:hover:after{opacity:1;-webkit-transition:opacity .3s linear;transition:opacity .3s linear}.ms-DetailsHeader-collapseButton{text-align:center;-webkit-transform:rotate(-180deg);transform:rotate(-180deg);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transition:-webkit-transform .1s linear;transition:-webkit-transform .1s linear;transition:transform .1s linear;transition:transform .1s linear,-webkit-transform .1s linear;width:20px;outline:0}.ms-DetailsHeader-collapseButton.is-collapsed{-webkit-transform:rotate(0);transform:rotate(0)}.ms-DetailsHeader-isSortedDescending{-webkit-transform:rotate(-180deg);transform:rotate(-180deg);-webkit-transform-origin:50% 50%;transform-origin:50% 50%}.ms-DetailsHeader-cell .ms-Icon{color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": ";opacity:1}.ms-DetailsHeader-cell .ms-DetailsHeader-filterChevron.ms-Icon{color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": ";vertical-align:middle}html[dir=ltr] .ms-DetailsHeader-cell .ms-DetailsHeader-filterChevron.ms-Icon{padding-left:4px}html[dir=rtl] .ms-DetailsHeader-cell .ms-DetailsHeader-filterChevron.ms-Icon{padding-right:4px}html[dir=ltr] .ms-DetailsHeader-cell .ms-DetailsHeader-collapseButton.ms-Icon{padding-right:0}html[dir=rtl] .ms-DetailsHeader-cell .ms-DetailsHeader-collapseButton.ms-Icon{padding-left:0}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var DetailsList_Props_1 = __webpack_require__(468);
	var DetailsRowCheck_1 = __webpack_require__(476);
	var GroupSpacer_1 = __webpack_require__(472);
	var DetailsRowFields_1 = __webpack_require__(479);
	var FocusZone_1 = __webpack_require__(432);
	var interfaces_1 = __webpack_require__(463);
	__webpack_require__(480);
	var DEFAULT_DROPPING_CSS_CLASS = 'is-dropping';
	var DetailsRow = (function (_super) {
	    __extends(DetailsRow, _super);
	    function DetailsRow(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            selectionState: _this._getSelectionState(props),
	            columnMeasureInfo: null,
	            isDropping: false,
	            groupNestingDepth: props.groupNestingDepth
	        };
	        _this._hasSetFocus = false;
	        _this._events = new Utilities_1.EventGroup(_this);
	        _this._droppingClassNames = '';
	        _this._updateDroppingState = _this._updateDroppingState.bind(_this);
	        return _this;
	    }
	    DetailsRow.prototype.componentDidMount = function () {
	        var dragDropHelper = this.props.dragDropHelper;
	        if (dragDropHelper) {
	            dragDropHelper.subscribe(this.refs.root, this._events, this._getRowDragDropOptions());
	        }
	        this._events.on(this.props.selection, interfaces_1.SELECTION_CHANGE, this._onSelectionChanged);
	        if (this.props.onDidMount && this.props.item) {
	            // If the item appears later, we should wait for it before calling this method.
	            this._hasMounted = true;
	            this.props.onDidMount(this);
	        }
	    };
	    DetailsRow.prototype.componentDidUpdate = function () {
	        var state = this.state;
	        var _a = this.props, item = _a.item, onDidMount = _a.onDidMount;
	        var columnMeasureInfo = state.columnMeasureInfo;
	        if (columnMeasureInfo && columnMeasureInfo.index >= 0) {
	            var newWidth = this.refs.cellMeasurer.getBoundingClientRect().width;
	            columnMeasureInfo.onMeasureDone(newWidth);
	            this.setState({
	                columnMeasureInfo: null
	            });
	        }
	        if (item && onDidMount && !this._hasMounted) {
	            this._hasMounted = true;
	            onDidMount(this);
	        }
	    };
	    DetailsRow.prototype.componentWillUnmount = function () {
	        var _a = this.props, item = _a.item, onWillUnmount = _a.onWillUnmount, dragDropHelper = _a.dragDropHelper;
	        this._events.dispose();
	        // Only call the onWillUnmount callback if we have an item.
	        if (onWillUnmount && item) {
	            onWillUnmount(this);
	        }
	        if (dragDropHelper) {
	            dragDropHelper.unsubscribe(this.refs.root, this._dragDropKey);
	        }
	    };
	    DetailsRow.prototype.componentWillReceiveProps = function (newProps) {
	        this.setState({
	            selectionState: this._getSelectionState(newProps),
	            groupNestingDepth: newProps.groupNestingDepth
	        });
	    };
	    DetailsRow.prototype.render = function () {
	        var _a = this.props, columns = _a.columns, dragDropEvents = _a.dragDropEvents, item = _a.item, itemIndex = _a.itemIndex, _b = _a.onRenderCheck, onRenderCheck = _b === void 0 ? this._onRenderCheck : _b, onRenderItemColumn = _a.onRenderItemColumn, selectionMode = _a.selectionMode, viewport = _a.viewport, checkboxVisibility = _a.checkboxVisibility, getRowAriaLabel = _a.getRowAriaLabel, checkButtonAriaLabel = _a.checkButtonAriaLabel, selection = _a.selection;
	        var _c = this.state, _d = _c.selectionState, isSelected = _d.isSelected, anySelected = _d.anySelected, columnMeasureInfo = _c.columnMeasureInfo, isDropping = _c.isDropping, groupNestingDepth = _c.groupNestingDepth;
	        var isDraggable = Boolean(dragDropEvents && dragDropEvents.canDrag && dragDropEvents.canDrag(item));
	        var droppingClassName = isDropping ? (this._droppingClassNames ? this._droppingClassNames : DEFAULT_DROPPING_CSS_CLASS) : '';
	        var ariaLabel = getRowAriaLabel ? getRowAriaLabel(item) : null;
	        var canSelect = selection.canSelectItem(item);
	        var isContentUnselectable = selectionMode === interfaces_1.SelectionMode.multiple;
	        return (React.createElement("div", { ref: 'root', role: 'row', "aria-label": ariaLabel, className: Utilities_1.css('ms-DetailsRow ms-u-fadeIn400', droppingClassName, {
	                'is-contentUnselectable': isContentUnselectable,
	                'is-selected': isSelected,
	                'is-check-visible': checkboxVisibility === DetailsList_Props_1.CheckboxVisibility.always
	            }), "data-is-focusable": true, "data-selection-index": itemIndex, "data-item-index": itemIndex, "data-is-draggable": isDraggable, "data-automationid": 'DetailsRow', style: { minWidth: viewport ? viewport.width : 0 }, "aria-selected": isSelected },
	            React.createElement(FocusZone_1.FocusZone, { direction: FocusZone_1.FocusZoneDirection.horizontal },
	                (selectionMode !== interfaces_1.SelectionMode.none && checkboxVisibility !== DetailsList_Props_1.CheckboxVisibility.hidden) && (React.createElement("span", { role: 'gridcell' }, onRenderCheck({
	                    isSelected: isSelected,
	                    anySelected: anySelected,
	                    ariaLabel: checkButtonAriaLabel,
	                    canSelect: canSelect
	                }))),
	                GroupSpacer_1.GroupSpacer({ count: groupNestingDepth }),
	                item && (React.createElement(DetailsRowFields_1.DetailsRowFields, { columns: columns, item: item, itemIndex: itemIndex, onRenderItemColumn: onRenderItemColumn })),
	                columnMeasureInfo && (React.createElement("span", { className: 'ms-DetailsRow-cellMeasurer ms-DetailsRow-cell', ref: 'cellMeasurer' },
	                    React.createElement(DetailsRowFields_1.DetailsRowFields, { columns: [columnMeasureInfo.column], item: item, itemIndex: itemIndex, onRenderItemColumn: onRenderItemColumn }))))));
	    };
	    /**
	     * measure cell at index. and call the call back with the measured cell width when finish measure
	     *
	     * @param {number} index (the cell index)
	     * @param {(width: number) => void} onMeasureDone (the call back function when finish measure)
	     */
	    DetailsRow.prototype.measureCell = function (index, onMeasureDone) {
	        var column = Utilities_1.assign({}, this.props.columns[index]);
	        column.minWidth = 0;
	        column.maxWidth = 999999;
	        delete column.calculatedWidth;
	        this.setState({
	            columnMeasureInfo: {
	                index: index,
	                column: column,
	                onMeasureDone: onMeasureDone
	            }
	        });
	    };
	    DetailsRow.prototype.focus = function () {
	        if (this.refs && this.refs.root) {
	            this.refs.root.tabIndex = 0;
	            this.refs.root.focus();
	        }
	    };
	    DetailsRow.prototype._onRenderCheck = function (props) {
	        return React.createElement(DetailsRowCheck_1.DetailsRowCheck, __assign({}, props));
	    };
	    DetailsRow.prototype._getSelectionState = function (props) {
	        var itemIndex = props.itemIndex, selection = props.selection;
	        return {
	            isSelected: selection.isIndexSelected(itemIndex),
	            anySelected: selection.getSelectedCount() > 0
	        };
	    };
	    DetailsRow.prototype._onSelectionChanged = function () {
	        var selectionState = this._getSelectionState(this.props);
	        if (!Utilities_1.shallowCompare(selectionState, this.state.selectionState)) {
	            this.setState({
	                selectionState: selectionState
	            });
	        }
	    };
	    DetailsRow.prototype._getRowDragDropOptions = function () {
	        var _a = this.props, item = _a.item, itemIndex = _a.itemIndex, dragDropEvents = _a.dragDropEvents, eventsToRegister = _a.eventsToRegister;
	        this._dragDropKey = 'row-' + itemIndex;
	        var options = {
	            key: this._dragDropKey,
	            eventMap: eventsToRegister,
	            selectionIndex: itemIndex,
	            context: { data: item, index: itemIndex },
	            canDrag: dragDropEvents.canDrag,
	            canDrop: dragDropEvents.canDrop,
	            onDragStart: dragDropEvents.onDragStart,
	            updateDropState: this._updateDroppingState
	        };
	        return options;
	    };
	    /**
	     * update isDropping state based on the input value, which is used to change style during drag and drop
	     *
	     * when change to true, that means drag enter. we will add default dropping class name
	     * or the custom dropping class name (return result from onDragEnter) to the root elemet.
	     *
	     * when change to false, that means drag leave. we will remove the dropping class name from root element.
	     *
	     * @private
	     * @param {boolean} newValue (new isDropping state value)
	     * @param {DragEvent} event (the event trigger dropping state change which can be dragenter, dragleave etc)
	     */
	    DetailsRow.prototype._updateDroppingState = function (newValue, event) {
	        var _a = this.state, selectionState = _a.selectionState, isDropping = _a.isDropping;
	        var _b = this.props, dragDropEvents = _b.dragDropEvents, item = _b.item;
	        if (!newValue) {
	            if (dragDropEvents.onDragLeave) {
	                dragDropEvents.onDragLeave(item, event);
	            }
	        }
	        else {
	            if (dragDropEvents.onDragEnter) {
	                this._droppingClassNames = dragDropEvents.onDragEnter(item, event);
	            }
	        }
	        if (isDropping !== newValue) {
	            this.setState({ selectionState: selectionState, isDropping: newValue });
	        }
	    };
	    return DetailsRow;
	}(React.Component));
	exports.DetailsRow = DetailsRow;
	


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-unused-variable */
	var React = __webpack_require__(386);
	/* tslint:enable:no-unused-variable */
	var Check_1 = __webpack_require__(477);
	exports.DetailsRowCheck = function (props) {
	    var selected = props.isSelected || props.selected;
	    return (React.createElement("button", { type: 'button', className: 'ms-DetailsRow-check', role: 'button', "aria-pressed": selected, "data-selection-toggle": true, "data-automationid": 'DetailsRowCheck', "aria-label": props.ariaLabel }, props.canSelect ?
	        React.createElement(Check_1.Check, { checked: selected }) :
	        React.createElement("div", { className: 'ms-DetailsRow-checkSpacer' })));
	};
	


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(478));
	


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(470));
	


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var DetailsRowFields = (function (_super) {
	    __extends(DetailsRowFields, _super);
	    function DetailsRowFields(props) {
	        var _this = _super.call(this) || this;
	        _this.state = _this._getState(props);
	        return _this;
	    }
	    DetailsRowFields.prototype.componentWillReceiveProps = function (newProps) {
	        this.setState(this._getState(newProps));
	    };
	    DetailsRowFields.prototype.render = function () {
	        var columns = this.props.columns;
	        var cellContent = this.state.cellContent;
	        return (React.createElement("div", { className: 'ms-DetailsRow-fields', "data-automationid": 'DetailsRowFields' }, columns.map(function (column, columnIndex) { return (React.createElement("div", { key: columnIndex, role: column.isRowHeader ? 'rowheader' : 'gridcell', className: Utilities_1.css('ms-DetailsRow-cell', column.className, {
	                'is-multiline': column.isMultiline
	            }), style: { width: column.calculatedWidth }, "data-automationid": 'DetailsRowCell', "data-automation-key": column.key }, cellContent[columnIndex])); })));
	    };
	    DetailsRowFields.prototype._getState = function (props) {
	        var _this = this;
	        var item = props.item, itemIndex = props.itemIndex, onRenderItemColumn = props.onRenderItemColumn;
	        return {
	            cellContent: props.columns.map(function (column) {
	                var cellContent;
	                try {
	                    var render = column.onRender || onRenderItemColumn;
	                    cellContent = render ? render(item, itemIndex, column) : _this._getCellText(item, column);
	                }
	                catch (e) { }
	                return cellContent;
	            })
	        };
	    };
	    DetailsRowFields.prototype._getCellText = function (item, column) {
	        var value = (item && column && column.fieldName) ? item[column.fieldName] : '';
	        if (value === null || value === undefined) {
	            value = '';
	        }
	        return value;
	    };
	    return DetailsRowFields;
	}(React.Component));
	exports.DetailsRowFields = DetailsRowFields;
	


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-DetailsRow{display:inline-block;min-width:100%;min-height:36px;margin:1px 0;vertical-align:top;white-space:nowrap;padding:0;box-sizing:border-box;background:0 0;border:none;vertical-align:top;line-height:16px}.ms-DetailsRow::-moz-focus-inner{border:0}.ms-DetailsRow{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-DetailsRow:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}html[dir=ltr] .ms-DetailsRow{text-align:left}html[dir=rtl] .ms-DetailsRow{text-align:right}.ms-DetailsRow.ms-DetailsRow.is-selected{background:" }, { "theme": "neutralQuaternary", "defaultValue": "#d0d0d0" }, { "rawString": "}.ms-DetailsRow.is-contentUnselectable{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.ms-DetailsRow:hover{background:" }, { "theme": "neutralLighter", "defaultValue": "#f4f4f4" }, { "rawString": "}.ms-DetailsRow.is-selected:hover{background:" }, { "theme": "neutralQuaternaryAlt", "defaultValue": "#dadada" }, { "rawString": "}.ms-DetailsRow-cell{display:inline-block;position:relative;box-sizing:border-box;padding:10px 0;margin:0 8px;min-height:36px;vertical-align:top;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ms-DetailsRow-cell.is-multiline{white-space:normal;word-break:break-word;text-overflow:clip}.ms-DetailsRow-fields{display:inline-block}.ms-DetailsRow-check{display:inline-block;cursor:default;padding:6px;box-sizing:border-box;vertical-align:top;background:0 0;border:none}.ms-DetailsRow-check::-moz-focus-inner{border:0}.ms-DetailsRow-check{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-DetailsRow-check:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-DetailsRow-check{opacity:0}.ms-DetailsRow.is-check-visible .ms-DetailsRow-check,.ms-DetailsRow.is-selected .ms-DetailsRow-check,.ms-DetailsRow:hover .ms-DetailsRow-check{opacity:1}.aFileTypeIconRenderer{height:36px;line-height:36px;vertical-align:top}.FileTypeIconRenderer>img{width:16px;height:16px;vertical-align:middle}.ms-DetailsRow-cellMeasurer .ms-DetailsRow-cell{overflow:visible;white-space:nowrap}.ms-DetailsRow-checkSpacer{display:inline-block;height:20px;width:20px}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(482));
	


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(483));
	


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var GroupedListSection_1 = __webpack_require__(484);
	var List_1 = __webpack_require__(493);
	var index_1 = __webpack_require__(462);
	__webpack_require__(496);
	var GroupedList = (function (_super) {
	    __extends(GroupedList, _super);
	    function GroupedList(props) {
	        var _this = _super.call(this, props) || this;
	        _this._isSomeGroupExpanded = _this._computeIsSomeGroupExpanded(props.groups);
	        _this.state = {
	            lastWidth: 0,
	            groups: props.groups
	        };
	        return _this;
	    }
	    GroupedList.prototype.componentWillReceiveProps = function (newProps) {
	        var _a = this.props, groups = _a.groups, selectionMode = _a.selectionMode;
	        var shouldForceUpdates = false;
	        if (newProps.groups !== groups) {
	            this.setState({ groups: newProps.groups });
	            shouldForceUpdates = true;
	        }
	        if (newProps.selectionMode !== selectionMode) {
	            shouldForceUpdates = true;
	        }
	        if (shouldForceUpdates) {
	            this._forceListUpdates();
	        }
	    };
	    GroupedList.prototype.render = function () {
	        var className = this.props.className;
	        var groups = this.state.groups;
	        return (React.createElement("div", { ref: 'root', className: Utilities_1.css('ms-GroupedList', className), "data-automationid": 'GroupedList', "data-is-scrollable": 'false', role: 'grid' }, !groups ?
	            this._renderGroup(null, 0) : (React.createElement(List_1.List, { ref: 'list', items: groups, onRenderCell: this._renderGroup, getItemCountForPage: function () { return 1; } }))));
	    };
	    GroupedList.prototype.forceUpdate = function () {
	        _super.prototype.forceUpdate.call(this);
	        this._forceListUpdates();
	    };
	    GroupedList.prototype.toggleCollapseAll = function (allCollapsed) {
	        var groups = this.state.groups;
	        var groupProps = this.props.groupProps;
	        var onToggleCollapseAll = groupProps && groupProps.onToggleCollapseAll;
	        if (groups) {
	            if (onToggleCollapseAll) {
	                onToggleCollapseAll(allCollapsed);
	            }
	            for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {
	                groups[groupIndex].isCollapsed = allCollapsed;
	            }
	            this._updateIsSomeGroupExpanded();
	            this.forceUpdate();
	        }
	    };
	    GroupedList.prototype._renderGroup = function (group, groupIndex) {
	        var _a = this.props, dragDropEvents = _a.dragDropEvents, dragDropHelper = _a.dragDropHelper, eventsToRegister = _a.eventsToRegister, groupProps = _a.groupProps, items = _a.items, listProps = _a.listProps, onRenderCell = _a.onRenderCell, selectionMode = _a.selectionMode, selection = _a.selection, viewport = _a.viewport;
	        // override group header/footer props as needed
	        var dividerProps = {
	            onToggleSelectGroup: this._onToggleSelectGroup,
	            onToggleCollapse: this._onToggleCollapse,
	            onToggleSummarize: this._onToggleSummarize
	        };
	        var headerProps = Utilities_1.assign({}, groupProps.headerProps, dividerProps);
	        var footerProps = Utilities_1.assign({}, groupProps.footerProps, dividerProps);
	        var groupNestingDepth = this._getGroupNestingDepth();
	        return (!group || group.count > 0) ? (React.createElement(GroupedListSection_1.GroupedListSection, { ref: 'group_' + groupIndex, key: this._getGroupKey(group, groupIndex), dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: eventsToRegister, footerProps: footerProps, getGroupItemLimit: groupProps && groupProps.getGroupItemLimit, group: group, groupIndex: groupIndex, groupNestingDepth: groupNestingDepth, headerProps: headerProps, listProps: listProps, items: items, onRenderCell: onRenderCell, onRenderGroupHeader: groupProps.onRenderHeader, onRenderGroupFooter: groupProps.onRenderFooter, selectionMode: selectionMode, selection: selection, viewport: viewport })) : null;
	    };
	    GroupedList.prototype._getGroupKey = function (group, index) {
	        return 'group-' + ((group && group.key) ? group.key : String(index));
	    };
	    GroupedList.prototype._getGroupNestingDepth = function () {
	        var groups = this.state.groups;
	        var level = 0;
	        var groupsInLevel = groups;
	        while (groupsInLevel && groupsInLevel.length > 0) {
	            level++;
	            groupsInLevel = groupsInLevel[0].children;
	        }
	        return level;
	    };
	    GroupedList.prototype._onToggleCollapse = function (group) {
	        var groupProps = this.props.groupProps;
	        var onToggleCollapse = groupProps && groupProps.headerProps && groupProps.headerProps.onToggleCollapse;
	        if (group) {
	            if (onToggleCollapse) {
	                onToggleCollapse(group);
	            }
	            group.isCollapsed = !group.isCollapsed;
	            this._updateIsSomeGroupExpanded();
	            this.forceUpdate();
	        }
	    };
	    GroupedList.prototype._onToggleSelectGroup = function (group) {
	        if (group) {
	            this.props.selection.toggleRangeSelected(group.startIndex, group.count);
	        }
	    };
	    GroupedList.prototype._forceListUpdates = function (groups) {
	        groups = groups || this.state.groups;
	        var groupCount = groups ? groups.length : 1;
	        if (this.refs.list) {
	            this.refs.list.forceUpdate();
	            for (var i = 0; i < groupCount; i++) {
	                var group = this.refs.list.refs['group_' + String(i)];
	                if (group) {
	                    group.forceListUpdate();
	                }
	            }
	        }
	        else {
	            var group = this.refs['group_' + String(0)];
	            if (group) {
	                group.forceListUpdate();
	            }
	        }
	    };
	    GroupedList.prototype._onToggleSummarize = function (group) {
	        var groupProps = this.props.groupProps;
	        var onToggleSummarize = groupProps && groupProps.footerProps && groupProps.footerProps.onToggleSummarize;
	        if (onToggleSummarize) {
	            onToggleSummarize(group);
	        }
	        else {
	            if (group) {
	                group.isShowingAll = !group.isShowingAll;
	            }
	            this.forceUpdate();
	        }
	    };
	    GroupedList.prototype._computeIsSomeGroupExpanded = function (groups) {
	        var _this = this;
	        return groups && groups.some(function (group) { return group.children ? _this._computeIsSomeGroupExpanded(group.children) : !group.isCollapsed; });
	    };
	    GroupedList.prototype._updateIsSomeGroupExpanded = function () {
	        var groups = this.state.groups;
	        var onGroupExpandStateChanged = this.props.onGroupExpandStateChanged;
	        var newIsSomeGroupExpanded = this._computeIsSomeGroupExpanded(groups);
	        if (this._isSomeGroupExpanded !== newIsSomeGroupExpanded) {
	            if (onGroupExpandStateChanged) {
	                onGroupExpandStateChanged(newIsSomeGroupExpanded);
	            }
	            this._isSomeGroupExpanded = newIsSomeGroupExpanded;
	        }
	    };
	    return GroupedList;
	}(Utilities_1.BaseComponent));
	GroupedList.defaultProps = {
	    selectionMode: index_1.SelectionMode.multiple,
	    isHeaderVisible: true,
	    groupProps: {}
	};
	__decorate([
	    Utilities_1.autobind
	], GroupedList.prototype, "_renderGroup", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedList.prototype, "_onToggleCollapse", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedList.prototype, "_onToggleSelectGroup", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedList.prototype, "_onToggleSummarize", null);
	exports.GroupedList = GroupedList;
	


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var index_1 = __webpack_require__(462);
	var GroupFooter_1 = __webpack_require__(485);
	var GroupHeader_1 = __webpack_require__(491);
	var List_1 = __webpack_require__(493);
	var Utilities_2 = __webpack_require__(410);
	var DEFAULT_DROPPING_CSS_CLASS = 'is-dropping';
	var GroupedListSection = (function (_super) {
	    __extends(GroupedListSection, _super);
	    function GroupedListSection(props) {
	        var _this = _super.call(this, props) || this;
	        var selection = props.selection, group = props.group;
	        _this._subGroups = {};
	        _this.state = {
	            isDropping: false,
	            isSelected: (selection && group) ? selection.isRangeSelected(group.startIndex, group.count) : false
	        };
	        return _this;
	    }
	    GroupedListSection.prototype.componentDidMount = function () {
	        var _a = this.props, dragDropHelper = _a.dragDropHelper, selection = _a.selection;
	        if (dragDropHelper) {
	            dragDropHelper.subscribe(this.refs.root, this._events, this._getGroupDragDropOptions());
	        }
	        if (selection) {
	            this._events.on(selection, index_1.SELECTION_CHANGE, this._onSelectionChange);
	        }
	    };
	    GroupedListSection.prototype.componentWillUnmount = function () {
	        var dragDropHelper = this.props.dragDropHelper;
	        if (dragDropHelper) {
	            dragDropHelper.unsubscribe(this.refs.root, this._dragDropKey);
	        }
	    };
	    GroupedListSection.prototype.render = function () {
	        var _a = this.props, getGroupItemLimit = _a.getGroupItemLimit, group = _a.group, groupIndex = _a.groupIndex, headerProps = _a.headerProps, footerProps = _a.footerProps, viewport = _a.viewport, selectionMode = _a.selectionMode, _b = _a.onRenderGroupHeader, onRenderGroupHeader = _b === void 0 ? this._onRenderGroupHeader : _b, _c = _a.onRenderGroupFooter, onRenderGroupFooter = _c === void 0 ? this._onRenderGroupFooter : _c;
	        var isSelected = this.state.isSelected;
	        var renderCount = group && getGroupItemLimit ? getGroupItemLimit(group) : Infinity;
	        var isFooterVisible = group && !group.children && !group.isCollapsed && !group.isShowingAll &&
	            (group.count > renderCount || group.hasMoreData);
	        var hasNestedGroups = group && group.children && group.children.length > 0;
	        var dividerProps = {
	            group: group,
	            groupIndex: groupIndex,
	            groupLevel: group ? group.level : 0,
	            isSelected: isSelected,
	            viewport: viewport,
	            selectionMode: selectionMode
	        };
	        var groupHeaderProps = Utilities_2.assign({}, headerProps, dividerProps);
	        var groupFooterProps = Utilities_2.assign({}, footerProps, dividerProps);
	        return (React.createElement("div", { ref: 'root', className: Utilities_2.css('ms-GroupedList-group', this._getDroppingClassName()) },
	            onRenderGroupHeader(groupHeaderProps, this._onRenderGroupHeader),
	            group && group.isCollapsed ?
	                null :
	                (hasNestedGroups ?
	                    (React.createElement(List_1.List, { ref: 'list', items: group.children, onRenderCell: this._renderSubGroup, getItemCountForPage: function () { return 1; } })) :
	                    this._onRenderGroup(renderCount)),
	            isFooterVisible && onRenderGroupFooter(groupFooterProps, this._onRenderGroupFooter)));
	    };
	    GroupedListSection.prototype.forceUpdate = function () {
	        _super.prototype.forceUpdate.call(this);
	        this.forceListUpdate();
	    };
	    GroupedListSection.prototype.forceListUpdate = function () {
	        var group = this.props.group;
	        if (this.refs.list) {
	            this.refs.list.forceUpdate();
	            if (group && group.children && group.children.length > 0) {
	                var subGroupCount = group.children.length;
	                for (var i = 0; i < subGroupCount; i++) {
	                    var subGroup = this.refs.list.refs['subGroup_' + String(i)];
	                    if (subGroup) {
	                        subGroup.forceListUpdate();
	                    }
	                }
	            }
	        }
	        else {
	            var subGroup = this.refs['subGroup_' + String(0)];
	            if (subGroup) {
	                subGroup.forceListUpdate();
	            }
	        }
	    };
	    GroupedListSection.prototype._onRenderGroupHeader = function (props) {
	        return React.createElement(GroupHeader_1.GroupHeader, __assign({}, props));
	    };
	    GroupedListSection.prototype._onRenderGroupFooter = function (props) {
	        return React.createElement(GroupFooter_1.GroupFooter, __assign({}, props));
	    };
	    GroupedListSection.prototype._onSelectionChange = function () {
	        var _a = this.props, group = _a.group, selection = _a.selection;
	        var isSelected = selection.isRangeSelected(group.startIndex, group.count);
	        if (isSelected !== this.state.isSelected) {
	            this.setState({ isSelected: isSelected });
	        }
	    };
	    GroupedListSection.prototype._onRenderGroup = function (renderCount) {
	        var _a = this.props, group = _a.group, items = _a.items, onRenderCell = _a.onRenderCell, listProps = _a.listProps, groupNestingDepth = _a.groupNestingDepth;
	        var count = group ? group.count : items.length;
	        var startIndex = group ? group.startIndex : 0;
	        return (React.createElement(List_1.List, __assign({ items: items, onRenderCell: function (item, itemIndex) { return onRenderCell(groupNestingDepth, item, itemIndex); }, ref: 'list', renderCount: Math.min(count, renderCount), startIndex: startIndex }, listProps)));
	    };
	    GroupedListSection.prototype._renderSubGroup = function (subGroup, subGroupIndex) {
	        var _a = this.props, dragDropEvents = _a.dragDropEvents, dragDropHelper = _a.dragDropHelper, eventsToRegister = _a.eventsToRegister, getGroupItemLimit = _a.getGroupItemLimit, groupNestingDepth = _a.groupNestingDepth, items = _a.items, headerProps = _a.headerProps, footerProps = _a.footerProps, listProps = _a.listProps, onRenderCell = _a.onRenderCell, selection = _a.selection, selectionMode = _a.selectionMode, viewport = _a.viewport;
	        return (!subGroup || subGroup.count > 0) ? (React.createElement(GroupedListSection, { ref: 'subGroup_' + subGroupIndex, key: this._getGroupKey(subGroup, subGroupIndex), dragDropEvents: dragDropEvents, dragDropHelper: dragDropHelper, eventsToRegister: eventsToRegister, footerProps: footerProps, getGroupItemLimit: getGroupItemLimit, group: subGroup, groupIndex: subGroupIndex, groupNestingDepth: groupNestingDepth, headerProps: headerProps, items: items, listProps: listProps, onRenderCell: onRenderCell, selection: selection, selectionMode: selectionMode, viewport: viewport })) : null;
	    };
	    GroupedListSection.prototype._getGroupKey = function (group, index) {
	        return 'group-' + ((group && group.key) ? group.key : String(group.level) + String(index));
	    };
	    /**
	     * collect all the data we need to enable drag/drop for a group
	     */
	    GroupedListSection.prototype._getGroupDragDropOptions = function () {
	        var _a = this.props, group = _a.group, groupIndex = _a.groupIndex, dragDropEvents = _a.dragDropEvents, eventsToRegister = _a.eventsToRegister;
	        this._dragDropKey = 'group-' + (group ? group.key : String(groupIndex));
	        var options = {
	            key: this._dragDropKey,
	            eventMap: eventsToRegister,
	            selectionIndex: -1,
	            context: { data: group, index: groupIndex, isGroup: true },
	            canDrag: function () { return false; },
	            canDrop: dragDropEvents.canDrop,
	            onDragStart: null,
	            updateDropState: this._updateDroppingState
	        };
	        return options;
	    };
	    /**
	     * update groupIsDropping state based on the input value, which is used to change style during drag and drop
	     *
	     * @private
	     * @param {boolean} newValue (new isDropping state value)
	     * @param {DragEvent} event (the event trigger dropping state change which can be dragenter, dragleave etc)
	     */
	    GroupedListSection.prototype._updateDroppingState = function (newIsDropping, event) {
	        var isDropping = this.state.isDropping;
	        var dragDropEvents = this.props.dragDropEvents;
	        if (!isDropping) {
	            if (dragDropEvents.onDragLeave) {
	                dragDropEvents.onDragLeave(event, null);
	            }
	        }
	        else {
	            if (dragDropEvents.onDragEnter) {
	                dragDropEvents.onDragEnter(event, null);
	            }
	        }
	        if (isDropping !== newIsDropping) {
	            this.setState({ isDropping: newIsDropping });
	        }
	    };
	    /**
	     * get the correct css class to reflect the dropping state for a given group
	     *
	     * If the group is the current drop target, return the default dropping class name
	     * Otherwise, return '';
	     *
	     */
	    GroupedListSection.prototype._getDroppingClassName = function () {
	        var isDropping = this.state.isDropping;
	        var group = this.props.group;
	        var droppingClass = group && isDropping ? DEFAULT_DROPPING_CSS_CLASS : '';
	        return droppingClass;
	    };
	    return GroupedListSection;
	}(Utilities_1.BaseComponent));
	__decorate([
	    Utilities_1.autobind
	], GroupedListSection.prototype, "_onRenderGroupHeader", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedListSection.prototype, "_onRenderGroupFooter", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedListSection.prototype, "_renderSubGroup", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedListSection.prototype, "_getGroupDragDropOptions", null);
	__decorate([
	    Utilities_1.autobind
	], GroupedListSection.prototype, "_updateDroppingState", null);
	exports.GroupedListSection = GroupedListSection;
	


/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var Link_1 = __webpack_require__(486);
	var GroupSpacer_1 = __webpack_require__(472);
	__webpack_require__(490);
	var GroupFooter = (function (_super) {
	    __extends(GroupFooter, _super);
	    function GroupFooter() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    GroupFooter.prototype.render = function () {
	        var _a = this.props, group = _a.group, groupLevel = _a.groupLevel, showAllLinkText = _a.showAllLinkText;
	        return group && (React.createElement("div", { className: 'ms-groupFooter' },
	            GroupSpacer_1.GroupSpacer({ count: groupLevel }),
	            React.createElement(Link_1.Link, { onClick: this._onSummarizeClick }, showAllLinkText)));
	    };
	    GroupFooter.prototype._onSummarizeClick = function (ev) {
	        this.props.onToggleSummarize(this.props.group);
	        ev.stopPropagation();
	        ev.preventDefault();
	    };
	    return GroupFooter;
	}(Utilities_1.BaseComponent));
	__decorate([
	    Utilities_1.autobind
	], GroupFooter.prototype, "_onSummarizeClick", null);
	exports.GroupFooter = GroupFooter;
	


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(487));
	


/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(488));
	


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	__webpack_require__(489);
	var Link = (function (_super) {
	    __extends(Link, _super);
	    function Link() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Link.prototype.render = function () {
	        var _a = this.props, disabled = _a.disabled, children = _a.children, className = _a.className, href = _a.href;
	        return (href ? (React.createElement("a", __assign({}, Utilities_1.getNativeProps(this.props, Utilities_1.anchorProperties), { className: Utilities_1.css('ms-Link', className, {
	                'is-disabled': disabled
	            }), onClick: this._onClick, ref: this._resolveRef('_link'), target: this.props.target }), children)) : (React.createElement("button", __assign({}, Utilities_1.getNativeProps(this.props, Utilities_1.buttonProperties), { className: Utilities_1.css('ms-Link', className, {
	                'is-disabled': disabled
	            }), onClick: this._onClick, ref: this._resolveRef('_link') }), children)));
	    };
	    Link.prototype.focus = function () {
	        if (this._link) {
	            this._link.focus();
	        }
	    };
	    Link.prototype._onClick = function (ev) {
	        var onClick = this.props.onClick;
	        if (onClick) {
	            onClick(ev);
	        }
	    };
	    return Link;
	}(Utilities_1.BaseComponent));
	__decorate([
	    Utilities_1.autobind
	], Link.prototype, "_onClick", null);
	exports.Link = Link;
	


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-Link{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": ";margin:0;overflow:inherit;padding:0;text-overflow:inherit}.ms-Link:not(.is-disabled):focus,.ms-Link:not(.is-disabled):hover{color:" }, { "theme": "themeDarker", "defaultValue": "#004578" }, { "rawString": "}.ms-Link:not(.is-disabled):active{color:" }, { "theme": "themePrimary", "defaultValue": "#0078d7" }, { "rawString": "}.ms-Link.is-disabled{color:" }, { "theme": "neutralTertiary", "defaultValue": "#a6a6a6" }, { "rawString": ";pointer-events:none;cursor:default}button.ms-Link{background:0 0;border:none;cursor:pointer;display:inline;font-size:inherit}button.ms-Link::-moz-focus-inner{border:0}button.ms-Link{outline:transparent;position:relative}.ms-Fabric.is-focusVisible button.ms-Link:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}html[dir=ltr] button.ms-Link{text-align:left}html[dir=rtl] button.ms-Link{text-align:right}a.ms-Link{text-decoration:none}.ms-Fabric.is-focusVisible a.ms-Link:focus{outline:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-groupFooter{position:relative;padding:10px 84px;cursor:pointer}.ms-groupFooter .ms-Link{font-family:\"Segoe UI WestEuropean\",\"Segoe UI\",-apple-system,BlinkMacSystemFont,Roboto,\"Helvetica Neue\",sans-serif;-webkit-font-smoothing:antialiased;font-size:12px}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var index_1 = __webpack_require__(462);
	var Check_1 = __webpack_require__(470);
	var GroupSpacer_1 = __webpack_require__(472);
	var Spinner_1 = __webpack_require__(439);
	var FocusZone_1 = __webpack_require__(432);
	__webpack_require__(492);
	var GroupHeader = (function (_super) {
	    __extends(GroupHeader, _super);
	    function GroupHeader(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            isCollapsed: _this.props.group && _this.props.group.isCollapsed,
	            isLoadingVisible: false
	        };
	        return _this;
	    }
	    GroupHeader.prototype.componentWillReceiveProps = function (newProps) {
	        if (newProps.group) {
	            var newCollapsed = newProps.group.isCollapsed;
	            var isGroupLoading = newProps.headerProps && newProps.headerProps.isGroupLoading;
	            var newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(newProps.group);
	            this.setState({
	                isCollapsed: newCollapsed,
	                isLoadingVisible: newLoadingVisible
	            });
	        }
	    };
	    GroupHeader.prototype.render = function () {
	        var _a = this.props, group = _a.group, groupLevel = _a.groupLevel, viewport = _a.viewport, selectionMode = _a.selectionMode, loadingText = _a.loadingText, isSelected = _a.isSelected, selected = _a.selected, isCollapsedGroupSelectVisible = _a.isCollapsedGroupSelectVisible;
	        var _b = this.state, isCollapsed = _b.isCollapsed, isLoadingVisible = _b.isLoadingVisible;
	        if (isCollapsedGroupSelectVisible === undefined) {
	            isCollapsedGroupSelectVisible = true;
	        }
	        var canSelectGroup = selectionMode === index_1.SelectionMode.multiple;
	        var isSelectionCheckVisible = canSelectGroup && (isCollapsedGroupSelectVisible || !(group && group.isCollapsed));
	        var currentlySelected = isSelected || selected;
	        return group && (React.createElement("div", { className: Utilities_1.css('ms-GroupHeader', {
	                'is-selected': currentlySelected
	            }), style: viewport ? { minWidth: viewport.width } : {}, onClick: this._onHeaderClick, "aria-label": group.ariaLabel || group.name, "data-is-focusable": true },
	            React.createElement(FocusZone_1.FocusZone, { direction: FocusZone_1.FocusZoneDirection.horizontal },
	                isSelectionCheckVisible ? (React.createElement("button", { className: 'ms-GroupHeader-check', "data-selection-toggle": true, onClick: this._onToggleSelectGroupClick },
	                    React.createElement(Check_1.Check, { checked: currentlySelected }))) : (selectionMode !== index_1.SelectionMode.none ? GroupSpacer_1.GroupSpacer({ count: 1 }) : null),
	                GroupSpacer_1.GroupSpacer({ count: groupLevel }),
	                React.createElement("div", { className: 'ms-GroupHeader-dropIcon' },
	                    React.createElement("i", { className: 'ms-Icon ms-Icon--Tag' })),
	                React.createElement("button", { className: 'ms-GroupHeader-expand', onClick: this._onToggleCollapse },
	                    React.createElement("i", { className: Utilities_1.css('ms-Icon ms-Icon--ChevronDown', {
	                            'is-collapsed': isCollapsed
	                        }) })),
	                React.createElement("div", { className: 'ms-GroupHeader-title ms-font-xl' },
	                    React.createElement("span", null,
	                        group.name,
	                        " "),
	                    React.createElement("span", null,
	                        "(",
	                        group.count,
	                        group.hasMoreData && '+',
	                        ") ")),
	                React.createElement("div", { className: Utilities_1.css('ms-GroupHeader-loading', { 'is-loading': isLoadingVisible }) },
	                    React.createElement(Spinner_1.Spinner, { label: loadingText })))));
	    };
	    GroupHeader.prototype._onToggleCollapse = function (ev) {
	        var _a = this.props, group = _a.group, onToggleCollapse = _a.onToggleCollapse, isGroupLoading = _a.isGroupLoading;
	        var isCollapsed = this.state.isCollapsed;
	        var newCollapsed = !isCollapsed;
	        var newLoadingVisible = !newCollapsed && isGroupLoading && isGroupLoading(group);
	        this.setState({
	            isCollapsed: newCollapsed,
	            isLoadingVisible: newLoadingVisible
	        });
	        if (onToggleCollapse) {
	            onToggleCollapse(group);
	        }
	        ev.stopPropagation();
	        ev.preventDefault();
	    };
	    GroupHeader.prototype._onToggleSelectGroupClick = function (ev) {
	        var _a = this.props, onToggleSelectGroup = _a.onToggleSelectGroup, group = _a.group;
	        if (onToggleSelectGroup) {
	            onToggleSelectGroup(group);
	        }
	        ev.preventDefault();
	        ev.stopPropagation();
	    };
	    GroupHeader.prototype._onHeaderClick = function () {
	        var _a = this.props, group = _a.group, onGroupHeaderClick = _a.onGroupHeaderClick, onToggleSelectGroup = _a.onToggleSelectGroup;
	        if (onGroupHeaderClick) {
	            onGroupHeaderClick(group);
	        }
	        else if (onToggleSelectGroup) {
	            onToggleSelectGroup(group);
	        }
	    };
	    return GroupHeader;
	}(React.Component));
	__decorate([
	    Utilities_1.autobind
	], GroupHeader.prototype, "_onToggleCollapse", null);
	__decorate([
	    Utilities_1.autobind
	], GroupHeader.prototype, "_onToggleSelectGroupClick", null);
	__decorate([
	    Utilities_1.autobind
	], GroupHeader.prototype, "_onHeaderClick", null);
	exports.GroupHeader = GroupHeader;
	


/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-GroupHeader{cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ms-GroupHeader::-moz-focus-inner{border:0}.ms-GroupHeader{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-GroupHeader:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-GroupHeader:hover{background:" }, { "theme": "themeLighterAlt", "defaultValue": "#eff6fc" }, { "rawString": "}.ms-GroupHeader.is-selected{background:" }, { "theme": "themeLighter", "defaultValue": "#deecf9" }, { "rawString": "}.ms-GroupHeader.is-selected:hover{background:" }, { "theme": "themeLight", "defaultValue": "#c7e0f4" }, { "rawString": "}.ms-GroupHeader-check,.ms-GroupHeader-expand{display:inline-block;cursor:default;padding:6px;-webkit-transform:translateY(50%);transform:translateY(50%);margin-top:-12px;box-sizing:border-box;vertical-align:top;background:0 0;border:none;font-size:12px;top:4px}.ms-GroupHeader-check::-moz-focus-inner,.ms-GroupHeader-expand::-moz-focus-inner{border:0}.ms-GroupHeader-check,.ms-GroupHeader-expand{outline:transparent;position:relative}.ms-Fabric.is-focusVisible .ms-GroupHeader-check:focus:after,.ms-Fabric.is-focusVisible .ms-GroupHeader-expand:focus:after{content:'';position:absolute;top:0;right:0;bottom:0;left:0;pointer-events:none;border:1px solid " }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-GroupHeader-check{opacity:0;margin-top:-10px}.ms-GroupHeader-check:focus{opacity:1}.ms-GroupHeader.is-selected .ms-GroupHeader-check,.ms-GroupHeader:hover .ms-GroupHeader-check{opacity:1}.ms-GroupHeader-title{padding:14px 6px;display:inline-block;cursor:pointer;outline:0}.ms-GroupHeader-expand{width:36px;height:40px;color:" }, { "theme": "neutralSecondary", "defaultValue": "#666666" }, { "rawString": "}.ms-GroupHeader-expand .ms-Icon{-webkit-transform:rotate(-180deg);transform:rotate(-180deg);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transition:-webkit-transform .1s linear;transition:-webkit-transform .1s linear;transition:transform .1s linear;transition:transform .1s linear,-webkit-transform .1s linear}.ms-GroupHeader-expand .ms-Icon.is-collapsed{-webkit-transform:rotate(0);transform:rotate(0)}.ms-GroupHeader-loading{display:inline-block;visibility:hidden;opacity:0;padding:0 16px;vertical-align:middle;-webkit-transition:visibility 367ms,opacity 367ms;transition:visibility 367ms,opacity 367ms}.ms-GroupHeader-loading.is-loading{visibility:visible;opacity:1}.ms-GroupHeader-dropIcon{display:inline-block;position:relative;top:-16px;font-size:20px;color:" }, { "theme": "neutralSecondaryAlt", "defaultValue": "#767676" }, { "rawString": ";-webkit-transition:opacity 467ms cubic-bezier(.39,.575,.565,1),-webkit-transform 267ms cubic-bezier(.6,-.28,.735,.045);transition:opacity 467ms cubic-bezier(.39,.575,.565,1),-webkit-transform 267ms cubic-bezier(.6,-.28,.735,.045);transition:transform 267ms cubic-bezier(.6,-.28,.735,.045),opacity 467ms cubic-bezier(.39,.575,.565,1);transition:transform 267ms cubic-bezier(.6,-.28,.735,.045),opacity 467ms cubic-bezier(.39,.575,.565,1),-webkit-transform 267ms cubic-bezier(.6,-.28,.735,.045);opacity:0;-webkit-transform:rotate(.2deg) scale(.65);transform:rotate(.2deg) scale(.65);-webkit-transform-origin:10px 10px;transform-origin:10px 10px}html[dir=ltr] .ms-GroupHeader-dropIcon{left:-26px}html[dir=rtl] .ms-GroupHeader-dropIcon{right:-26px}.ms-GroupHeader-dropIcon .ms-Icon--Tag{position:absolute}.ms-GroupedList-group.is-dropping>.ms-GroupHeader .ms-GroupHeader-dropIcon{-webkit-transition:opacity 167ms cubic-bezier(.39,.575,.565,1),-webkit-transform 467ms cubic-bezier(.075,.82,.165,1);transition:opacity 167ms cubic-bezier(.39,.575,.565,1),-webkit-transform 467ms cubic-bezier(.075,.82,.165,1);transition:transform 467ms cubic-bezier(.075,.82,.165,1),opacity 167ms cubic-bezier(.39,.575,.565,1);transition:transform 467ms cubic-bezier(.075,.82,.165,1),opacity 167ms cubic-bezier(.39,.575,.565,1),-webkit-transform 467ms cubic-bezier(.075,.82,.165,1);-webkit-transition-delay:367ms;transition-delay:367ms;opacity:1;-webkit-transform:rotate(.2deg) scale(1);transform:rotate(.2deg) scale(1)}.ms-GroupedList-group.is-dropping .ms-GroupHeader-check{opacity:0}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(494));
	


/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(495));
	


/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var Utilities_1 = __webpack_require__(410);
	var RESIZE_DELAY = 16;
	var MIN_SCROLL_UPDATE_DELAY = 100;
	var MAX_SCROLL_UPDATE_DELAY = 500;
	var IDLE_DEBOUNCE_DELAY = 200;
	var DEFAULT_ITEMS_PER_PAGE = 10;
	var DEFAULT_PAGE_HEIGHT = 30;
	var DEFAULT_RENDERED_WINDOWS_BEHIND = 2;
	var DEFAULT_RENDERED_WINDOWS_AHEAD = 2;
	var EMPTY_RECT = {
	    top: -1,
	    bottom: -1,
	    left: -1,
	    right: -1,
	    width: 0,
	    height: 0
	};
	// Naming expensive measures so that they're named in profiles.
	var _measurePageRect = function (element) { return element.getBoundingClientRect(); };
	var _measureSurfaceRect = _measurePageRect;
	var _measureScrollRect = _measurePageRect;
	/**
	 * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback if
	 * provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if provided by
	 * the caller, or by cached measurements if available, or by a running average, or a default fallback.
	 *
	 * The algorithm for rendering pages works like this:
	 *
	 * 1. Predict visible pages based on "current measure data" (page heights, surface position, visible window)
	 * 2. If changes are necessary, apply changes (add/remove pages)
	 * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect
	 * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously
	 *
	 * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that
	 * we can avoid re-measuring during operations that should not alter heights, like scrolling.
	 *
	 * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,
	 * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion
	 * number, which we associate with cached measurements and use to determine if a remeasure should occur.
	 */
	var List = (function (_super) {
	    __extends(List, _super);
	    function List(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            pages: []
	        };
	        _this._estimatedPageHeight = 0;
	        _this._totalEstimates = 0;
	        _this._requiredWindowsAhead = 0;
	        _this._requiredWindowsBehind = 0;
	        // Track the measure version for everything.
	        _this._measureVersion = 0;
	        // Ensure that scrolls are lazy updated.
	        _this._onAsyncScroll = _this._async.debounce(_this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {
	            leading: false,
	            maxWait: MAX_SCROLL_UPDATE_DELAY
	        });
	        _this._onAsyncIdle = _this._async.debounce(_this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {
	            leading: false
	        });
	        _this._onAsyncResize = _this._async.debounce(_this._onAsyncResize, RESIZE_DELAY, {
	            leading: false
	        });
	        _this._cachedPageHeights = {};
	        _this._estimatedPageHeight = 0;
	        _this._focusedIndex = -1;
	        _this._scrollingToIndex = -1;
	        return _this;
	    }
	    /**
	     * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback
	     * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.
	     *
	     * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling
	     * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.
	     *
	     * @param index Index of item to scroll to
	     * @param measureItem Optional callback to measure the height of an individual item
	     */
	    List.prototype.scrollToIndex = function (index, measureItem) {
	        var startIndex = this.props.startIndex;
	        var renderCount = this._getRenderCount();
	        var endIndex = startIndex + renderCount;
	        var scrollTop = 0;
	        var itemsPerPage = 1;
	        for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
	            itemsPerPage = this._getItemCountForPage(itemIndex, this._allowedRect);
	            var requestedIndexIsInPage = itemIndex <= index && (itemIndex + itemsPerPage) > index;
	            if (requestedIndexIsInPage) {
	                // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in just
	                // the given item, otherwise we'll only bring the page into view
	                if (measureItem) {
	                    // Adjust for actual item position within page
	                    var itemPositionWithinPage = index - itemIndex;
	                    for (var itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {
	                        scrollTop += measureItem(itemIndex + itemIndexInPage);
	                    }
	                    var scrollBottom = scrollTop + measureItem(index);
	                    var scrollRect = _measureScrollRect(this._scrollElement);
	                    var scrollWindow = {
	                        top: this._scrollElement.scrollTop,
	                        bottom: this._scrollElement.scrollTop + scrollRect.height
	                    };
	                    var itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;
	                    if (itemIsFullyVisible) {
	                        // Item is already visible, do nothing.
	                        return;
	                    }
	                    var itemIsPartiallyAbove = scrollTop < scrollWindow.top;
	                    var itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;
	                    if (itemIsPartiallyAbove) {
	                    }
	                    else if (itemIsPartiallyBelow) {
	                        // Adjust scrollTop position to just bring in the element
	                        //  ______   - scrollTop
	                        // |      |
	                        // |  ____|_  - scrollWindow.bottom
	                        // |_|____| |
	                        //   | Item |
	                        //   |______| - scrollBottom
	                        scrollTop = this._scrollElement.scrollTop + (scrollBottom - scrollWindow.bottom);
	                    }
	                }
	                this._scrollElement.scrollTop = scrollTop;
	                break;
	            }
	            scrollTop += this._getPageHeight(itemIndex, itemsPerPage, this._surfaceRect);
	        }
	    };
	    List.prototype.componentDidMount = function () {
	        this._updatePages();
	        this._measureVersion++;
	        this._scrollElement = Utilities_1.findScrollableParent(this.refs.root);
	        this._events.on(window, 'resize', this._onAsyncResize);
	        this._events.on(this.refs.root, 'focus', this._onFocus, true);
	        if (this._scrollElement) {
	            this._events.on(this._scrollElement, 'scroll', this._onScroll);
	            this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);
	        }
	    };
	    List.prototype.componentWillReceiveProps = function (newProps) {
	        if (newProps.items !== this.props.items ||
	            newProps.renderCount !== this.props.renderCount ||
	            newProps.startIndex !== this.props.startIndex) {
	            this._measureVersion++;
	            this._updatePages(newProps);
	        }
	    };
	    List.prototype.shouldComponentUpdate = function (newProps, newState) {
	        var _a = this.props, renderedWindowsAhead = _a.renderedWindowsAhead, renderedWindowsBehind = _a.renderedWindowsBehind;
	        var oldPages = this.state.pages;
	        var newPages = newState.pages, measureVersion = newState.measureVersion;
	        var shouldComponentUpdate = false;
	        if (this._measureVersion === measureVersion &&
	            newProps.renderedWindowsAhead === renderedWindowsAhead,
	            newProps.renderedWindowsBehind === renderedWindowsBehind,
	            newProps.items === this.props.items &&
	                oldPages.length === newPages.length) {
	            for (var i = 0; i < oldPages.length; i++) {
	                var oldPage = oldPages[i];
	                var newPage = newPages[i];
	                if ((oldPage.key !== newPage.key ||
	                    oldPage.itemCount !== newPage.itemCount)) {
	                    shouldComponentUpdate = true;
	                    break;
	                }
	            }
	        }
	        else {
	            shouldComponentUpdate = true;
	        }
	        return shouldComponentUpdate;
	    };
	    List.prototype.forceUpdate = function () {
	        // Ensure that when the list is force updated we update the pages first before render.
	        this._updateRenderRects(this.props, true);
	        this._updatePages();
	        this._measureVersion++;
	        _super.prototype.forceUpdate.call(this);
	    };
	    List.prototype.render = function () {
	        var className = this.props.className;
	        var pages = this.state.pages;
	        var pageElements = [];
	        for (var i = 0; i < pages.length; i++) {
	            pageElements.push(this._renderPage(pages[i]));
	        }
	        return (React.createElement("div", { ref: 'root', className: Utilities_1.css('ms-List', className) },
	            React.createElement("div", { ref: 'surface', className: 'ms-List-surface' }, pageElements)));
	    };
	    List.prototype._renderPage = function (page) {
	        var onRenderCell = this.props.onRenderCell;
	        var cells = [];
	        var pageStyle = this._getPageStyle(page);
	        for (var i = 0; page.items && i < page.items.length; i++) {
	            var item = page.items[i];
	            var itemKey = (item ? item.key : null);
	            if (itemKey === null || itemKey === undefined) {
	                itemKey = page.startIndex + i;
	            }
	            cells.push(React.createElement("div", { className: 'ms-List-cell', key: itemKey, "data-list-index": i + page.startIndex, "data-automationid": 'ListCell' }, onRenderCell(item, page.startIndex + i)));
	        }
	        return (React.createElement("div", { className: 'ms-List-page', key: page.key, ref: page.key, style: pageStyle }, cells));
	    };
	    /** Generate the style object for the page. */
	    List.prototype._getPageStyle = function (page) {
	        var style;
	        var getPageStyle = this.props.getPageStyle;
	        if (getPageStyle) {
	            style = getPageStyle(page);
	        }
	        if (!page.items) {
	            style = style || {};
	            style.height = page.height;
	        }
	        return style;
	    };
	    /** Track the last item index focused so that we ensure we keep it rendered. */
	    List.prototype._onFocus = function (ev) {
	        var target = ev.target;
	        while (target !== this.refs.surface) {
	            var indexString = target.getAttribute('data-list-index');
	            if (indexString) {
	                this._focusedIndex = Number(indexString);
	                break;
	            }
	            target = Utilities_1.getParent(target);
	        }
	    };
	    /**
	     * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,
	     * we will call onAsyncIdle which will reset it back to it's correct value.
	     */
	    List.prototype._onScroll = function () {
	        this._requiredWindowsAhead = 0;
	        this._requiredWindowsBehind = 0;
	    };
	    /**
	     * Debounced method to asynchronously update the visible region on a scroll event.
	     */
	    List.prototype._onAsyncScroll = function () {
	        this._updateRenderRects();
	        // Only update pages when the visible rect falls outside of the materialized rect.
	        if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {
	            this._updatePages();
	        }
	        else {
	        }
	    };
	    /**
	     * This is an async debounced method that will try and increment the windows we render. If we can increment
	     * either, we increase the amount we render and re-evaluate.
	     */
	    List.prototype._onAsyncIdle = function () {
	        var _a = this.props, renderedWindowsAhead = _a.renderedWindowsAhead, renderedWindowsBehind = _a.renderedWindowsBehind;
	        var _b = this, requiredWindowsAhead = _b._requiredWindowsAhead, requiredWindowsBehind = _b._requiredWindowsBehind;
	        var windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);
	        var windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);
	        if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {
	            // console.log('idling', windowsBehind, windowsAhead);
	            this._requiredWindowsAhead = windowsAhead;
	            this._requiredWindowsBehind = windowsBehind;
	            this._updateRenderRects();
	            this._updatePages();
	        }
	        if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {
	            // Async increment on next tick.
	            this._onAsyncIdle();
	        }
	    };
	    List.prototype._onAsyncResize = function () {
	        this.forceUpdate();
	    };
	    List.prototype._updatePages = function (props) {
	        var _this = this;
	        var _a = (props || this.props), items = _a.items, startIndex = _a.startIndex, renderCount = _a.renderCount;
	        renderCount = this._getRenderCount(props);
	        // console.log('updating pages');
	        if (!this._requiredRect) {
	            this._updateRenderRects(props);
	        }
	        var newListState = this._buildPages(items, startIndex, renderCount);
	        var oldListPages = this.state.pages;
	        this.setState(newListState, function () {
	            // If measured version is invalid since we've updated the DOM
	            var heightsChanged = _this._updatePageMeasurements(oldListPages, newListState.pages);
	            // On first render, we should re-measure so that we don't get a visual glitch.
	            if (heightsChanged) {
	                _this._materializedRect = null;
	                if (!_this._hasCompletedFirstRender) {
	                    _this._hasCompletedFirstRender = true;
	                    _this._updatePages();
	                }
	                else {
	                    _this._onAsyncScroll();
	                }
	            }
	            else {
	                // Enqueue an idle bump.
	                _this._onAsyncIdle();
	            }
	        });
	    };
	    List.prototype._updatePageMeasurements = function (oldPages, newPages) {
	        var renderedIndexes = {};
	        var heightChanged = false;
	        var renderCount = this._getRenderCount();
	        for (var i = 0; i < oldPages.length; i++) {
	            var page = oldPages[i];
	            if (page.items) {
	                renderedIndexes[page.startIndex] = page;
	            }
	        }
	        for (var i = 0; i < newPages.length; i++) {
	            var page = newPages[i];
	            if (page.items) {
	                // Only evaluate page height if the page contains less items than total.
	                if (page.items.length < renderCount) {
	                    heightChanged = this._measurePage(page) || heightChanged;
	                }
	                if (!renderedIndexes[page.startIndex]) {
	                    this._onPageAdded(page);
	                }
	                else {
	                    delete renderedIndexes[page.startIndex];
	                }
	            }
	        }
	        for (var index in renderedIndexes) {
	            if (renderedIndexes.hasOwnProperty(index)) {
	                this._onPageRemoved(renderedIndexes[index]);
	            }
	        }
	        return heightChanged;
	    };
	    /**
	     * Given a page, measure its dimensions, update cache.
	     * @returns True if the height has changed.
	     */
	    List.prototype._measurePage = function (page) {
	        var hasChangedHeight = false;
	        var pageElement = this.refs[page.key];
	        var cachedHeight = this._cachedPageHeights[page.startIndex];
	        // console.log('   * measure attempt', page.startIndex, cachedHeight);
	        if (pageElement && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {
	            var newClientRect = _measurePageRect(pageElement);
	            hasChangedHeight = page.height !== newClientRect.height;
	            // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);
	            page.height = newClientRect.height;
	            this._cachedPageHeights[page.startIndex] = {
	                height: newClientRect.height,
	                measureVersion: this._measureVersion
	            };
	            this._estimatedPageHeight = Math.round(((this._estimatedPageHeight * this._totalEstimates) + newClientRect.height) /
	                (this._totalEstimates + 1));
	            this._totalEstimates++;
	        }
	        return hasChangedHeight;
	    };
	    /** Called when a page has been added to the DOM. */
	    List.prototype._onPageAdded = function (page) {
	        var onPageAdded = this.props.onPageAdded;
	        // console.log('page added', page.startIndex, this.state.pages.map(page=>page.key).join(', '));
	        if (onPageAdded) {
	            onPageAdded(page);
	        }
	    };
	    /** Called when a page has been removed from the DOM. */
	    List.prototype._onPageRemoved = function (page) {
	        var onPageRemoved = this.props.onPageRemoved;
	        // console.log('  --- page removed', page.startIndex, this.state.pages.map(page=>page.key).join(', '));
	        if (onPageRemoved) {
	            onPageRemoved(page);
	        }
	    };
	    /** Build up the pages that should be rendered. */
	    List.prototype._buildPages = function (items, startIndex, renderCount) {
	        var materializedRect = Utilities_1.assign({}, EMPTY_RECT);
	        var itemsPerPage = 1;
	        var pages = [];
	        var pageTop = 0;
	        var currentSpacer = null;
	        var focusedIndex = this._focusedIndex;
	        var endIndex = startIndex + renderCount;
	        // First render is very important to track; when we render cells, we have no idea of estimated page height.
	        // So we should default to rendering only the first page so that we can get information.
	        // However if the user provides a measure function, let's just assume they know the right heights.
	        var isFirstRender = this._estimatedPageHeight === 0 && !this.props.getPageHeight;
	        var _loop_1 = function (itemIndex) {
	            itemsPerPage = this_1._getItemCountForPage(itemIndex, this_1._allowedRect);
	            var pageHeight = this_1._getPageHeight(itemIndex, itemsPerPage, this_1._surfaceRect);
	            var pageBottom = pageTop + pageHeight - 1;
	            var isPageRendered = Utilities_1.findIndex(this_1.state.pages, function (page) { return page.items && page.startIndex === itemIndex; }) > -1;
	            var isPageInAllowedRange = pageBottom >= this_1._allowedRect.top && pageTop <= this_1._allowedRect.bottom;
	            var isPageInRequiredRange = pageBottom >= this_1._requiredRect.top && pageTop <= this_1._requiredRect.bottom;
	            var isPageVisible = !isFirstRender && (isPageInRequiredRange || (isPageInAllowedRange && isPageRendered));
	            var isPageFocused = focusedIndex >= itemIndex && focusedIndex < (itemIndex + itemsPerPage);
	            var isFirstPage = itemIndex === startIndex;
	            // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' + isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);
	            // Only render whats visible, focused, or first page.
	            if (isPageVisible || isPageFocused || isFirstPage) {
	                if (currentSpacer) {
	                    pages.push(currentSpacer);
	                    currentSpacer = null;
	                }
	                var itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);
	                var newPage = this_1._createPage(null, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex);
	                newPage.top = pageTop;
	                newPage.height = pageHeight;
	                pages.push(newPage);
	                if (isPageInRequiredRange) {
	                    _mergeRect(materializedRect, {
	                        top: pageTop,
	                        bottom: pageBottom,
	                        height: pageHeight,
	                        left: this_1._allowedRect.left,
	                        right: this_1._allowedRect.right,
	                        width: this_1._allowedRect.width
	                    });
	                }
	            }
	            else {
	                if (!currentSpacer) {
	                    currentSpacer = this_1._createPage('spacer-' + itemIndex, null, itemIndex, 0);
	                }
	                currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;
	                currentSpacer.itemCount += itemsPerPage;
	            }
	            pageTop += (pageBottom - pageTop + 1);
	            if (isFirstRender) {
	                return "break";
	            }
	        };
	        var this_1 = this;
	        for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {
	            var state_1 = _loop_1(itemIndex);
	            if (state_1 === "break")
	                break;
	        }
	        if (currentSpacer) {
	            currentSpacer.key = 'spacer-end';
	            pages.push(currentSpacer);
	        }
	        this._materializedRect = materializedRect;
	        // console.log('materialized: ', materializedRect);
	        return {
	            pages: pages,
	            measureVersion: this._measureVersion
	        };
	    };
	    /**
	     * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to
	     * cached height, or estimated page height, or default page height.
	     */
	    List.prototype._getPageHeight = function (itemIndex, itemsPerPage, visibleRect) {
	        if (this.props.getPageHeight) {
	            return this.props.getPageHeight(itemIndex, visibleRect);
	        }
	        else {
	            var cachedHeight = (this._cachedPageHeights[itemIndex]);
	            return cachedHeight ? cachedHeight.height : (this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT);
	        }
	    };
	    List.prototype._getItemCountForPage = function (itemIndex, visibileRect) {
	        var itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;
	        return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;
	    };
	    List.prototype._createPage = function (pageKey, items, startIndex, count, style) {
	        pageKey = pageKey || ('page-' + startIndex);
	        // Fill undefined cells because array.map will ignore undefined cells.
	        if (items) {
	            for (var i = 0; i < items.length; i++) {
	                items[i] = items[i] || null;
	            }
	        }
	        return {
	            key: pageKey,
	            startIndex: startIndex === undefined ? -1 : startIndex,
	            itemCount: (count === undefined) ? (items ? items.length : 0) : count,
	            items: items,
	            style: style || {},
	            top: 0,
	            height: 0
	        };
	    };
	    List.prototype._getRenderCount = function (props) {
	        var _a = props || this.props, items = _a.items, startIndex = _a.startIndex, renderCount = _a.renderCount;
	        return (renderCount === undefined ? (items ? items.length - startIndex : 0) : renderCount);
	    };
	    /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */
	    List.prototype._updateRenderRects = function (props, forceUpdate) {
	        var _a = (props || this.props), renderedWindowsAhead = _a.renderedWindowsAhead, renderedWindowsBehind = _a.renderedWindowsBehind;
	        var pages = this.state.pages;
	        var renderCount = this._getRenderCount(props);
	        var surfaceRect = this._surfaceRect;
	        // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.
	        if (forceUpdate ||
	            !pages ||
	            !this._surfaceRect ||
	            (pages.length > 0 && pages[0].items && pages[0].items.length < renderCount)) {
	            surfaceRect = this._surfaceRect = _measureSurfaceRect(this.refs.surface);
	        }
	        // If the surface is above the container top or below the container bottom, or if this is not the first
	        // render return empty rect.
	        // The first time the list gets rendered we need to calculate the rectangle. The width of the list is
	        // used to calculate the width of the list items.
	        var visibleTop = Math.max(0, -surfaceRect.top);
	        var visibleRect = {
	            top: visibleTop,
	            left: surfaceRect.left,
	            bottom: visibleTop + window.innerHeight,
	            right: surfaceRect.right,
	            width: surfaceRect.width,
	            height: window.innerHeight
	        };
	        // The required/allowed rects are adjusted versions of the visible rect.
	        this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);
	        this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead);
	    };
	    return List;
	}(Utilities_1.BaseComponent));
	List.defaultProps = {
	    startIndex: 0,
	    onRenderCell: function (item, index, containsFocus) { return (React.createElement("div", null, (item && item.name) || '')); },
	    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,
	    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND
	};
	exports.List = List;
	function _expandRect(rect, pagesBefore, pagesAfter) {
	    var top = rect.top - (pagesBefore * rect.height);
	    var height = rect.height + ((pagesBefore + pagesAfter) * rect.height);
	    return {
	        top: top,
	        bottom: top + height,
	        height: height,
	        left: rect.left,
	        right: rect.right,
	        width: rect.width
	    };
	}
	function _isContainedWithin(innerRect, outerRect) {
	    return (innerRect.top >= outerRect.top &&
	        innerRect.left >= outerRect.left &&
	        innerRect.bottom <= outerRect.bottom &&
	        innerRect.right <= outerRect.right);
	}
	function _mergeRect(targetRect, newRect) {
	    targetRect.top = (newRect.top < targetRect.top || targetRect.top === -1) ? newRect.top : targetRect.top;
	    targetRect.left = (newRect.left < targetRect.left || targetRect.left === -1) ? newRect.left : targetRect.left;
	    targetRect.bottom = (newRect.bottom > targetRect.bottom || targetRect.bottom === -1) ? newRect.bottom : targetRect.bottom;
	    targetRect.right = (newRect.right > targetRect.right || targetRect.right === -1) ? newRect.right : targetRect.right;
	    targetRect.width = targetRect.right - targetRect.left + 1;
	    targetRect.height = targetRect.bottom - targetRect.top + 1;
	    return targetRect;
	}
	


/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-GroupedList{position:relative;font-size:12px}.ms-GroupedList BUTTON{font-family:inherit;background-color:transparent}.ms-GroupedList>.ms-FocusZone{display:inline-block;vertical-align:top;min-width:1px;min-height:1px}.ms-GroupedList.is-horizontalConstrained{overflow-x:auto;overflow-y:visible;-webkit-overflow-scrolling:touch;-webkit-transform:translateZ(0);transform:translateZ(0)}.ms-GroupedList-cell{word-break:break-word}.ms-GroupedList-group{-webkit-transition:background-color 267ms cubic-bezier(.445,.05,.55,.95);transition:background-color 267ms cubic-bezier(.445,.05,.55,.95)}.ms-GroupedList-group.is-dropping{background-color:" }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": "}.ms-GroupedList .ms-List-cell{min-height:38px}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var React = __webpack_require__(386);
	var BaseDecorator_1 = __webpack_require__(498);
	var Utilities_1 = __webpack_require__(410);
	var RESIZE_DELAY = 500;
	function withViewport(ComposedComponent) {
	    return (function (_super) {
	        __extends(WithViewportComponent, _super);
	        function WithViewportComponent() {
	            var _this = _super.call(this) || this;
	            _this.state = {
	                viewport: {
	                    width: 0,
	                    height: 0
	                }
	            };
	            return _this;
	        }
	        WithViewportComponent.prototype.componentDidMount = function () {
	            this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {
	                leading: false
	            });
	            this._events.on(window, 'resize', this._onAsyncResize);
	            this._updateViewport();
	        };
	        WithViewportComponent.prototype.componentWillUnmount = function () {
	            this._events.dispose();
	        };
	        WithViewportComponent.prototype.render = function () {
	            var viewport = this.state.viewport;
	            var isViewportVisible = viewport.width > 0 && viewport.height > 0;
	            return (React.createElement("div", { className: 'ms-Viewport', ref: 'root', style: { minWidth: 1, minHeight: 1 } }, isViewportVisible && (React.createElement(ComposedComponent, __assign({ ref: this._updateComposedComponentRef, viewport: viewport }, this.props)))));
	        };
	        WithViewportComponent.prototype.forceUpdate = function () {
	            this._updateViewport(true);
	        };
	        WithViewportComponent.prototype._onAsyncResize = function () {
	            this._updateViewport();
	        };
	        WithViewportComponent.prototype._updateViewport = function (withForceUpdate) {
	            var _this = this;
	            var viewport = this.state.viewport;
	            var viewportElement = this.refs.root;
	            var scrollElement = Utilities_1.findScrollableParent(viewportElement);
	            var scrollRect = Utilities_1.getRect(scrollElement);
	            var clientRect = Utilities_1.getRect(viewportElement);
	            var updateComponent = function () {
	                if (withForceUpdate && _this._composedComponentInstance) {
	                    _this._composedComponentInstance.forceUpdate();
	                }
	            };
	            var isSizeChanged = (clientRect.width !== viewport.width ||
	                scrollRect.height !== viewport.height);
	            if (isSizeChanged) {
	                this.setState({
	                    viewport: {
	                        width: clientRect.width,
	                        height: scrollRect.height
	                    }
	                }, updateComponent);
	            }
	            else {
	                updateComponent();
	            }
	        };
	        return WithViewportComponent;
	    }(BaseDecorator_1.BaseDecorator));
	}
	exports.withViewport = withViewport;
	


/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Utilities_1 = __webpack_require__(410);
	var BaseDecorator = (function (_super) {
	    __extends(BaseDecorator, _super);
	    function BaseDecorator() {
	        var _this = _super.call(this) || this;
	        _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
	        return _this;
	    }
	    /**
	     * Updates the ref to the component composed by the decorator, which will also take care of hoisting
	     * (and unhoisting as appropriate) methods from said component.
	     *
	     * Pass this method as the argument to the 'ref' property of the composed component.
	     */
	    BaseDecorator.prototype._updateComposedComponentRef = function (composedComponentInstance) {
	        this._composedComponentInstance = composedComponentInstance;
	        if (composedComponentInstance) {
	            this._hoisted = Utilities_1.hoistMethods(this, composedComponentInstance);
	        }
	        else if (this._hoisted) {
	            Utilities_1.unhoistMethods(this, this._hoisted);
	        }
	    };
	    return BaseDecorator;
	}(Utilities_1.BaseComponent));
	exports.BaseDecorator = BaseDecorator;
	


/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ReactDOM = __webpack_require__(387);
	var Utilities_1 = __webpack_require__(410);
	var DISTANCE_FOR_DRAG_SQUARED = 25; // the minimum mouse move distance to treat it as drag event
	var MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button
	var MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button
	var DragDropHelper = (function () {
	    function DragDropHelper(params) {
	        this._selection = params.selection;
	        this._dragEnterCounts = {};
	        this._activeTargets = {};
	        this._events = new Utilities_1.EventGroup(this);
	        // clear drag data when mouse up, use capture event to ensure it will be run
	        this._events.on(document.body, 'mouseup', this._onMouseUp.bind(this), true);
	        this._events.on(document, 'mouseup', this._onDocumentMouseUp.bind(this), true);
	    }
	    DragDropHelper.prototype.dispose = function () {
	        this._events.dispose();
	    };
	    DragDropHelper.prototype.subscribe = function (root, events, dragDropOptions) {
	        var _this = this;
	        if (dragDropOptions && root) {
	            var key_1 = dragDropOptions.key, eventMap = dragDropOptions.eventMap, context_1 = dragDropOptions.context, updateDropState_1 = dragDropOptions.updateDropState;
	            var dragDropTarget = { root: root, options: dragDropOptions };
	            var isDraggable = this._isDraggable(dragDropTarget);
	            var isDroppable = this._isDroppable(dragDropTarget);
	            if (isDraggable || isDroppable) {
	                this._activeTargets[key_1] = dragDropTarget;
	                if (eventMap) {
	                    for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {
	                        var event_1 = eventMap_1[_i];
	                        this._events.on(root, event_1.eventName, event_1.callback.bind(null, context_1));
	                    }
	                }
	            }
	            if (isDroppable) {
	                this._dragEnterCounts[key_1] = 0;
	                // dragenter and dragleave will be fired when hover to the child element
	                // but we only want to change state when enter or leave the current element
	                // use the count to ensure it.
	                events.onAll(root, {
	                    'dragenter': function (event) {
	                        event.preventDefault(); // needed for IE
	                        if (!event.isHandled) {
	                            event.isHandled = true;
	                            _this._dragEnterCounts[key_1]++;
	                            if (_this._dragEnterCounts[key_1] === 1) {
	                                updateDropState_1(true /* isDropping */, event);
	                            }
	                        }
	                    },
	                    'dragleave': function (event) {
	                        if (!event.isHandled) {
	                            event.isHandled = true;
	                            _this._dragEnterCounts[key_1]--;
	                            if (_this._dragEnterCounts[key_1] === 0) {
	                                updateDropState_1(false /* isDropping */, event);
	                            }
	                        }
	                    },
	                    'dragend': function (event) {
	                        _this._dragEnterCounts[key_1] = 0;
	                        updateDropState_1(false /* isDropping */, event);
	                    },
	                    'drop': function (event) {
	                        _this._dragEnterCounts[key_1] = 0;
	                        updateDropState_1(false /* isDropping */, event);
	                    }
	                });
	            }
	            if (isDraggable) {
	                events.on(root, 'mousedown', this._onMouseDown.bind(this, dragDropTarget));
	            }
	        }
	    };
	    DragDropHelper.prototype.unsubscribe = function (root, key) {
	        delete this._activeTargets[key];
	        this._events.off(root);
	    };
	    /**
	     * clear drag data when mouse up on body
	     */
	    DragDropHelper.prototype._onMouseUp = function (event) {
	        this._isDragging = false;
	        if (this._dragData) {
	            for (var key in this._activeTargets) {
	                if (this._activeTargets.hasOwnProperty(key)) {
	                    var target = this._activeTargets[key];
	                    if (target && target.root) {
	                        this._events.off(target.root, 'mousemove');
	                        this._events.off(target.root, 'mouseleave');
	                    }
	                }
	            }
	            if (this._dragData.dropTarget) {
	                // raise dargleave event to let dropTarget know it need to remove dropping style
	                Utilities_1.EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');
	            }
	        }
	        this._dragData = null;
	    };
	    /**
	     * clear drag data when mouse up outside of the document
	     */
	    DragDropHelper.prototype._onDocumentMouseUp = function (event) {
	        if (event.target === document.documentElement) {
	            this._onMouseUp(event);
	        }
	    };
	    /**
	     * when mouse move over a new drop target while dragging some items,
	     * fire dragleave on the old target and fire dragenter to the new target
	     * The target will handle style change on dragenter and dragleave events.
	     */
	    DragDropHelper.prototype._onMouseMove = function (target, event) {
	        var 
	        // use buttons property here since ev.button in some edge case is not updating well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        _a = event.buttons, 
	        // use buttons property here since ev.button in some edge case is not updating well during the move.
	        // but firefox doesn't support it, so we set the default value when it is not defined.
	        buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;
	        if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {
	            // cancel mouse down event and return early when the primary button is not pressed
	            this._onMouseUp(event);
	            return;
	        }
	        var root = target.root, options = target.options;
	        if (this._isDragging) {
	            if (this._isDroppable(target)) {
	                // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into
	                // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the
	                // outer target too, and we need to prevent the outer one from taking over.
	                // So, check if the last dropTarget is not a child of the current.
	                if (this._dragData.dropTarget &&
	                    this._dragData.dropTarget.options.key !== options.key &&
	                    !this._isChild(root, this._dragData.dropTarget.root)) {
	                    Utilities_1.EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');
	                    this._dragData.dropTarget = null;
	                }
	                if (!this._dragData.dropTarget) {
	                    Utilities_1.EventGroup.raise(root, 'dragenter');
	                    this._dragData.dropTarget = target;
	                }
	            }
	        }
	        else if (this._dragData) {
	            if (this._isDraggable(target)) {
	                var xDiff = this._dragData.clientX - event.clientX;
	                var yDiff = this._dragData.clientY - event.clientY;
	                if (xDiff * xDiff + yDiff * yDiff >= DISTANCE_FOR_DRAG_SQUARED) {
	                    if (this._dragData.dragTarget &&
	                        this._selection.isIndexSelected(options.selectionIndex)) {
	                        this._isDragging = true;
	                        if (options.onDragStart) {
	                            options.onDragStart(options.context.data, options.context.index, this._selection.getSelection(), event);
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * when mouse leave a target while dragging some items, fire dragleave to the target
	     */
	    DragDropHelper.prototype._onMouseLeave = function (target, event) {
	        if (this._isDragging) {
	            if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.options.key === target.options.key) {
	                Utilities_1.EventGroup.raise(target.root, 'dragleave');
	                this._dragData.dropTarget = null;
	            }
	        }
	    };
	    /**
	     * when mouse down on a draggable item, we start to track dragdata.
	     */
	    DragDropHelper.prototype._onMouseDown = function (target, event) {
	        if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {
	            // Ignore anything except the primary button.
	            return;
	        }
	        if (this._isDraggable(target)) {
	            this._dragData = {
	                clientX: event.clientX,
	                clientY: event.clientY,
	                eventTarget: event.target,
	                dragTarget: target
	            };
	            for (var key in this._activeTargets) {
	                if (this._activeTargets.hasOwnProperty(key)) {
	                    var activeTarget = this._activeTargets[key];
	                    if (activeTarget && activeTarget.root) {
	                        this._events.on(activeTarget.root, 'mousemove', this._onMouseMove.bind(this, activeTarget));
	                        this._events.on(activeTarget.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget));
	                    }
	                }
	            }
	        }
	        else {
	            this._dragData = null;
	        }
	    };
	    /**
	     * determine whether the child target is a descendant of the parent
	     */
	    DragDropHelper.prototype._isChild = function (parent, child) {
	        var parentElement = ReactDOM.findDOMNode(parent);
	        var childElement = ReactDOM.findDOMNode(child);
	        while (childElement && childElement.parentElement) {
	            if (childElement.parentElement === parentElement) {
	                return true;
	            }
	            childElement = childElement.parentElement;
	        }
	        return false;
	    };
	    DragDropHelper.prototype._isDraggable = function (target) {
	        var options = target.options;
	        return options.canDrag && options.canDrag(options.context.data);
	    };
	    DragDropHelper.prototype._isDroppable = function (target) {
	        // TODO: take the drag item into consideration to prevent dragging an item into the same group
	        var options = target.options;
	        var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : null;
	        return options.canDrop && options.canDrop(options.context, dragContext);
	    };
	    return DragDropHelper;
	}());
	exports.DragDropHelper = DragDropHelper;
	


/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable */
	var load_themed_styles_1 = __webpack_require__(385);
	var styles = {};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;
	load_themed_styles_1.loadStyles([{ "rawString": ".ms-DetailsList{position:relative;font-size:12px}.ms-DetailsList BUTTON{font-family:inherit;background-color:transparent}.ms-DetailsList>.ms-FocusZone{display:inline-block;vertical-align:top;min-width:1px;min-height:1px}.ms-DetailsList.is-horizontalConstrained{overflow-x:auto;overflow-y:visible;-webkit-overflow-scrolling:touch}.ms-DetailsList-cell{word-break:break-word}.ms-DetailsList .ms-List-cell{min-height:38px}" }]);
	/* tslint:enable */ 
	


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(502);
	var styles = {
	    container: 'container_ac564998',
	    manifestListContainer: 'manifestListContainer_ac564998',
	    manifestDetailsContainer: 'manifestDetailsContainer_ac564998',
	    noManifestSelectedContainer: 'noManifestSelectedContainer_ac564998',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(503);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_ac564998{height:100%}.manifestListContainer_ac564998{border-right:solid 2px gray;height:100%;width:500px;overflow-y:auto;overflow-x:hidden;float:left}.manifestDetailsContainer_ac564998{height:100%;padding:5px;overflow-x:hidden;overflow-y:auto}.noManifestSelectedContainer_ac564998{text-align:center;position:relative;font-size:30px;color:gray;display:table;width:100%;height:calc(100% - 10px);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.noManifestSelectedContainer_ac564998>div{display:table-cell;text-align:center;vertical-align:middle}", ""]);
	
	// exports


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var strings =  false
	    ? require('../../../../resx-strings/en-us.json')
	    : __webpack_require__(382);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (strings['_sovI4qDAUPMnD4jg3Vsyfg'] || {});


/***/ },
/* 505 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var sp_core_library_1 = __webpack_require__(46);
	var PerformanceDisplay_module_scss_1 = __webpack_require__(506);
	var PerformanceGraph_1 = __webpack_require__(509);
	var PerformanceHeader_1 = __webpack_require__(521);
	var PerformanceDisplayStateProvider_1 = __webpack_require__(526);
	var PerformanceLogger_1 = __webpack_require__(370);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var PerformanceDisplay = (function (_super) {
	    __extends(PerformanceDisplay, _super);
	    function PerformanceDisplay() {
	        var _this = _super.call(this) || this;
	        _this._setState = function () {
	            _this.setState(PerformanceDisplayStateProvider_1.getState());
	        };
	        _this.state = PerformanceDisplayStateProvider_1.getState();
	        return _this;
	    }
	    PerformanceDisplay.prototype.componentDidMount = function () {
	        PerformanceLogger_1.default.addListener(this._setState);
	    };
	    PerformanceDisplay.prototype.componentWillUnmount = function () {
	        PerformanceLogger_1.default.removeListener(this._setState);
	    };
	    PerformanceDisplay.prototype.render = function () {
	        if (this.state.errorMessage) {
	            var errorMessageClass = [PerformanceDisplay_module_scss_1.default.errorMessage, PerformanceDisplay_module_scss_1.default.msFontColorRedDark].join(' ');
	            return (React.createElement("div", { className: errorMessageClass },
	                PerformanceDisplay_resx_1.default.GeneralErrorMessage,
	                React.createElement("br", null),
	                sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.ErrorMessagePrefix, this.state.errorMessage)));
	        }
	        else {
	            return (React.createElement("div", { className: PerformanceDisplay_module_scss_1.default.performanceDisplayContainer },
	                React.createElement(PerformanceHeader_1.default, { perfItems: this.state.perfItems, overallDuration: this.state.eupl }),
	                React.createElement("div", { className: PerformanceDisplay_module_scss_1.default.graphContainer },
	                    React.createElement(PerformanceGraph_1.default, { perfItems: this.state.perfItems, startTime: this.state.startTime, overallDuration: this.state.eupl }))));
	        }
	    };
	    return PerformanceDisplay;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerformanceDisplay;


/***/ },
/* 506 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(507);
	var styles = {
	    performanceDisplayContainer: 'performanceDisplayContainer_a0bf0116',
	    graphContainer: 'graphContainer_a0bf0116',
	    errorMessage: 'errorMessage_a0bf0116',
	    msFontColorRedDark: 'msFontColorRedDark_a0bf0116',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 507 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(508);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 508 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".performanceDisplayContainer_a0bf0116{position:absolute;width:100%;height:100%;overflow-y:scroll}.graphContainer_a0bf0116{float:left;width:calc(100% - 1em);border:1px solid}.errorMessage_a0bf0116{text-align:center;position:relative;top:50%;font-size:25px}.msFontColorRedDark_a0bf0116{color:#A80000}", ""]);
	
	// exports


/***/ },
/* 509 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var PerformanceGraph_module_scss_1 = __webpack_require__(510);
	var PerformanceGraphItem_1 = __webpack_require__(513);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var PerformanceGraph = (function (_super) {
	    __extends(PerformanceGraph, _super);
	    function PerformanceGraph(props) {
	        var _this = _super.call(this, props) || this;
	        _this._scale = Math.ceil(_this.props.overallDuration / 100) * 100;
	        return _this;
	    }
	    PerformanceGraph.prototype.render = function () {
	        var _this = this;
	        var graphBars = [];
	        this.props.perfItems.map(function (item) {
	            graphBars.push(React.createElement(PerformanceGraphItem_1.default, { key: item.id, perfItem: item, startTime: _this.props.startTime, overallDuration: _this._scale }));
	        });
	        var delimiters = [];
	        for (var i = 1; i <= 10; i++) {
	            delimiters.push(React.createElement("th", { key: i, className: PerformanceGraph_module_scss_1.default.thDelimiter }, i * (this._scale / 10)));
	        }
	        var nameStyle = [
	            PerformanceGraph_module_scss_1.default.tableRowPerfList,
	            PerformanceGraph_module_scss_1.default.tableRowRightLight,
	            PerformanceGraph_module_scss_1.default.tableRowName
	        ].join(' ');
	        var durationStyle = [PerformanceGraph_module_scss_1.default.tableRowPerfList, PerformanceGraph_module_scss_1.default.tableRowDuration].join(' ');
	        return (React.createElement("div", { className: PerformanceGraph_module_scss_1.default.container },
	            React.createElement("table", { className: PerformanceGraph_module_scss_1.default.tableDelimiter },
	                React.createElement("thead", null,
	                    React.createElement("tr", null,
	                        React.createElement("th", { className: nameStyle }, PerformanceDisplay_resx_1.default.ItemsColumnHeader),
	                        React.createElement("th", { className: durationStyle }, PerformanceDisplay_resx_1.default.DurationColumnHeader),
	                        delimiters)),
	                React.createElement("tbody", null, graphBars))));
	    };
	    return PerformanceGraph;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerformanceGraph;


/***/ },
/* 510 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(511);
	var styles = {
	    container: 'container_69a8060a',
	    tableDelimiter: 'tableDelimiter_69a8060a',
	    thDelimiter: 'thDelimiter_69a8060a',
	    tableRowPerfList: 'tableRowPerfList_69a8060a',
	    tableRowRightLight: 'tableRowRightLight_69a8060a',
	    tableRowName: 'tableRowName_69a8060a',
	    tableRowDuration: 'tableRowDuration_69a8060a',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(512);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_69a8060a{display:block;height:100%;width:100%}.tableDelimiter_69a8060a{position:relative;float:left;width:100%;border-spacing:0;z-index:1}.thDelimiter_69a8060a{height:100%;padding:5px;border:0;border-right:1px solid #C8C8C8;border-bottom:1px solid #767676;width:10%;text-align:right;vertical-align:text-top;font-weight:400;font-size:small;position:relative}.tableRowPerfList_69a8060a{border:1px solid #767676;padding:5px;height:25px;box-sizing:border-box}.tableRowRightLight_69a8060a{border-right:1px solid #C8C8C8}.tableRowName_69a8060a{min-width:250px;max-width:250px}.tableRowDuration_69a8060a{min-width:70px;max-width:70px}", ""]);
	
	// exports


/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var sp_core_library_1 = __webpack_require__(46);
	var PerformanceGraphItem_module_scss_1 = __webpack_require__(514);
	var PerformanceLegend_module_scss_1 = __webpack_require__(517);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var PerformanceGraphItem = (function (_super) {
	    __extends(PerformanceGraphItem, _super);
	    function PerformanceGraphItem() {
	        var _this = _super.call(this) || this;
	        _this._drawGraphBar = _this._drawGraphBar.bind(_this);
	        return _this;
	    }
	    PerformanceGraphItem.prototype.render = function () {
	        var nameStyle = [
	            PerformanceGraphItem_module_scss_1.default.tableRowPerfList,
	            PerformanceGraphItem_module_scss_1.default.tableRowBottomLight,
	            PerformanceGraphItem_module_scss_1.default.tableRowRightLight
	        ].join(' ');
	        var durationStyle = [PerformanceGraphItem_module_scss_1.default.tableRowPerfList, PerformanceGraphItem_module_scss_1.default.tableRowBottomLight].join(' ');
	        var graphBar = [];
	        var perfItem = this.props.perfItem;
	        if (perfItem.breakdown) {
	            graphBar.push(this._drawGraphBar(perfItem.breakdown.render.startVal, perfItem.breakdown.render.duration, PerformanceLegend_module_scss_1.default.msBlueMid, PerformanceDisplay_resx_1.default.RenderTimeLegendLabel));
	            graphBar.push(this._drawGraphBar(perfItem.breakdown.init.startVal, perfItem.breakdown.init.duration, PerformanceLegend_module_scss_1.default.msPurpleLight, PerformanceDisplay_resx_1.default.InitializationTimeLabel));
	            graphBar.push(this._drawGraphBar(perfItem.breakdown.modulesLoaded.startVal, perfItem.breakdown.modulesLoaded.duration, PerformanceLegend_module_scss_1.default.msBlue, PerformanceDisplay_resx_1.default.ModuleLoadingTimeLabel));
	            for (var _i = 0, _a = perfItem.breakdown.dataFetch; _i < _a.length; _i++) {
	                var apiCall = _a[_i];
	                graphBar.push(this._drawGraphBar(apiCall.startVal, apiCall.duration, PerformanceLegend_module_scss_1.default.msTealLight, PerformanceDisplay_resx_1.default.DataFetchTimeLabel));
	            }
	        }
	        else {
	            graphBar.push(this._drawGraphBar(perfItem.startVal, perfItem.duration, PerformanceLegend_module_scss_1.default.msThemeTertiary, perfItem.name));
	        }
	        return (React.createElement("tr", null,
	            React.createElement("td", { className: nameStyle }, this.props.perfItem.name),
	            React.createElement("td", { className: durationStyle }, sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this.props.perfItem.duration)),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }, graphBar),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter }),
	            React.createElement("td", { className: PerformanceGraphItem_module_scss_1.default.tdDelimiter })));
	    };
	    PerformanceGraphItem.prototype._drawGraphBar = function (startVal, duration, barColor, tooltip) {
	        var leftVal = ((startVal - this.props.startTime) / this.props.overallDuration);
	        var widthVal = (duration / this.props.overallDuration);
	        var nameTableWidth = '320px';
	        var barStyling = {
	            left: "calc(" + leftVal + " * (100% - " + nameTableWidth + ") + " + nameTableWidth + ")",
	            width: "calc(" + widthVal + " * (100% - " + nameTableWidth + "))"
	        };
	        var barClass = [PerformanceGraphItem_module_scss_1.default.bar, barColor].join(' ');
	        return React.createElement("div", { key: "" + leftVal + widthVal, className: barClass, style: barStyling, title: tooltip });
	    };
	    return PerformanceGraphItem;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerformanceGraphItem;


/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(515);
	var styles = {
	    bar: 'bar_4d8fb335',
	    tableRowPerfList: 'tableRowPerfList_4d8fb335',
	    tableRowBottomLight: 'tableRowBottomLight_4d8fb335',
	    tableRowRightLight: 'tableRowRightLight_4d8fb335',
	    tdDelimiter: 'tdDelimiter_4d8fb335',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(516);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".bar_4d8fb335{height:13px;margin:0;margin-top:-6px;box-sizing:border-box;position:absolute}.tableRowPerfList_4d8fb335{border:1px solid #767676;padding:5px;height:25px;box-sizing:border-box}.tableRowBottomLight_4d8fb335{border-bottom:1px solid #C8C8C8}.tableRowRightLight_4d8fb335{border-right:1px solid #C8C8C8}.tdDelimiter_4d8fb335{width:10%;border-spacing:0;z-index:1;border:1px solid #C8C8C8;border-top:0;border-left:0}", ""]);
	
	// exports


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(518);
	var styles = {
	    legend: 'legend_b7b8bd19',
	    legendCells: 'legendCells_b7b8bd19',
	    colorSquare: 'colorSquare_b7b8bd19',
	    msBlue: 'msBlue_b7b8bd19',
	    msBlueMid: 'msBlueMid_b7b8bd19',
	    msPurpleLight: 'msPurpleLight_b7b8bd19',
	    msTealLight: 'msTealLight_b7b8bd19',
	    msThemeTertiary: 'msThemeTertiary_b7b8bd19',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(519);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".legend_b7b8bd19{border:1px solid #767676;border-collapse:collapse;position:relative;margin:auto;margin-bottom:10px}.legendCells_b7b8bd19{border:1px solid #767676;padding:2px 10px}.colorSquare_b7b8bd19{height:13px;width:13px;float:left;position:relative;margin-right:7px;top:3px}.msBlue_b7b8bd19{background-color:#0078d7}.msBlueMid_b7b8bd19{background-color:#00188F}.msPurpleLight_b7b8bd19{background-color:#B4A0FF}.msTealLight_b7b8bd19{background-color:#00B294}.msThemeTertiary_b7b8bd19{background-color:#71AFE5}", ""]);
	
	// exports


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var strings =  false
	    ? require('../../../../resx-strings/en-us.json')
	    : __webpack_require__(382);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (strings['_g7G0QHJ5bQYlxe+lk+DcxA'] || {});


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var sp_core_library_1 = __webpack_require__(46);
	var PerformanceLegend_1 = __webpack_require__(522);
	var PerformanceHeader_module_scss_1 = __webpack_require__(523);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var PerformanceHeader = (function (_super) {
	    __extends(PerformanceHeader, _super);
	    function PerformanceHeader() {
	        var _this = _super.call(this) || this;
	        _this._serverResponse = 0;
	        _this._appStart = 0;
	        _this._renderPageDuration = 0;
	        _this._renderWebparts = 0;
	        _this._hasWebParts = false;
	        _this._getPerfTimings = _this._getPerfTimings.bind(_this);
	        return _this;
	    }
	    PerformanceHeader.prototype.render = function () {
	        this._getPerfTimings();
	        var legend = undefined;
	        if (this._hasWebParts) {
	            legend = React.createElement(PerformanceLegend_1.default, null);
	        }
	        var tableStyle = [PerformanceHeader_module_scss_1.default.headerTable, PerformanceHeader_module_scss_1.default.msThemeLighter].join(' ');
	        return (React.createElement("div", null,
	            React.createElement("p", { className: PerformanceHeader_module_scss_1.default.hint }, PerformanceDisplay_resx_1.default.PerformanceDataHint),
	            React.createElement("table", { className: tableStyle },
	                React.createElement("thead", null,
	                    React.createElement("tr", null,
	                        React.createElement("th", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, PerformanceDisplay_resx_1.default.ServerResponseLabel),
	                        React.createElement("th", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, PerformanceDisplay_resx_1.default.AppLoadLabel),
	                        React.createElement("th", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, PerformanceDisplay_resx_1.default.PageRenderLabel),
	                        React.createElement("th", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, PerformanceDisplay_resx_1.default.RenderWebPartsLabel),
	                        React.createElement("th", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, PerformanceDisplay_resx_1.default.TotalRenderTimeLabel))),
	                React.createElement("tbody", null,
	                    React.createElement("tr", null,
	                        React.createElement("td", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this._serverResponse)),
	                        React.createElement("td", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this._appStart)),
	                        React.createElement("td", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this._renderPageDuration)),
	                        React.createElement("td", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, this._hasWebParts
	                            ? sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this._renderWebparts)
	                            : PerformanceDisplay_resx_1.default.NAPlaceholder),
	                        React.createElement("td", { className: PerformanceHeader_module_scss_1.default.headerTableRows }, sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.MillisecondsUnitLabel, this.props.overallDuration))))),
	            React.createElement("div", null, legend)));
	    };
	    PerformanceHeader.prototype._getPerfTimings = function () {
	        var renderPageStart = Infinity;
	        var renderPageEnd = 0;
	        var webPartStart = Infinity;
	        var webPartEnd = 0;
	        this._hasWebParts = false;
	        for (var _i = 0, _a = this.props.perfItems; _i < _a.length; _i++) {
	            var item = _a[_i];
	            if (item.id === 'w3cResponseEnd') {
	                this._serverResponse = item.duration;
	            }
	            else if (item.id === 'appStart') {
	                this._appStart = item.duration;
	            }
	            else if ((item.id).indexOf('Component') > -1) {
	                if (item.startVal < renderPageStart) {
	                    renderPageStart = item.startVal;
	                }
	                if ((item.duration + item.startVal) > (renderPageEnd)) {
	                    renderPageEnd = item.duration + item.startVal;
	                }
	            }
	            else if ((item.id).indexOf('WebPart') > -1) {
	                this._hasWebParts = true;
	                if (item.startVal < webPartStart) {
	                    webPartStart = item.startVal;
	                }
	                if ((item.duration + item.startVal) > (webPartEnd)) {
	                    webPartEnd = item.duration + item.startVal;
	                }
	            }
	        }
	        this._renderPageDuration = renderPageEnd - renderPageStart;
	        this._renderWebparts = webPartEnd - webPartStart;
	    };
	    return PerformanceHeader;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerformanceHeader;


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var PerformanceLegend_module_scss_1 = __webpack_require__(517);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	var PerformanceLegend = (function (_super) {
	    __extends(PerformanceLegend, _super);
	    function PerformanceLegend() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    PerformanceLegend.prototype.render = function () {
	        var legendBlue = [PerformanceLegend_module_scss_1.default.colorSquare, PerformanceLegend_module_scss_1.default.msBlue].join(' ');
	        var legendPurple = [PerformanceLegend_module_scss_1.default.colorSquare, PerformanceLegend_module_scss_1.default.msPurpleLight].join(' ');
	        var legendDarkBlue = [PerformanceLegend_module_scss_1.default.colorSquare, PerformanceLegend_module_scss_1.default.msBlueMid].join(' ');
	        var legendTeal = [PerformanceLegend_module_scss_1.default.colorSquare, PerformanceLegend_module_scss_1.default.msTealLight].join(' ');
	        return (React.createElement("table", { className: PerformanceLegend_module_scss_1.default.legend },
	            React.createElement("tbody", null,
	                React.createElement("tr", null,
	                    React.createElement("td", { className: PerformanceLegend_module_scss_1.default.legendCells },
	                        React.createElement("div", { className: legendBlue }),
	                        React.createElement("span", null, PerformanceDisplay_resx_1.default.ModulesLoadedLegendLabel)),
	                    React.createElement("td", { className: PerformanceLegend_module_scss_1.default.legendCells },
	                        React.createElement("div", { className: legendPurple }),
	                        React.createElement("span", null, PerformanceDisplay_resx_1.default.InitializationLegendLabel)),
	                    React.createElement("td", { className: PerformanceLegend_module_scss_1.default.legendCells },
	                        React.createElement("div", { className: legendDarkBlue }),
	                        React.createElement("span", null, PerformanceDisplay_resx_1.default.RenderTimeLegendLabel)),
	                    React.createElement("td", { className: PerformanceLegend_module_scss_1.default.legendCells },
	                        React.createElement("div", { className: legendTeal }),
	                        React.createElement("span", null, PerformanceDisplay_resx_1.default.DataFetchLegendLabel))))));
	    };
	    return PerformanceLegend;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = PerformanceLegend;


/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(524);
	var styles = {
	    headerTable: 'headerTable_5131234b',
	    headerTableRows: 'headerTableRows_5131234b',
	    hint: 'hint_5131234b',
	    infoIcon: 'infoIcon_5131234b',
	    msThemeLighter: 'msThemeLighter_5131234b',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(525);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".headerTable_5131234b{border:1px solid #767676;border-right:0;width:calc(100% - 1em);margin-bottom:10px;margin-top:5px;border-collapse:collapse}.headerTableRows_5131234b{text-align:center;border-right:1px solid #767676;border-bottom:1px solid #767676}.hint_5131234b{font-size:12px;margin:5px}.infoIcon_5131234b{margin-right:5px}.msThemeLighter_5131234b{background-color:#DEECF9}", ""]);
	
	// exports


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var sp_core_library_1 = __webpack_require__(46);
	var PerformanceLogger_1 = __webpack_require__(370);
	var PerformanceDisplay_resx_1 = __webpack_require__(520);
	function getState() {
	    var perfItems = [];
	    var toReturn = {
	        perfItems: perfItems,
	        startTime: 0,
	        eupl: 0
	    };
	    try {
	        var data = PerformanceLogger_1.default.getPerformanceData();
	        if (!data || (data && !data.W3cNavigationStart) || (data && !data.EUPL)) {
	            toReturn.errorMessage = PerformanceDisplay_resx_1.default.ErrorAccessingPerfDataErrorMessage;
	            console.debug(toReturn.errorMessage); 
	            return toReturn;
	        }
	        toReturn.startTime = data.W3cNavigationStart;
	        toReturn.eupl = data.EUPL;
	        var euplBreakdown = void 0;
	        try {
	            euplBreakdown = JSON.parse(data.EUPLBreakdown);
	        }
	        catch (error) { }
	        if (!euplBreakdown) {
	            toReturn.errorMessage = PerformanceDisplay_resx_1.default.ErrorParsingPercievedLatencyErrorMessage;
	            console.debug(toReturn.errorMessage); 
	            return toReturn;
	        }
	        var apiCallsData = void 0;
	        try {
	            apiCallsData = JSON.parse(data.APICalls);
	        }
	        catch (error) { }
	        if (!apiCallsData) {
	            toReturn.errorMessage = PerformanceDisplay_resx_1.default.ErrorParsingApiDataErrorMessage;
	            console.debug(toReturn.errorMessage); 
	            return toReturn;
	        }
	        var redirectPerf = void 0;
	        try {
	            redirectPerf = window.performance.timing;
	        }
	        catch (error) { }
	        if (!redirectPerf) {
	            toReturn.errorMessage = PerformanceDisplay_resx_1.default.ErrorAccessingRedirectDataErrorMessage;
	            console.debug(toReturn.errorMessage); 
	            return toReturn;
	        }
	        if (redirectPerf.redirectEnd) {
	            perfItems.push({
	                id: 'RedirectResponse',
	                name: PerformanceDisplay_resx_1.default.RedirectResponseLabel,
	                startVal: redirectPerf.redirectStart,
	                duration: (redirectPerf.redirectEnd - redirectPerf.redirectStart),
	                breakdown: undefined
	            });
	        }
	        perfItems.push({
	            id: 'w3cResponseEnd',
	            name: PerformanceDisplay_resx_1.default.ServerResponseLabel,
	            startVal: data.W3cNavigationStart,
	            duration: euplBreakdown.w3cResponseEnd,
	            breakdown: undefined
	        });
	        perfItems.push({
	            id: 'appStart',
	            name: PerformanceDisplay_resx_1.default.ApplicationInitializationLabel,
	            startVal: data.W3cResponseEnd,
	            duration: euplBreakdown.appStart,
	            breakdown: undefined
	        });
	        perfItems.push({
	            id: 'PageComponent',
	            name: PerformanceDisplay_resx_1.default.PageRenderLabel,
	            startVal: euplBreakdown['PageComponent.start'],
	            duration: data.Control3RenderTime -
	                (euplBreakdown['PageComponent.start'] - data.W3cNavigationStart),
	            breakdown: undefined
	        });
	        perfItems.push({
	            id: 'LeftNavComponent',
	            name: PerformanceDisplay_resx_1.default.LeftNavRenderLabel,
	            startVal: euplBreakdown['LeftNavComponent.start'],
	            duration: data.Control1RenderTime -
	                (euplBreakdown['LeftNavComponent.start'] - data.W3cNavigationStart),
	            breakdown: undefined
	        });
	        perfItems.push({
	            id: 'CanvasComponent',
	            name: PerformanceDisplay_resx_1.default.CanvasRenderLabel,
	            startVal: euplBreakdown['CanvasComponent.start'],
	            duration: data.Control2RenderTime -
	                (euplBreakdown['CanvasComponent.start'] - data.W3cNavigationStart),
	            breakdown: undefined
	        });
	        var apiCalls = {};
	        var endVals = {};
	        for (var _i = 0, apiCallsData_1 = apiCallsData; _i < apiCallsData_1.length; _i++) {
	            var apiCall = apiCallsData_1[_i];
	            if (apiCall.name && apiCall.name.indexOf('WebPart') > -1) {
	                if (!apiCalls[apiCall.name]) {
	                    apiCalls[apiCall.name] = [];
	                    endVals[apiCall.name] = 0;
	                }
	                apiCalls[apiCall.name].push({
	                    startVal: Date.parse(apiCall.startTime),
	                    duration: +apiCall.duration
	                });
	                endVals[apiCall.name] = Math.max(Date.parse(apiCall.startTime) + +apiCall.duration, endVals[apiCall.name]);
	            }
	        }
	        for (var webPart = data.Control4Id, i = 4; webPart; i++, webPart = data["Control" + i + "Id"]) {
	            var renderDuration = data["Control" + i + "RenderTime"] -
	                (euplBreakdown[webPart + ".start"] - data.W3cNavigationStart);
	            var wpBreakdown = {
	                dataFetch: apiCalls[webPart] || [],
	                init: {
	                    startVal: euplBreakdown[webPart + ".start"],
	                    duration: euplBreakdown[webPart + ".init"]
	                },
	                modulesLoaded: {
	                    startVal: euplBreakdown[webPart + ".start"],
	                    duration: euplBreakdown[webPart + ".modulesLoaded"]
	                },
	                render: {
	                    startVal: euplBreakdown[webPart + ".start"],
	                    duration: renderDuration
	                }
	            };
	            perfItems.push({
	                id: webPart,
	                name: "" + _getReadableWebpartName(webPart.replace('Load.', '')),
	                startVal: euplBreakdown[webPart + ".start"],
	                duration: Math.max(renderDuration, (endVals[webPart] || 0) - euplBreakdown[webPart + ".start"]),
	                breakdown: wpBreakdown
	            });
	        }
	        return toReturn;
	    }
	    catch (error) {
	        toReturn.errorMessage = sp_core_library_1.Text.format(PerformanceDisplay_resx_1.default.UnkownPerformanceDataErrorMessage, error);
	        console.debug(toReturn.errorMessage); 
	        return toReturn;
	    }
	}
	exports.getState = getState;
	function _getReadableWebpartName(id) {
	    try {
	        var readableWebPartName = id.split('.')[1];
	        return readableWebPartName;
	    }
	    catch (error) {
	        return PerformanceDisplay_resx_1.default.DefaultWebPartName;
	    }
	}


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var TraceDisplay_module_scss_1 = __webpack_require__(528);
	var TraceDisplayStore_1 = __webpack_require__(531);
	var TraceList_1 = __webpack_require__(533);
	var TraceDisplay = (function (_super) {
	    __extends(TraceDisplay, _super);
	    function TraceDisplay() {
	        var _this = _super.call(this) || this;
	        _this._setState = function () {
	            _this.setState({
	                filter: TraceDisplayStore_1.default.currentFilter
	            });
	        };
	        _this.state = {
	            filter: TraceDisplayStore_1.default.currentFilter
	        };
	        return _this;
	    }
	    TraceDisplay.prototype.componentDidMount = function () {
	        TraceDisplayStore_1.default.addListener(this._setState);
	    };
	    TraceDisplay.prototype.componentWillUnmount = function () {
	        TraceDisplayStore_1.default.removeListener(this._setState);
	    };
	    TraceDisplay.prototype.render = function () {
	        return (React.createElement("div", { className: TraceDisplay_module_scss_1.default.container },
	            React.createElement("div", { className: TraceDisplay_module_scss_1.default.traceListContainer },
	                React.createElement(TraceList_1.default, { allTraces: TraceDisplayStore_1.default.traces, filters: this.state.filter }))));
	    };
	    return TraceDisplay;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TraceDisplay;


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(529);
	var styles = {
	    container: 'container_28344716',
	    traceListContainer: 'traceListContainer_28344716',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(530);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_28344716{height:100%}.traceListContainer_28344716{height:100%;width:100%;float:left}", ""]);
	
	// exports


/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var LogManager_1 = __webpack_require__(367);
	var BaseStore_1 = __webpack_require__(395);
	var TraceDisplay_resx_1 = __webpack_require__(532);
	var LogLevel;
	(function (LogLevel) {
	    LogLevel[LogLevel["all"] = 0] = "all";
	    LogLevel[LogLevel["verbose"] = 1] = "verbose";
	    LogLevel[LogLevel["info"] = 2] = "info";
	    LogLevel[LogLevel["warning"] = 3] = "warning";
	    LogLevel[LogLevel["error"] = 4] = "error";
	})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
	var TraceDisplayStore = (function (_super) {
	    __extends(TraceDisplayStore, _super);
	    function TraceDisplayStore() {
	        var _this = _super.call(this) || this;
	        _this._filter = {
	            level: { all: true, verbose: true, info: true, warning: true, error: true, none: true },
	            source: { all: true, none: true },
	            scope: { all: true, none: true }
	        };
	        _this._traces = [];
	        return _this;
	    }
	    Object.defineProperty(TraceDisplayStore, "instance", {
	        get: function () {
	            if (!this._instance) {
	                this._instance = new TraceDisplayStore();
	            }
	            return this._instance;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TraceDisplayStore.prototype, "traces", {
	        get: function () {
	            var _this = this;
	            var errorMessage = undefined;
	            var data = LogManager_1.default.events;
	            this._traces = [];
	            if (!data) {
	                errorMessage = TraceDisplay_resx_1.default.ErrorAccessingTraceDataErrorMessage;
	            }
	            else {
	                data.forEach(function (value) {
	                    if (value) {
	                        _this._traces.push(value);
	                    }
	                });
	            }
	            return this._traces;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TraceDisplayStore.prototype, "currentFilter", {
	        get: function () {
	            return this._filter;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TraceDisplayStore.prototype.applyTraceFilter = function (filter) {
	        this._filter = filter;
	        this.emitChange();
	    };
	    return TraceDisplayStore;
	}(BaseStore_1.default));
	exports.TraceDisplayStore = TraceDisplayStore;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TraceDisplayStore.instance;


/***/ },
/* 532 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var strings =  false
	    ? require('../../../../resx-strings/en-us.json')
	    : __webpack_require__(382);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (strings['_gqinlPQb8HZprTeCpwNz2w'] || {});


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var TraceList_module_scss_1 = __webpack_require__(534);
	var TraceDisplayStore_1 = __webpack_require__(531);
	var TraceListHeader_1 = __webpack_require__(537);
	var TraceListItem_1 = __webpack_require__(541);
	var TraceDisplay_resx_1 = __webpack_require__(532);
	var TraceList = (function (_super) {
	    __extends(TraceList, _super);
	    function TraceList(props) {
	        var _this = _super.call(this, props) || this;
	        _this._exportAsCSV = _this._exportAsCSV.bind(_this);
	        return _this;
	    }
	    TraceList.prototype.render = function () {
	        var _this = this;
	        var idCounter = 0;
	        var displayedTraces = [];
	        var levelFilters = this.props.filters.level;
	        var scopeFilters = this.props.filters.scope;
	        var sourceFilters = this.props.filters.source;
	        if (!this.props.allTraces) {
	            return React.createElement("div", null,
	                React.createElement(TraceListHeader_1.default, { filters: this.props.filters }),
	                TraceDisplay_resx_1.default.EmptyTraceData);
	        }
	        this.props.allTraces.forEach(function (trace) {
	            if (levelFilters[TraceDisplayStore_1.LogLevel[trace.level]] === false) {
	                return;
	            }
	            if (trace.scope) {
	                _this._addFilterLabel(trace.scope.id, scopeFilters);
	                if (!scopeFilters[trace.scope.id]) {
	                    return;
	                }
	            }
	            else if (scopeFilters.none === false) {
	                return;
	            }
	            if (trace.source) {
	                _this._addFilterLabel(trace.source, sourceFilters);
	                if (!sourceFilters[trace.source]) {
	                    return;
	                }
	            }
	            displayedTraces.push(React.createElement(TraceListItem_1.default, { key: idCounter, id: idCounter, trace: trace }));
	            idCounter++;
	        });
	        return (React.createElement("div", { className: TraceList_module_scss_1.default.container },
	            React.createElement("button", { onClick: this._exportAsCSV }, TraceDisplay_resx_1.default.ExportCSVButtonLabel),
	            React.createElement(TraceListHeader_1.default, { filters: this.props.filters }),
	            React.createElement("ul", { className: TraceList_module_scss_1.default.traceListItemsContainer }, displayedTraces)));
	    };
	    TraceList.prototype._addFilterLabel = function (filterLabel, multiFilter) {
	        if (filterLabel && !(filterLabel in multiFilter)) {
	            multiFilter[filterLabel] = true;
	        }
	    };
	    TraceList.prototype._exportAsCSV = function () {
	        var tracesLength = this.props.allTraces.length;
	        if (tracesLength === 0) {
	            return;
	        }
	        var header = 'data:text/csv;charset=utf-8,Timestamp,Level,Source,Message\n';
	        var items = this.props.allTraces.map(this._logEventToCSV);
	        var csvContent = header + items.join('\n');
	        var link = document.createElement('a');
	        link.setAttribute('href', encodeURI(csvContent));
	        link.setAttribute('download', 'spfx_trace_logs.csv');
	        document.body.appendChild(link);
	        link.click(); 
	        document.body.removeChild(link);
	    };
	    TraceList.prototype._logEventToCSV = function (logEvent) {
	        var logEventArray = [];
	        logEventArray.push(String(logEvent.timestamp));
	        logEventArray.push(logEvent.level ? TraceDisplayStore_1.LogLevel[logEvent.level] : ' '); 
	        logEventArray.push(logEvent.source);
	        if (logEvent.message) {
	            logEventArray.push(logEvent.message);
	        }
	        else if (logEvent.error) {
	            logEventArray.push(logEvent.error.message);
	        }
	        return logEventArray.join(',');
	    };
	    return TraceList;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TraceList;


/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(535);
	var styles = {
	    container: 'container_4f362c21',
	    traceListItemsContainer: 'traceListItemsContainer_4f362c21',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(536);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, "ul{padding:0}li{display:inline-table}.container_4f362c21{height:100%;padding:0}.traceListItemsContainer_4f362c21{height:80%;padding:0;overflow-y:auto;margin-top:0;margin-bottom:0}", ""]);
	
	// exports


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var TraceListHeader_module_scss_1 = __webpack_require__(538);
	var TraceDisplayStore_1 = __webpack_require__(531);
	var TraceDisplay_resx_1 = __webpack_require__(532);
	var TraceListHeader = (function (_super) {
	    __extends(TraceListHeader, _super);
	    function TraceListHeader(props) {
	        var _this = _super.call(this, props) || this;
	        _this._handleFilterChange = _this._handleFilterChange.bind(_this);
	        _this.state = {
	            filterToggles: {}
	        };
	        return _this;
	    }
	    TraceListHeader.prototype.render = function () {
	        var _this = this;
	        return (React.createElement("ul", { className: TraceListHeader_module_scss_1.default.container },
	            React.createElement("li", { className: TraceListHeader_module_scss_1.default.timestamp }, TraceDisplay_resx_1.default.TimestampHeaderLabel),
	            React.createElement("li", { className: TraceListHeader_module_scss_1.default.level },
	                React.createElement("p", { role: 'button', onClick: function () { return _this._toggleFilterStateForColumn('level'); }, className: TraceListHeader_module_scss_1.default.headerText }, TraceDisplay_resx_1.default.LevelHeaderLabel),
	                React.createElement("button", { onClick: function () { return _this._toggleFilterStateForColumn('level'); }, className: [TraceListHeader_module_scss_1.default.filterButton, 'ms-Icon', 'ms-Icon--Filter'].join(' ') }),
	                React.createElement("div", { className: this._getFilterStyleForColumn('level'), id: 'levelFilterDropdown' }, Object.keys(this.props.filters.level).map(function (id) {
	                    return React.createElement("div", { key: id, className: TraceListHeader_module_scss_1.default.filterRow },
	                        React.createElement("input", { type: 'checkbox', name: 'level '.concat(id), "aria-checked": _this.props.filters.level[id], checked: _this.props.filters.level[id], onChange: _this._handleFilterChange }),
	                        id);
	                }))),
	            React.createElement("li", { className: TraceListHeader_module_scss_1.default.scope },
	                React.createElement("p", { role: 'button', onClick: function () { return _this._toggleFilterStateForColumn('scope'); }, className: TraceListHeader_module_scss_1.default.headerText }, TraceDisplay_resx_1.default.ScopeHeaderLabel),
	                React.createElement("button", { onClick: function () { return _this._toggleFilterStateForColumn('scope'); }, className: [TraceListHeader_module_scss_1.default.filterButton, 'ms-Icon', 'ms-Icon--Filter'].join(' ') }),
	                React.createElement("div", { className: this._getFilterStyleForColumn('scope'), id: 'scopeFilterDropdown' }, Object.keys(this.props.filters.scope).map(function (id) {
	                    return React.createElement("div", { key: id, className: TraceListHeader_module_scss_1.default.filterRow },
	                        React.createElement("input", { type: 'checkbox', name: 'scope '.concat(id), "aria-checked": _this.props.filters.scope[id], checked: _this.props.filters.scope[id], onChange: _this._handleFilterChange }),
	                        id);
	                }))),
	            React.createElement("li", { className: TraceListHeader_module_scss_1.default.source },
	                React.createElement("p", { role: 'button', onClick: function () { return _this._toggleFilterStateForColumn('source'); }, className: TraceListHeader_module_scss_1.default.headerText }, TraceDisplay_resx_1.default.SourceHeaderLabel),
	                React.createElement("button", { onClick: function () { return _this._toggleFilterStateForColumn('source'); }, className: [TraceListHeader_module_scss_1.default.filterButton, 'ms-Icon', 'ms-Icon--Filter'].join(' ') }),
	                React.createElement("div", { className: this._getFilterStyleForColumn('source'), id: 'sourceFilterDropdown' }, Object.keys(this.props.filters.source).map(function (id) {
	                    return React.createElement("div", { key: id, className: TraceListHeader_module_scss_1.default.filterRow },
	                        React.createElement("input", { type: 'checkbox', name: 'source '.concat(id), "aria-checked": _this.props.filters.source[id], checked: _this.props.filters.source[id], onChange: _this._handleFilterChange }),
	                        id);
	                }))),
	            React.createElement("li", { className: TraceListHeader_module_scss_1.default.message }, TraceDisplay_resx_1.default.MessageHeaderLabel)));
	    };
	    TraceListHeader.prototype._getFilterStyleForColumn = function (columnId) {
	        var filterStyle = this.state.filterToggles[columnId]
	            ? TraceListHeader_module_scss_1.default.displayBlock
	            : TraceListHeader_module_scss_1.default.displayNone;
	        return [TraceListHeader_module_scss_1.default.filterOverlay, filterStyle].join(' ');
	    };
	    TraceListHeader.prototype._toggleFilterStateForColumn = function (columnId) {
	        var filterToggles = {};
	        for (var toggle in this.state.filterToggles) {
	            if (this.state.filterToggles.hasOwnProperty(toggle)) {
	                var value = this.state.filterToggles[toggle];
	                filterToggles[toggle] = columnId !== toggle ? !value : value;
	            }
	        }
	        this.setState({ filterToggles: filterToggles });
	    };
	    TraceListHeader.prototype._handleFilterChange = function (event) {
	        var all = 'all';
	        var name = 'name';
	        var eventTargetNameAttribute = event.target.getAttribute(name) || '';
	        var filterDetailsTuple = eventTargetNameAttribute.split(' ');
	        var filterType = filterDetailsTuple[0];
	        var filterSubType = filterDetailsTuple[1];
	        var subfilters = this.props.filters[filterType];
	        if (filterSubType === all) {
	            subfilters[all] = !subfilters[all];
	            Object.keys(subfilters).forEach(function (element, count, array) {
	                subfilters[element] = subfilters[all];
	            });
	        }
	        else {
	            subfilters[all] = false;
	            subfilters[filterSubType] = !subfilters[filterSubType];
	            var allTrue_1 = true;
	            Object.keys(subfilters).forEach(function (key) {
	                if (key !== all && subfilters[key] === false) {
	                    allTrue_1 = false;
	                }
	            });
	            if (allTrue_1) {
	                subfilters[all] = true;
	            }
	        }
	        TraceDisplayStore_1.TraceDisplayStore.instance.applyTraceFilter(this.props.filters);
	    };
	    return TraceListHeader;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TraceListHeader;


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(539);
	var styles = {
	    container: 'container_61f58bcf',
	    displayNone: 'displayNone_61f58bcf',
	    displayBlock: 'displayBlock_61f58bcf',
	    filterRow: 'filterRow_61f58bcf',
	    filterButton: 'filterButton_61f58bcf',
	    filterOverlay: 'filterOverlay_61f58bcf',
	    headerText: 'headerText_61f58bcf',
	    levelFilterOverlay: 'levelFilterOverlay_61f58bcf',
	    level: 'level_61f58bcf',
	    message: 'message_61f58bcf',
	    source: 'source_61f58bcf',
	    scope: 'scope_61f58bcf',
	    timestamp: 'timestamp_61f58bcf',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(540);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_61f58bcf{display:block;margin-top:0;margin-bottom:0}.displayNone_61f58bcf{display:none}.displayBlock_61f58bcf{display:block}.filterRow_61f58bcf{width:100%}.filterButton_61f58bcf{background:0 0;border:none;cursor:pointer;padding:13px 5px;font-size:1.25em;color:#2f4f4f}.filterOverlay_61f58bcf{height:60%;width:20%;clear:left;position:absolute;z-index:200;background:#fff;border:solid;border-color:#696969;border-width:1px;overflow-y:auto}.headerText_61f58bcf{float:left}.levelFilterOverlay_61f58bcf{height:60%;width:10%;clear:left;position:absolute;z-index:200;background:#fff;border:solid;border-color:#696969;border-width:1px;overflow-y:auto}.level_61f58bcf{width:10%}.message_61f58bcf{width:40%}.source_61f58bcf{width:20%}.scope_61f58bcf{width:20%}.timestamp_61f58bcf{width:10%}", ""]);
	
	// exports


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var TraceListItem_module_scss_1 = __webpack_require__(542);
	var TraceDisplayStore_1 = __webpack_require__(531);
	var TraceListItem = (function (_super) {
	    __extends(TraceListItem, _super);
	    function TraceListItem() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TraceListItem.prototype.render = function () {
	        var styleDeclarations;
	        var message;
	        var date = new Date(this.props.trace.timestamp);
	        var calendarDate = [date.getDate(), date.getMonth(), date.getFullYear()];
	        var clockTime = [date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
	        styleDeclarations = [TraceListItem_module_scss_1.default.container];
	        if (this.props.id % 2 === 0) {
	            styleDeclarations.push(TraceListItem_module_scss_1.default.blueBackground);
	        }
	        if (Number(this.props.trace.level) === TraceDisplayStore_1.LogLevel.error) {
	            message = this.props.trace.error ? this.props.trace.error.message : this.props.trace.message;
	            styleDeclarations.push(TraceListItem_module_scss_1.default.redText);
	        }
	        else {
	            message = this.props.trace.message;
	        }
	        return (React.createElement("li", { key: this.props.id, className: styleDeclarations.join(' ') },
	            React.createElement("ul", { className: TraceListItem_module_scss_1.default.itemDetails },
	                React.createElement("li", { className: TraceListItem_module_scss_1.default.timestamp }, [calendarDate.join('/'), clockTime.join(':')].join(' ')),
	                React.createElement("li", { className: TraceListItem_module_scss_1.default[TraceDisplayStore_1.LogLevel[this.props.trace.level]] }, TraceDisplayStore_1.LogLevel[this.props.trace.level]),
	                React.createElement("li", { className: TraceListItem_module_scss_1.default.scope }, this.props.trace.scope ? this.props.trace.scope.id : undefined),
	                React.createElement("li", { className: TraceListItem_module_scss_1.default.source }, this.props.trace.source),
	                React.createElement("li", { className: TraceListItem_module_scss_1.default.message }, message))));
	    };
	    return TraceListItem;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TraceListItem;


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(543);
	var styles = {
	    container: 'container_e70a92d8',
	    blueBackground: 'blueBackground_e70a92d8',
	    itemDetails: 'itemDetails_e70a92d8',
	    verbose: 'verbose_e70a92d8',
	    info: 'info_e70a92d8',
	    warning: 'warning_e70a92d8',
	    error: 'error_e70a92d8',
	    message: 'message_e70a92d8',
	    source: 'source_e70a92d8',
	    scope: 'scope_e70a92d8',
	    timestamp: 'timestamp_e70a92d8',
	    redText: 'redText_e70a92d8',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(544);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_e70a92d8{display:block}.blueBackground_e70a92d8{background:\"[theme:themeLighter, default: #deecf9]\"}.itemDetails_e70a92d8{padding:0}.itemDetails_e70a92d8 li{display:inline-table}.verbose_e70a92d8{width:10%;color:\"[theme:yellow, default: #ffb900]\"}.info_e70a92d8{width:10%;color:\"[theme:orangeLighter, default: #ff8c00]\"}.warning_e70a92d8{width:10%;color:\"[theme:orangeLight, default: #ea4300]\"}.error_e70a92d8{width:10%;color:\"[theme:red, default: #e81123]\"}.message_e70a92d8{width:40%}.source_e70a92d8{width:20%}.scope_e70a92d8{width:20%}.timestamp_e70a92d8{width:10%}.redText_e70a92d8{color:\"[theme:red, default: #e81123]\"}", ""]);
	
	// exports


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var React = __webpack_require__(386);
	var DeveloperToolsFabric_1 = __webpack_require__(388);
	var LoadingOrErrorModule_module_scss_1 = __webpack_require__(546);
	var LoadingOrErrorModule_resx_1 = __webpack_require__(549);
	var LoadingOrErrorModule = (function (_super) {
	    __extends(LoadingOrErrorModule, _super);
	    function LoadingOrErrorModule() {
	        return _super.call(this) || this;
	    }
	    LoadingOrErrorModule.prototype.componentDidMount = function () {
	        var _this = this;
	        this.props.tab.loadComponent()
	            .then(function () {
	            _this.forceUpdate();
	        })
	            .catch(function (error) {
	            _this.forceUpdate();
	        });
	    };
	    LoadingOrErrorModule.prototype.render = function () {
	        var tab = this.props.tab;
	        if (tab.isLoading) {
	            return React.createElement("div", { className: LoadingOrErrorModule_module_scss_1.default.loadingModule },
	                React.createElement(DeveloperToolsFabric_1.Spinner, { type: DeveloperToolsFabric_1.SpinnerType.large, label: LoadingOrErrorModule_resx_1.default.developerToolsTabLoadingText }));
	        }
	        else if (tab.loadError || !tab.component) {
	            var errorMessage = tab.loadError || LoadingOrErrorModule_resx_1.default.developerToolsTabLoadingUnknownError;
	            return React.createElement("div", { className: LoadingOrErrorModule_module_scss_1.default.module },
	                React.createElement("div", { "aria-live": 'assertive', className: 'ms-u-screenReaderOnly', "data-automation-id": 'error-message' }, errorMessage),
	                React.createElement("p", { className: DeveloperToolsFabric_1.css('ms-TextField-errorMessage', 'ms-font-l', LoadingOrErrorModule_module_scss_1.default.errorText) }, errorMessage));
	        }
	        else {
	            return React.createElement(tab.component);
	        }
	    };
	    return LoadingOrErrorModule;
	}(React.Component));
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = LoadingOrErrorModule;


/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(547);
	var styles = {
	    module: 'module_8dbc09df',
	    loadingModule: 'loadingModule_8dbc09df',
	    errorText: 'errorText_8dbc09df',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 547 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(548);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".loadingModule_8dbc09df,.module_8dbc09df{text-align:center;vertical-align:middle;height:100%;display:table;width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.loadingModule_8dbc09df>div{display:table-cell;text-align:center;vertical-align:middle}.errorText_8dbc09df{display:table-cell;text-align:center;vertical-align:middle}", ""]);
	
	// exports


/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var strings =  false
	    ? require('../../../../resx-strings/en-us.json')
	    : __webpack_require__(382);
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (strings['_SxImp5ewsUToxeAHBkB+pw'] || {});


/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(551);
	var styles = {
	    container: 'container_f80eae55',
	    toolsArea: 'toolsArea_f80eae55',
	    resizeBar: 'resizeBar_f80eae55',
	    closeButton: 'closeButton_f80eae55',
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = styles;


/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	var content = __webpack_require__(552);
	var loader = __webpack_require__(385);
	
	if(typeof content === "string") content = [[module.id, content]];
	
	// add the styles to the DOM
	for (var i = 0; i < content.length; i++) loader.loadStyles(content[i][1]);
	
	if(content.locals) module.exports = content.locals;

/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(402)();
	// imports
	
	
	// module
	exports.push([module.id, ".container_f80eae55{position:fixed;bottom:0;width:100%;background-color:#fff;opacity:.9;z-index:2147483647}.toolsArea_f80eae55{position:absolute;bottom:0;top:5px;width:100%}.toolsArea_f80eae55>div{height:100%}.toolsArea_f80eae55>div .ms-Pivot{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.toolsArea_f80eae55>div>div+div{padding:0 5px 5px 5px;height:calc(100% - 50px);position:absolute;width:calc(100% - 10px)}.toolsArea_f80eae55>div>div+div>div{height:100%}.resizeBar_f80eae55{background-color:#2f4f4f;width:100%;height:5px;cursor:ns-resize}.closeButton_f80eae55{position:absolute!important;right:0;top:0}", ""]);
	
	// exports


/***/ }
]));
//# sourceMappingURL=2.developer-tools_c68f6bf06ff9588162fc.js.map