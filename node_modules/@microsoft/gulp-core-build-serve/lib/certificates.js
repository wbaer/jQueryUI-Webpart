/// <reference path="./NodeForgeExtensions.d.ts" />
"use strict";
var forge = require('node-forge');
var fs = require("fs");
var path = require("path");
var child_process = require("child_process");
var os_1 = require("os");
var sudoSync_1 = require("./sudoSync");
var CertificateStore_1 = require("./CertificateStore");
var serialNumber = '731c321744e34650a202e3ef91c3c1b9';
var friendlyName = 'gulp-core-build-serve Development Certificate';
var macKeychain = '/Library/Keychains/System.keychain';
var _certutilExePath;
function createDevelopmentCertificate() {
    var keys = forge.pki.rsa.generateKeyPair(2048);
    var certificate = forge.pki.createCertificate();
    certificate.publicKey = keys.publicKey;
    certificate.serialNumber = serialNumber;
    var now = new Date();
    certificate.validity.notBefore = now;
    certificate.validity.notAfter.setFullYear(certificate.validity.notBefore.getFullYear() + 3); // Three years from now
    var attrs = [{
            name: 'commonName',
            value: 'localhost'
        }];
    certificate.setSubject(attrs);
    certificate.setIssuer(attrs);
    certificate.setExtensions([
        {
            name: 'keyUsage',
            digitalSignature: true,
            keyEncipherment: true,
            dataEncipherment: true
        }, {
            name: 'extKeyUsage',
            serverAuth: true
        }, {
            name: 'friendlyName',
            value: friendlyName
        }
    ]);
    // self-sign certificate
    certificate.sign(keys.privateKey, forge.md.sha256.create());
    // convert a Forge certificate to PEM
    var pem = forge.pki.certificateToPem(certificate);
    var privateKey = forge.pki.privateKeyToPem(keys.privateKey);
    return {
        pemCertificate: pem,
        pemKey: privateKey
    };
}
function ensureCertUtilExePath(parentTask) {
    if (!_certutilExePath) {
        var where = child_process.spawnSync('where', ['certutil']);
        var whereErr = where.stderr.toString();
        if (!!whereErr) {
            parentTask.logError("Error finding certUtil command: \"" + whereErr + "\"");
            _certutilExePath = undefined;
        }
        else {
            _certutilExePath = where.stdout.toString().trim();
        }
    }
    return _certutilExePath;
}
function tryTrustCertificate(certificatePath, parentTask) {
    switch (process.platform) {
        case 'win32':
            var certutilExePath = ensureCertUtilExePath(parentTask);
            if (!certutilExePath) {
                // Unable to find the cert utility
                return false;
            }
            parentTask.log('Attempting to trust a dev certificate. This self-signed certificate only points to localhost ' +
                'and will be stored in your local user profile to be used by other instances of ' +
                'gulp-core-build-serve. If you do not consent to trust this certificate, click "NO" in the ' +
                'dialog.');
            var winTrustResult = child_process.spawnSync(certutilExePath, ['-user', '-addstore', 'root', certificatePath]);
            if (winTrustResult.status !== 0) {
                parentTask.logError("Error: " + winTrustResult.stdout.toString());
                var errorLines = winTrustResult.stdout.toString().split(os_1.EOL).map(function (line) { return line.trim(); });
                // Not sure if this is always the status code for "cancelled" - should confirm.
                if (winTrustResult.status === 2147943623 ||
                    errorLines[errorLines.length - 1].indexOf('The operation was canceled by the user.') > 0) {
                    parentTask.log('Certificate trust cancelled.');
                }
                else {
                    parentTask.logError('Certificate trust failed with an unknown error.');
                }
                return false;
            }
            else {
                parentTask.logVerbose('Successfully trusted development certificate.');
                return true;
            }
        case 'darwin':
            parentTask.log('Attempting to trust a dev certificate. This self-signed certificate only points to localhost ' +
                'and will be stored in your local user profile to be used by other instances of ' +
                'gulp-core-build-serve. If you do not consent to trust this certificate, do not enter your ' +
                'root password in the prompt.');
            var commands = [
                'security',
                'add-trusted-cert',
                '-d',
                '-r',
                'trustRoot',
                '-k',
                macKeychain,
                certificatePath
            ];
            var result = sudoSync_1.runSudoSync(commands);
            if (result.code === 0) {
                parentTask.logVerbose('Successfully trusted development certificate.');
                return true;
            }
            else {
                if (result.stderr.some(function (value) { return !!value.match(/The authorization was cancelled by the user\./); })) {
                    parentTask.log('Certificate trust cancelled.');
                    return false;
                }
                else {
                    parentTask.logError("Certificate trust failed with an unknown error. Exit code: " + result.code + ". " +
                        ("Error: " + result.stderr.join(' ')));
                    return false;
                }
            }
        default:
            // Linux + others: Have the user manually trust the cert if they want to
            parentTask.log('Automatic certificate trust is only implemented for gulp-core-build-serve on Windows and ' +
                'macOS. To trust the development certificate, add this certificate to your trusted root ' +
                ("certification authorities: \"" + CertificateStore_1.default.instance.certificatePath + "\"."));
            return true;
    }
}
function trySetFriendlyName(certificatePath, parentTask) {
    if (process.platform === 'win32') {
        var certutilExePath = ensureCertUtilExePath(parentTask);
        if (!certutilExePath) {
            // Unable to find the cert utility
            return false;
        }
        var basePath = path.dirname(certificatePath);
        var fileName = path.basename(certificatePath, path.extname(certificatePath));
        var friendlyNamePath = path.join(basePath, fileName + ".inf");
        var friendlyNameFile = [
            '[Version]',
            'Signature = "$Windows NT$"',
            '[Properties]',
            "11 = \"{text}" + friendlyName + "\"",
            ''
        ].join(os_1.EOL);
        fs.writeFileSync(friendlyNamePath, friendlyNameFile);
        var commands = [
            '–repairstore',
            '–user',
            'root',
            serialNumber,
            friendlyNamePath
        ];
        var repairStoreResult = child_process.spawnSync(certutilExePath, commands);
        if (repairStoreResult.status !== 0) {
            parentTask.logError("CertUtil Error: " + repairStoreResult.stdout.toString());
            return false;
        }
        else {
            parentTask.logVerbose('Successfully set certificate name.');
            return true;
        }
    }
    else {
        // No equivalent concept outside of Windows
        return true;
    }
}
/**
 * Get the dev certificate from the store, or, optionally, generate a new one and trust it if one doesn't exist in the
 *  store.
 */
function ensureCertificate(canGenerateNewCertificate, parentTask) {
    var certificateStore = CertificateStore_1.default.instance;
    if ((!certificateStore.certificateData || !certificateStore.keyData) && canGenerateNewCertificate) {
        var generatedCertificate = createDevelopmentCertificate();
        var now = new Date();
        var certificateName = now.getTime().toString();
        var tempDirName = path.join(__dirname, '..', 'temp');
        if (!fs.existsSync(tempDirName)) {
            fs.mkdirSync(tempDirName); // Create the temp dir if it doesn't exist
        }
        var tempCertificatePath = path.join(tempDirName, certificateName + ".cer");
        fs.writeFileSync(tempCertificatePath, generatedCertificate.pemCertificate);
        if (tryTrustCertificate(tempCertificatePath, parentTask)) {
            certificateStore.certificateData = generatedCertificate.pemCertificate;
            certificateStore.keyData = generatedCertificate.pemKey;
            if (!trySetFriendlyName(tempCertificatePath, parentTask)) {
                parentTask.logWarning('Unable to set the certificate\'s friendly name.');
            }
        }
        else {
            // Clear out the existing store data, if any exists
            certificateStore.certificateData = undefined;
            certificateStore.keyData = undefined;
        }
        fs.unlinkSync(tempCertificatePath);
    }
    return {
        pemCertificate: certificateStore.certificateData,
        pemKey: certificateStore.keyData
    };
}
exports.ensureCertificate = ensureCertificate;
function untrustCertificate(parentTask) {
    switch (process.platform) {
        case 'win32':
            var certutilExePath = ensureCertUtilExePath(parentTask);
            if (!certutilExePath) {
                // Unable to find the cert utility
                return false;
            }
            var winUntrustResult = child_process.spawnSync(certutilExePath, ['-user', '-delstore', 'root', serialNumber]);
            if (winUntrustResult.status !== 0) {
                parentTask.logError("Error: " + winUntrustResult.stdout.toString());
                return false;
            }
            else {
                parentTask.logVerbose('Successfully untrusted development certificate.');
                return true;
            }
        case 'darwin':
            parentTask.logVerbose('Trying to find the signature of the dev cert');
            var macFindCertificateResult = child_process.spawnSync('security', ['find-certificate', '-c', 'localhost', '-a', '-Z', macKeychain]);
            if (macFindCertificateResult.status !== 0) {
                parentTask.logError("Error finding the dev certificate: " + macFindCertificateResult.output.join(' '));
                return false;
            }
            var outputLines = macFindCertificateResult.stdout.toString().split(os_1.EOL);
            var found = false;
            var shaHash = undefined;
            for (var i = 0; i < outputLines.length; i++) {
                var line = outputLines[i];
                var shaMatch = line.match(/^SHA-1 hash: (.+)$/);
                if (shaMatch) {
                    shaHash = shaMatch[1];
                }
                var snbrMatch = line.match(/^\s*"snbr"<blob>=0x([^\s]+).+$/);
                if (snbrMatch && (snbrMatch[1] || '').toLowerCase() === serialNumber) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                parentTask.logError('Unable to find the dev certificate.');
                return false;
            }
            parentTask.logVerbose("Found the dev cert. SHA is " + shaHash);
            var macUntrustResult = sudoSync_1.runSudoSync(['security', 'delete-certificate', '-Z', shaHash, macKeychain]);
            if (macUntrustResult.code === 0) {
                parentTask.logVerbose('Successfully untrusted dev certificate.');
                return true;
            }
            else {
                parentTask.logError(macUntrustResult.stderr.join(' '));
                return false;
            }
        default:
            // Linux + others: Have the user manually untrust the cert
            parentTask.log('Automatic certificate untrust is only implemented for gulp-core-build-serve on Windows and ' +
                'macOS. To untrust the development certificate, remove this certificate from your trusted ' +
                ("root certification authorities: \"" + CertificateStore_1.default.instance.certificatePath + "\". The ") +
                ("certificate has serial number \"" + serialNumber + "\"."));
            return false;
    }
}
exports.untrustCertificate = untrustCertificate;

//# sourceMappingURL=certificates.js.map
