/// <reference types="mocha" />
"use strict";
var chai_1 = require("chai");
var gulp_core_build_webpack_1 = require("@microsoft/gulp-core-build-webpack");
var lodash_1 = require("lodash");
var path = require("path");
var ConfigureExternalBundlingWebpackTask_1 = require("./../ConfigureExternalBundlingWebpackTask");
var ConfigureWebpackTask_1 = require("./../ConfigureWebpackTask");
var task;
var errorBuffer;
var warningBuffer;
var baseConfig = {
    output: {
        libraryTarget: 'var'
    }
};
var entries = [
    {
        configEntry: undefined,
        entryName: 'entry_a',
        nonLocalizedEntrypointPath: 'path/to/A.js',
        manifest: undefined
    },
    {
        configEntry: undefined,
        entryName: 'entry_b',
        nonLocalizedEntrypointPath: 'path/to/B.js',
        manifest: undefined
    }
];
var locales = ['en-us', 'fr-fr'];
var localizedResources = {
    'Loc1': (_a = {},
        _a[locales[0]] = 'path/A/en-us',
        _a[locales[1]] = 'path/A/fr-fr',
        _a),
    'Loc2': (_b = {},
        _b[locales[0]] = 'path/B/en-us',
        _b[locales[1]] = 'path/B/fr-fr',
        _b)
};
var externals = {
    'A': 'a',
    'B': 'b'
};
var rootPath = __dirname;
var distFolder = 'dist';
describe('ConfigureExternalBundlingWebpackTask', function () {
    beforeEach(function () {
        task = new ConfigureExternalBundlingWebpackTask_1.ConfigureExternalBundlingWebpackTask();
        task.buildConfig = {
            rootPath: rootPath,
            distFolder: distFolder,
            properties: {}
        };
        task.properties.externals = externals;
        errorBuffer = [];
        warningBuffer = [];
        task.logWarning = function (text) { return warningBuffer.push(text); };
        task.logError = function (text) { return errorBuffer.push(text); };
    });
    describe('setConfig', function () {
        it('logs a warning if the webpack paramter is not a webpack task', function () {
            task.setConfig({ webpack: {} }); // tslint:disable-line:no-any
            chai_1.assert.equal(warningBuffer.length, 1);
            chai_1.assert.equal(errorBuffer.length, 0);
        });
        it('does not log a warning if the webpack paramter is a webpack task', function () {
            attachWebpackTask();
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
        });
    });
    describe('executeTask', function () {
        it('logs a warning and doesn\'t do anything if a webpack task isn\'t provided', function () {
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.isUndefined(result.taskError);
            chai_1.assert.equal(warningBuffer.length, 1);
            chai_1.assert.equal(errorBuffer.length, 0);
        });
        it('logs an error and disables the webpack task if no configureWebpackTask is provided', function () {
            var webpackTask = attachWebpackTask();
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.isUndefined(result.taskError);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 1);
            chai_1.assert.isFalse(webpackTask.isEnabled(undefined));
        });
        it('disables the webpack task if no localized resources are provided', function () {
            var webpackTask = attachWebpackTask();
            attachConfigureWebpackTask();
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.isUndefined(result.taskError);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isFalse(webpackTask.isEnabled(undefined));
        });
        it('logs an error if there\'s no existing webpack stats object', function () {
            attachWebpackTask();
            configureWithLocResources();
            attachConfigureWebpackTask();
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.isUndefined(result.taskError);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 1);
        });
        it('returns an error if the localized resources weren\'t discovered', function () {
            attachWebpackTask();
            configureWithLocResources();
            attachWebpackStats();
            attachConfigureWebpackTask();
            task.properties.discoveredLocalizedResources = undefined;
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isDefined(result.taskError);
            // Should have returned all of the resources' names.
            var resourceNames = Object.keys(localizedResources);
            resourceNames.forEach(function (resourceName) {
                chai_1.assert.notEqual(result.taskError.indexOf(resourceName), -1);
            });
        });
        it('returns an error if the localized resources don\'t have matching locales', function () {
            attachWebpackTask();
            configureWithLocResources();
            attachWebpackStats();
            attachConfigureWebpackTask();
            // This only applies if we're in production mode
            task.buildConfig.production = true;
            var resourceNames = Object.keys(localizedResources);
            task.properties.discoveredLocalizedResources[resourceNames[1]] = { 'fr-fr': 'test' };
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isDefined(result.taskError);
            // Should have returned the second resource's name
            chai_1.assert.notEqual(result.taskError.indexOf(resourceNames[1]), -1);
            // Should have returned the first resource's locale names
            var localeNames = Object.keys(localizedResources[resourceNames[0]]);
            localeNames.forEach(function (localeName) {
                chai_1.assert.notEqual(result.taskError.indexOf(localeName), -1);
            });
        });
        it('calls "tinkerWithLocConfig" on the configureWebpackTask', function () {
            attachWebpackTask();
            configureWithLocResources();
            attachWebpackStats();
            var configureWebpackTask = attachConfigureWebpackTask();
            var tinkerWithLocConfigCalled = false;
            configureWebpackTask.tinkerWithLocConfig = function () { return tinkerWithLocConfigCalled = true; };
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isUndefined(result.taskError);
            chai_1.assert.isTrue(tinkerWithLocConfigCalled);
        });
        it('has a valid Configuration', function () {
            var webpackTask = attachWebpackTask();
            configureWithLocResources();
            attachWebpackStats();
            attachConfigureWebpackTask();
            setBundleEntries();
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isUndefined(result.taskError);
            var configs = webpackTask.taskConfig.config;
            configs.forEach(function (config) {
                // json-loader is configured
                chai_1.assert.equal(config.module.loaders.length, 1);
                chai_1.assert.equal(config.module.loaders[0].loader, 'json-loader');
                chai_1.assert.isNotNull('test.json'.match(config.module.loaders[0].test));
                chai_1.assert.isNull('test.jsone'.match(config.module.loaders[0].test));
                // .map files aren't parsed
                chai_1.assert.equal(config.module.noParse.length, 1);
                chai_1.assert.isNotNull('test.map'.match(config.module.noParse[0]));
                chai_1.assert.isNull('test.mape'.match(config.module.noParse[0]));
                // No post-loaders
                chai_1.assert.equal(config.module.postLoaders.length, 0);
                // No source-map-loader in non-production mode
                chai_1.assert.equal(config.module.preLoaders.length, 1);
                chai_1.assert.equal(config.module.preLoaders[0].loader, 'source-map-loader');
                chai_1.assert.isNotNull('test.js'.match(config.module.preLoaders[0].test));
                chai_1.assert.isNull('test.jsx'.match(config.module.preLoaders[0].test));
                // resolveLoader root is in the node_modules directory
                chai_1.assert.isNotNull(config.resolveLoader.root.match(/node_modules$/));
                // context is the output directory
                chai_1.assert.equal(config.context, task.outputDirectory);
                // source-map is set as the dev tool in non-production mode
                chai_1.assert.equal(config.devtool, 'source-map');
                // externals are correctly listed
                var externalsKeys = Object.keys(externals);
                chai_1.assert.equal(config.externals.length, externalsKeys.length + 3);
                externalsKeys.forEach(function (external) {
                    chai_1.assert.notEqual(config.externals.indexOf(external), -1);
                });
                var configEntries = config.entry;
                var configEntryKeys = Object.keys(configEntries);
                chai_1.assert.equal(configEntryKeys.length, entries.length);
                configEntryKeys.forEach(function (key) {
                    chai_1.assert.isTrue(entries.some(function (entry) {
                        var configEntryPath = configEntries[key];
                        var expectedPath = path.join(rootPath, distFolder, path.basename(entry.nonLocalizedEntrypointPath));
                        return path.basename(entry.nonLocalizedEntrypointPath, '.js') === key &&
                            configEntryPath === expectedPath;
                    }));
                });
                chai_1.assert.equal(config.output.libraryTarget, 'amd');
                chai_1.assert.equal(config.output.path, path.join(rootPath, distFolder));
                chai_1.assert.equal(config.output.devtoolModuleFilenameTemplate, 'webpack:///../[resource-path]');
                chai_1.assert.equal(config.output.devtoolFallbackModuleFilenameTemplate, 'webpack:///../[resource-path]?[hash]');
                chai_1.assert.isTrue(locales.some(function (locale) {
                    return config.output.filename.indexOf(locale) !== -1 &&
                        config.output.chunkFilename.indexOf(locale) !== -1;
                }));
                var alias = config.resolve.alias;
                Object.keys(localizedResources).forEach(function (resourceName) {
                    chai_1.assert.isDefined(alias[resourceName]);
                });
            });
        });
        it('selects all locales if "bundleAllLocalizedResources" is enabled', function () {
            var webpackTask = attachWebpackTask();
            configureWithLocResources();
            attachWebpackStats();
            var configureWebpackTask = attachConfigureWebpackTask();
            setBundleEntries();
            task.setConfig({
                localizedResources: null,
                bundleAllLocalizedResources: true
            });
            configureWebpackTask.buildConfig = task.buildConfig;
            var result = callExecuteTask();
            chai_1.assert.isTrue(result.taskCompleted);
            chai_1.assert.equal(warningBuffer.length, 0);
            chai_1.assert.equal(errorBuffer.length, 0);
            chai_1.assert.isUndefined(result.taskError);
            var configs = webpackTask.taskConfig.config;
            configs.forEach(function (config) {
                var alias = config.resolve.alias;
                Object.keys(localizedResources).forEach(function (resourceName) {
                    chai_1.assert.isDefined(alias[resourceName]);
                });
            });
        });
    });
    describe('tinkerWithBaseWebackConfig', function () {
        it('doesn\'t do anything if there are no localized resources', function () {
            var testConfig = lodash_1.cloneDeep(baseConfig);
            task.tinkerWithBaseWebpackConfig(testConfig);
            chai_1.assert.deepEqual(testConfig, baseConfig);
        });
        it('sets the config type to "amd" if there are localized resources', function () {
            configureWithLocResources();
            var testConfig = lodash_1.cloneDeep(baseConfig);
            task.tinkerWithBaseWebpackConfig(testConfig);
            chai_1.assert.equal(testConfig.output.libraryTarget, 'amd');
        });
    });
});
function callExecuteTask() {
    var result = {
        taskCompleted: false,
        taskError: undefined
    };
    task.executeTask(undefined, function (error) {
        result.taskCompleted = true;
        result.taskError = error;
    });
    return result;
}
function attachWebpackTask() {
    var webpackTask = new gulp_core_build_webpack_1.WebpackTask();
    task.setConfig({ webpack: webpackTask });
    return webpackTask;
}
function attachWebpackStats() {
    var stats = {
        toJson: function () {
            return {
                modules: [
                    {
                        name: 'external "Loc1"'
                    },
                    {
                        name: 'external "Loc2"'
                    }
                ]
            };
        }
    };
    task.properties.webpackStats = stats;
    return stats;
}
function configureWithLocResources() {
    task.setConfig({ localizedResources: Object.keys(localizedResources) });
    task.properties.discoveredLocalizedResources = lodash_1.cloneDeep(localizedResources);
}
function attachConfigureWebpackTask() {
    var configureWebpackTask = new ConfigureWebpackTask_1.ConfigureWebpackTask();
    task.setConfig({ configureWebpackTask: configureWebpackTask });
    return configureWebpackTask;
}
function setBundleEntries() {
    task.properties.bundleEntries = lodash_1.cloneDeep(entries);
}
var _a, _b;

//# sourceMappingURL=ConfigureExternalBundlingWebpackTask.test.js.map
