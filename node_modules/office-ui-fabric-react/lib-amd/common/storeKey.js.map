{"version":3,"sources":["common/storeKey.ts"],"names":[],"mappings":";;IAOA;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACU,QAAA,QAAQ,GAAG,UAAI,IAAY,IAAK,OAAA,CAAC,EAAE,IAAI,MAAA,EAAE,EAAE,EAAE,iBAAK,CAAC,IAAI,CAAC,EAAE,CAAiB,EAA3C,CAA2C,CAAC","file":"common/storeKey.js","sourcesContent":["import { getId } from '../Utilities';\r\n\r\nexport interface IStoreKey<T> {\r\n  name: string;\r\n  id: string;\r\n}\r\n\r\n/**\r\n * Store keys are a very simple abstraction that maps a string name to an interface type.\r\n * The enables a type-safe contract for store dependencies when you connect dumb components\r\n * to stores.\r\n *\r\n * @example\r\n * let selectionKey = storeKey<ISelection>('selection');\r\n *\r\n * let stores = new StoreSet()\r\n *   .add(selectionKey, new Selection());\r\n *\r\n * <StoreHost stores={ stores }>\r\n *   ...\r\n * </StoreHost>\r\n *\r\n * connect(DumbComponent, [ selectionKey ], (props, selection) => ({\r\n *   isSelected: selection.getSelected(props.item.key)\r\n * });\r\n *\r\n * Note that the \"selection\" reference in the connect callback would be of type ISelection due\r\n * to the selectionKey reference, and you will get TypeScript errors by referring to selection\r\n * member that aren't in that interface.\r\n */\r\nexport const storeKey = <T>(name: string) => ({ name, id: getId(name) }) as IStoreKey<T>;\r\n"],"sourceRoot":"..\\..\\src"}