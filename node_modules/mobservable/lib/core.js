var dnode_1 = require('./dnode');
var utils_1 = require('./utils');
var observablevalue_1 = require('./observablevalue');
var observableview_1 = require('./observableview');
var observablearray_1 = require('./observablearray');
var observableobject_1 = require('./observableobject');
var observablemap_1 = require('./observablemap');
var dnode_2 = require('./dnode');
function observable(v, keyOrScope) {
    if (typeof arguments[1] === "string")
        return observableDecorator.apply(null, arguments);
    switch (arguments.length) {
        case 0:
            throw new Error("[mobservable.observable] Please provide at least one argument.");
        case 1:
            break;
        case 2:
            if (typeof v === "function")
                break;
            throw new Error("[mobservable.observable] Only one argument expected.");
        default:
            throw new Error("[mobservable.observable] Too many arguments. Please provide exactly one argument, or a function and a scope.");
    }
    if (isObservable(v))
        return v;
    var _a = getValueModeFromValue(v, ValueMode.Recursive), mode = _a[0], value = _a[1];
    var sourceType = mode === ValueMode.Reference ? ValueType.Reference : getTypeOfValue(value);
    switch (sourceType) {
        case ValueType.Reference:
        case ValueType.ComplexObject:
            return toGetterSetterFunction(new observablevalue_1.ObservableValue(value, mode, null));
        case ValueType.ComplexFunction:
            throw new Error("[mobservable.observable] To be able to make a function reactive it should not have arguments. If you need an observable reference to a function, use `observable(asReference(f))`");
        case ValueType.ViewFunction: {
            var context = {
                name: value.name,
                object: value
            };
            return toGetterSetterFunction(new observableview_1.ObservableView(value, keyOrScope, context, mode === ValueMode.Structure));
        }
        case ValueType.Array:
        case ValueType.PlainObject:
            return makeChildObservable(value, mode, null);
    }
    throw "Illegal State";
}
exports.observable = observable;
function map(initialValues, valueModifier) {
    return new observablemap_1.ObservableMap(initialValues, valueModifier);
}
exports.map = map;
function fastArray(initialValues) {
    return observablearray_1.createObservableArray(initialValues, ValueMode.Flat, false, null);
}
exports.fastArray = fastArray;
function asReference(value) {
    return new AsReference(value);
}
exports.asReference = asReference;
function asStructure(value) {
    return new AsStructure(value);
}
exports.asStructure = asStructure;
function asFlat(value) {
    return new AsFlat(value);
}
exports.asFlat = asFlat;
function isObservable(value, property) {
    if (value === null || value === undefined)
        return false;
    if (property !== undefined) {
        if (value instanceof observablemap_1.ObservableMap || value instanceof observablearray_1.ObservableArray)
            throw new Error("[mobservable.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
        else if (value.$mobservable instanceof observableobject_1.ObservableObject) {
            var o = value.$mobservable;
            return o.values && !!o.values[property];
        }
        return false;
    }
    return !!value.$mobservable || value instanceof dnode_2.DataNode;
}
exports.isObservable = isObservable;
function autorun(view, scope) {
    var _a = getValueModeFromValue(view, ValueMode.Recursive), mode = _a[0], unwrappedView = _a[1];
    if (typeof unwrappedView !== "function")
        throw new Error("[mobservable.autorun] expects a function");
    if (unwrappedView.length !== 0)
        throw new Error("[mobservable.autorun] expects a function without arguments");
    var observable = new observableview_1.ObservableView(unwrappedView, scope, {
        object: scope || view,
        name: view.name
    }, mode === ValueMode.Structure);
    var disposedPrematurely = false;
    var started = false;
    dnode_2.runAfterTransaction(function () {
        if (!disposedPrematurely) {
            observable.setRefCount(+1);
            started = true;
        }
    });
    var disposer = utils_1.once(function () {
        if (started)
            observable.setRefCount(-1);
        else
            disposedPrematurely = true;
    });
    disposer.$mobservable = observable;
    return disposer;
}
exports.autorun = autorun;
function autorunUntil(predicate, effect, scope) {
    var disposeImmediately = false;
    var disposer = autorun(function () {
        if (predicate.call(scope)) {
            if (disposer)
                disposer();
            else
                disposeImmediately = true;
            dnode_1.untracked(function () { return effect.call(scope); });
        }
    });
    if (disposeImmediately)
        disposer();
    return disposer;
}
exports.autorunUntil = autorunUntil;
function autorunAsyncDeprecated(view, effect, delay, scope) {
    if (delay === void 0) { delay = 1; }
    var latestValue = undefined;
    var timeoutHandle;
    var disposer = autorun(function () {
        latestValue = view.call(scope);
        if (!timeoutHandle) {
            timeoutHandle = setTimeout(function () {
                effect.call(scope, latestValue);
                timeoutHandle = null;
            }, delay);
        }
    });
    return utils_1.once(function () {
        disposer();
        if (timeoutHandle)
            clearTimeout(timeoutHandle);
    });
}
function autorunAsync(func, delay, scope) {
    if (delay === void 0) { delay = 1; }
    if (typeof delay === "function") {
        console.warn("[mobservable] autorun(func, func) is deprecated and will removed in 2.0");
        return autorunAsyncDeprecated.apply(null, arguments);
    }
    var shouldRun = false;
    var tickScheduled = false;
    var tick = observable(0);
    var observedValues = [];
    var disposer;
    var isDisposed = false;
    function schedule(f) {
        setTimeout(f, delay);
    }
    function doTick() {
        tickScheduled = false;
        shouldRun = true;
        tick(tick() + 1);
    }
    disposer = autorun(function () {
        if (isDisposed)
            return;
        tick();
        if (shouldRun) {
            func.call(scope);
            observedValues = disposer.$mobservable.observing;
            shouldRun = false;
        }
        else {
            observedValues.forEach(function (o) { return o.notifyObserved(); });
            if (!tickScheduled) {
                tickScheduled = true;
                schedule(doTick);
            }
        }
    });
    return utils_1.once(function () {
        isDisposed = true;
        if (disposer)
            disposer();
    });
}
exports.autorunAsync = autorunAsync;
function expr(expr, scope) {
    if (!dnode_1.isComputingView())
        console.warn("[mobservable.expr] 'expr' should only be used inside other reactive functions.");
    return observable(expr, scope)();
}
exports.expr = expr;
function extendObservable(target) {
    var properties = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        properties[_i - 1] = arguments[_i];
    }
    if (arguments.length < 2)
        throw new Error("[mobservable.extendObservable] expected 2 or more arguments");
    if (target instanceof observablemap_1.ObservableMap || properties instanceof observablemap_1.ObservableMap)
        throw new Error("[mobservable.extendObservable] 'extendObservable' should not be used on maps, use map.merge instead");
    properties.forEach(function (propSet) {
        if (!propSet || typeof target !== "object")
            throw new Error("[mobservable.extendObservable] 'extendObservable' expects one or more objects with properties to define");
        extendObservableHelper(target, propSet, ValueMode.Recursive, null);
    });
    return target;
}
exports.extendObservable = extendObservable;
function observableDecorator(target, key, baseDescriptor) {
    if (arguments.length < 2 || arguments.length > 3)
        throw new Error("[mobservable.@observable] A decorator expects 2 or 3 arguments, got: " + arguments.length);
    var isDecoratingGetter = baseDescriptor && baseDescriptor.hasOwnProperty("get");
    var descriptor = {};
    var baseValue = undefined;
    if (baseDescriptor) {
        if (baseDescriptor.hasOwnProperty('get'))
            baseValue = baseDescriptor.get;
        else if (baseDescriptor.hasOwnProperty('value'))
            baseValue = baseDescriptor.value;
        else if (baseDescriptor.initializer) {
            baseValue = baseDescriptor.initializer();
            if (typeof baseValue === "function")
                baseValue = asReference(baseValue);
        }
    }
    if (!target || typeof target !== "object")
        throw new Error("The @observable decorator can only be used on objects");
    if (isDecoratingGetter) {
        if (typeof baseValue !== "function")
            throw new Error("@observable expects a getter function if used on a property (in member: '" + key + "').");
        if (descriptor.set)
            throw new Error("@observable properties cannot have a setter (in member: '" + key + "').");
        if (baseValue.length !== 0)
            throw new Error("@observable getter functions should not take arguments (in member: '" + key + "').");
    }
    descriptor.configurable = true;
    descriptor.enumerable = true;
    descriptor.get = function () {
        var _this = this;
        withStrict(false, function () {
            observableobject_1.ObservableObject.asReactive(_this, null, ValueMode.Recursive).set(key, baseValue);
        });
        return this[key];
    };
    descriptor.set = isDecoratingGetter
        ? observableview_1.throwingViewSetter(key)
        : function (value) {
            observableobject_1.ObservableObject.asReactive(this, null, ValueMode.Recursive).set(key, typeof value === "function" ? asReference(value) : value);
        };
    if (!baseDescriptor) {
        Object.defineProperty(target, key, descriptor);
    }
    else {
        return descriptor;
    }
}
function toJSON(source, detectCycles, __alreadySeen) {
    if (detectCycles === void 0) { detectCycles = true; }
    if (__alreadySeen === void 0) { __alreadySeen = null; }
    function cache(value) {
        if (detectCycles)
            __alreadySeen.push([source, value]);
        return value;
    }
    if (detectCycles && __alreadySeen === null)
        __alreadySeen = [];
    if (detectCycles && source !== null && typeof source === "object") {
        for (var i = 0, l = __alreadySeen.length; i < l; i++)
            if (__alreadySeen[i][0] === source)
                return __alreadySeen[i][1];
    }
    if (!source)
        return source;
    if (Array.isArray(source) || source instanceof observablearray_1.ObservableArray) {
        var res = cache([]);
        res.push.apply(res, source.map(function (value) { return toJSON(value, detectCycles, __alreadySeen); }));
        return res;
    }
    if (source instanceof observablemap_1.ObservableMap) {
        var res = cache({});
        source.forEach(function (value, key) { return res[key] = toJSON(value, detectCycles, __alreadySeen); });
        return res;
    }
    if (typeof source === "object" && utils_1.isPlainObject(source)) {
        var res = cache({});
        for (var key in source)
            if (source.hasOwnProperty(key))
                res[key] = toJSON(source[key], detectCycles, __alreadySeen);
        return res;
    }
    if (isObservable(source) && source.$mobservable instanceof observablevalue_1.ObservableValue)
        return toJSON(source(), detectCycles, __alreadySeen);
    return source;
}
exports.toJSON = toJSON;
var strict = false;
function getStrict() {
    return strict;
}
exports.getStrict = getStrict;
function withStrict(newStrict, func) {
    var baseStrict = strict;
    strict = newStrict;
    try {
        func();
    }
    finally {
        strict = baseStrict;
    }
}
exports.withStrict = withStrict;
(function (ValueType) {
    ValueType[ValueType["Reference"] = 0] = "Reference";
    ValueType[ValueType["PlainObject"] = 1] = "PlainObject";
    ValueType[ValueType["ComplexObject"] = 2] = "ComplexObject";
    ValueType[ValueType["Array"] = 3] = "Array";
    ValueType[ValueType["ViewFunction"] = 4] = "ViewFunction";
    ValueType[ValueType["ComplexFunction"] = 5] = "ComplexFunction";
})(exports.ValueType || (exports.ValueType = {}));
var ValueType = exports.ValueType;
(function (ValueMode) {
    ValueMode[ValueMode["Recursive"] = 0] = "Recursive";
    ValueMode[ValueMode["Reference"] = 1] = "Reference";
    ValueMode[ValueMode["Structure"] = 2] = "Structure";
    ValueMode[ValueMode["Flat"] = 3] = "Flat";
})(exports.ValueMode || (exports.ValueMode = {}));
var ValueMode = exports.ValueMode;
function getTypeOfValue(value) {
    if (value === null || value === undefined)
        return ValueType.Reference;
    if (typeof value === "function")
        return value.length ? ValueType.ComplexFunction : ValueType.ViewFunction;
    if (Array.isArray(value) || value instanceof observablearray_1.ObservableArray)
        return ValueType.Array;
    if (typeof value == 'object')
        return utils_1.isPlainObject(value) ? ValueType.PlainObject : ValueType.ComplexObject;
    return ValueType.Reference;
}
exports.getTypeOfValue = getTypeOfValue;
function extendObservableHelper(target, properties, mode, context) {
    var meta = observableobject_1.ObservableObject.asReactive(target, context, mode);
    for (var key in properties)
        if (properties.hasOwnProperty(key)) {
            meta.set(key, properties[key]);
        }
    return target;
}
exports.extendObservableHelper = extendObservableHelper;
function toGetterSetterFunction(observable) {
    var f = function (value) {
        if (arguments.length > 0)
            observable.set(value);
        else
            return observable.get();
    };
    f.$mobservable = observable;
    f.observe = function (listener, fire) {
        return observable.observe(listener, fire);
    };
    f.toString = function () {
        return observable.toString();
    };
    return f;
}
exports.toGetterSetterFunction = toGetterSetterFunction;
var AsReference = (function () {
    function AsReference(value) {
        this.value = value;
        assertUnwrapped(value, "Modifiers are not allowed to be nested");
    }
    return AsReference;
})();
exports.AsReference = AsReference;
var AsStructure = (function () {
    function AsStructure(value) {
        this.value = value;
        assertUnwrapped(value, "Modifiers are not allowed to be nested");
    }
    return AsStructure;
})();
exports.AsStructure = AsStructure;
var AsFlat = (function () {
    function AsFlat(value) {
        this.value = value;
        assertUnwrapped(value, "Modifiers are not allowed to be nested");
    }
    return AsFlat;
})();
exports.AsFlat = AsFlat;
function getValueModeFromValue(value, defaultMode) {
    if (value instanceof AsReference)
        return [ValueMode.Reference, value.value];
    if (value instanceof AsStructure)
        return [ValueMode.Structure, value.value];
    if (value instanceof AsFlat)
        return [ValueMode.Flat, value.value];
    return [defaultMode, value];
}
exports.getValueModeFromValue = getValueModeFromValue;
function getValueModeFromModifierFunc(func) {
    if (func === asReference)
        return ValueMode.Reference;
    else if (func === asStructure)
        return ValueMode.Structure;
    else if (func === asFlat)
        return ValueMode.Flat;
    else if (func !== undefined)
        throw new Error("[mobservable] Cannot determine value mode from function. Please pass in one of these: mobservable.asReference, mobservable.asStructure or mobservable.asFlat, got: " + func);
    return ValueMode.Recursive;
}
exports.getValueModeFromModifierFunc = getValueModeFromModifierFunc;
function makeChildObservable(value, parentMode, context) {
    var childMode;
    if (isObservable(value))
        return value;
    switch (parentMode) {
        case ValueMode.Reference:
            return value;
        case ValueMode.Flat:
            assertUnwrapped(value, "Items inside 'asFlat' canont have modifiers");
            childMode = ValueMode.Reference;
            break;
        case ValueMode.Structure:
            assertUnwrapped(value, "Items inside 'asStructure' canont have modifiers");
            childMode = ValueMode.Structure;
            break;
        case ValueMode.Recursive:
            _a = getValueModeFromValue(value, ValueMode.Recursive), childMode = _a[0], value = _a[1];
            break;
        default:
            throw "Illegal State";
    }
    if (Array.isArray(value) && Object.isExtensible(value))
        return observablearray_1.createObservableArray(value, childMode, true, context);
    if (utils_1.isPlainObject(value) && Object.isExtensible(value))
        return extendObservableHelper(value, value, childMode, context);
    return value;
    var _a;
}
exports.makeChildObservable = makeChildObservable;
function assertUnwrapped(value, message) {
    if (value instanceof AsReference || value instanceof AsStructure || value instanceof AsFlat)
        throw new Error("[mobservable] asStructure / asReference / asFlat cannot be used here. " + message);
}
exports.assertUnwrapped = assertUnwrapped;
function isObservableObject(thing) {
    return thing && typeof thing === "object" && thing.$mobservable instanceof observableobject_1.ObservableObject;
}
exports.isObservableObject = isObservableObject;
function isObservableArray(thing) {
    return thing instanceof observablearray_1.ObservableArray;
}
exports.isObservableArray = isObservableArray;
function isObservableMap(thing) {
    return thing instanceof observablemap_1.ObservableMap;
}
exports.isObservableMap = isObservableMap;
function observe(thing, property, listener) {
    if (arguments.length === 2) {
        listener = property;
        property = undefined;
    }
    if (typeof thing === "function") {
        console.error("[mobservable.observe] is deprecated in combination with a function, use 'mobservable.autorun' instead");
        return autorun(thing);
    }
    if (typeof listener !== "function")
        throw new Error("[mobservable.observe] expected second argument to be a function");
    if (isObservableArray(thing))
        return thing.observe(listener);
    if (isObservableMap(thing)) {
        if (property) {
            if (!thing._has(property))
                throw new Error("[mobservable.observe] the provided observable map has no key with name: " + property);
            return thing._data[property].observe(listener);
        }
        else {
            return thing.observe(listener);
        }
    }
    if (isObservableObject(thing)) {
        if (property) {
            if (!isObservable(thing, property))
                throw new Error("[mobservable.observe] the provided object has no observable property with name: " + property);
            return thing.$mobservable.values[property].observe(listener);
        }
        return thing.$mobservable.observe(listener);
    }
    if (utils_1.isPlainObject(thing))
        return observable(thing).$mobservable.observe(listener);
    throw new Error("[mobservable.observe] first argument should be an observable array, observable map, observable object or plain object.");
}
exports.observe = observe;
