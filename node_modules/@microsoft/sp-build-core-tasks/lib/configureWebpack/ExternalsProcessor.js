"use strict";
var path = require("path");
var cumulativeManifestProcessor_1 = require("./../writeManifests/cumulativeManifest/cumulativeManifestProcessor");
var Resolve_1 = require("./../utilities/Resolve");
/**
 * Get an array of a project's externals' names. To be used when creating a webpack configuration.
 */
// tslint:disable-next-line:no-any
function getExternalsKeys(gulpTask) {
    // Set the linked externals if they aren't already set
    setLinkedExternals(gulpTask);
    var result = [];
    result.push.apply(result, Object.keys(gulpTask.properties.linkedExternals));
    if (gulpTask.properties.externals) {
        result.push.apply(result, Object.keys(gulpTask.properties.externals));
    }
    return result;
}
exports.getExternalsKeys = getExternalsKeys;
/**
 * Set the linked externals in the task's shared properties object if it isn't already set
 */
// tslint:disable-next-line:no-any
function setLinkedExternals(gulpTask) {
    if (!gulpTask.properties.linkedExternals) {
        var linkedExternals = getLinkedExternals(gulpTask);
        gulpTask.properties.linkedExternals = linkedExternals;
    }
}
exports.setLinkedExternals = setLinkedExternals;
/**
 * Gets the referenced externals for a project.
 */
// tslint:disable-next-line:no-any
function getLinkedExternals(gulpTask) {
    // Discover packages that should be externalized because they have manifests
    var cumulativeManifestProcessor = new cumulativeManifestProcessor_1.default(gulpTask);
    var discoveredManifests = cumulativeManifestProcessor.discoverManifests(process.cwd(), cumulativeManifestProcessor_1.ForceSearch.deepSparseIgnoreFirstProject);
    var result = {};
    // Add these projects to externalized packages
    for (var manifestId in discoveredManifests) {
        var referencedProject = discoveredManifests[manifestId];
        if (referencedProject.packageName) {
            result[referencedProject.packageName] = {
                id: manifestId,
                name: referencedProject.packageName,
                version: referencedProject.manifestData.version
            };
        }
    }
    var nonStandardExternals = _getNonStandardExternals(gulpTask.buildConfig.rootPath);
    for (var externalName in nonStandardExternals) {
        result[externalName] = nonStandardExternals[externalName];
    }
    return result;
}
var _nonStandardExternalMap = {
    'react': {
        name: 'react',
        version: '15.4.2',
        id: '0d910c1c-13b9-4e1c-9aa4-b008c5e42d7d',
        getFailoverPath: function (packageRoot) { return path.join(packageRoot, 'dist', 'react.js'); }
    },
    'react-dom': {
        name: 'react-dom',
        version: '15.4.2',
        id: 'aa0a46ec-1505-43cd-a44a-93f3a5aa460a',
        getFailoverPath: function (packageRoot) { return path.join(packageRoot, 'dist', 'react-dom.js'); }
    },
    'office-ui-fabric-react': {
        name: 'office-ui-fabric-react',
        version: '1.0.0',
        id: '02a01e42-69ab-403d-8a16-acd128661f8e'
    }
};
/**
 * This is a temporary function that will soon be replaced by something more robust. It
 *  currently serves to include linked externals referenced in projects that don't have manifests.
 */
function _getNonStandardExternals(projectRootPath) {
    var result = {};
    for (var dependency in _nonStandardExternalMap) {
        tryFillFailoverPath(projectRootPath, _nonStandardExternalMap[dependency]);
        result[dependency] = _nonStandardExternalMap[dependency];
    }
    return result;
}
function tryFillFailoverPath(projectRootPath, dependency) {
    if (!dependency.failoverPath && dependency.getFailoverPath) {
        try {
            var resolvedPath = Resolve_1.resolvePackage(dependency.name, projectRootPath);
            dependency.failoverPath = dependency.getFailoverPath(resolvedPath);
        }
        catch (e) { }
    }
}

//# sourceMappingURL=ExternalsProcessor.js.map
