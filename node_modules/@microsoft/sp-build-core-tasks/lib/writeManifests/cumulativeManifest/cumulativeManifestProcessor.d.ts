/// <reference types="node" />
/// <reference types="webpack" />
import * as gulp from 'gulp';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { GulpTask } from '@microsoft/gulp-core-build';
import * as Webpack from 'webpack';
export declare enum ForceSearch {
    /**
     * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.
     */
    none = 0,
    /**
     * Don't force a manifest search in the first project, but use the manifests.json file in other packages.
     */
    shallow = 1,
    /**
     * Don't use the manifests.json file anywhere, and search every single package.
     */
    deep = 2,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.
     */
    deepSparse = 3,
    /**
     * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,
     *  except for the first project. Always recurse from the first project. This option is useful if it's uncertain
     *  whether the first project has been built, but otherwise "deepSparse" is intended behavior.
     */
    deepSparseIgnoreFirstProject = 4,
}
export interface ICumulativeManifestOptions {
    /**
     * IDs of manifests to exclude from the manifest map file.
     */
    ignoreOutputManifestIds?: string[];
    /**
     * The base path for debug manifests. Expected to match the result of the "debugBasePath" function passed to the
     *  WriteManifestsTask task.
     */
    baseUrl?: string;
}
export interface IReferencedProject {
    /**
     * The creation time of the newest version of this manifest we've found
     */
    manifestCreationTime: number;
    /**
     * The project's manifest data
     */
    manifestData: IClientSideComponentManifest;
    /**
     * The root path of the project.
     */
    packagePath: string;
    /**
     * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only
     *  one manifest.
     */
    packageName: string;
}
export interface IReferencedProjectMap {
    [id: string]: IReferencedProject;
}
export default class CumulativeManifestProcessor {
    private _options;
    private _parentTask;
    private _discoveryCache;
    constructor(parentTask: GulpTask<any>, options?: ICumulativeManifestOptions);
    /**
     * Ths function:
     *  1. discovers all packages referenced in package.json
     *  2a. looks for a file in each discovered project's temp folder called manifests.json
     *  2b. looks for <id>.manifest.json files in the dist folder
     *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by
     *      taking the newest file
     *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when "gulp serve"
     *      is run from this current project's directory
     *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all
     *      manifests
     *  6. filters this array by the ignoreOutputManifestIds options
     *  7. drops a JSON file in the temp directory called manifests.json containing this array
     *  9. drops an initialization script in the temp directory called manifests.js that
     *      exports two functions. One that retruns the array with the manifests' base URLs as fully-qualified, and the
     *      other with manifests' base URLs as relative to the page root.
     */
    generateCumulativeManifest(gulp: gulp.Gulp, debugManifests: IClientSideComponentManifest[]): NodeJS.ReadWriteStream[];
    readonly manifestsFilePath: string;
    getManifestsFileWebpackConfig(manifestsArray: IClientSideComponentManifest[]): Webpack.Configuration;
    reset(): void;
    discoverManifests(packagePath: string, forceSearchMode: ForceSearch): IReferencedProjectMap;
    private _getTransformedManifest(referenceProject, baseUrl);
}
