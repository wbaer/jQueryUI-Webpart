"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require("path");
var fs = require("fs");
var glob = require("glob");
var lodash_1 = require("lodash");
var constants_1 = require("./../constants");
var OdspGulpTask_1 = require("./../OdspGulpTask");
exports.escapedTokenRegExp = new RegExp(lodash_1.escapeRegExp(lodash_1.escapeRegExp(constants_1.default.localeToken)));
exports.escapedTokenGlobalRegExp = new RegExp(lodash_1.escapeRegExp(lodash_1.escapeRegExp(constants_1.default.localeToken)), 'g');
/**
 * Discovers strings based on the pattern described in config.json
 */
var CollectLocalizedResourcesTask = (function (_super) {
    __extends(CollectLocalizedResourcesTask, _super);
    function CollectLocalizedResourcesTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'collectLocalizedResources';
        _this.taskConfig = {};
        return _this;
    }
    CollectLocalizedResourcesTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        var libPath = path.join(this.buildConfig.rootPath, this.buildConfig.libFolder);
        var localizedResources = this.properties.localizedResources || {};
        var localizedResourceKeys = Object.keys(localizedResources);
        this.logVerbose(localizedResourceKeys.length + " localized resources defined.");
        this.properties.discoveredLocalizedResources = {};
        var promises = localizedResourceKeys.map(function (key) {
            return _this._collectResourcesForKey(libPath, localizedResources[key])
                .then(function (result) {
                _this.properties.discoveredLocalizedResources[key] = result;
            })
                .catch(function (error) {
                throw "Error for resource \"" + key + "\": " + error;
            });
        });
        return Promise.all(promises)
            .then(function () { return completeCallback(); })
            .catch(completeCallback);
    };
    CollectLocalizedResourcesTask.prototype._collectResourcesForKey = function (libPath, rawPattern) {
        var _this = this;
        // If the pattern doesn't have a leading slash, include one so the glob pattern resolves to under the lib directory.
        var rawPatternMatches = rawPattern.match(/(?:^\/+)(.+)/);
        var pattern = rawPatternMatches ? rawPatternMatches[1] : rawPattern;
        if (rawPatternMatches) {
            this.logWarning("The localized file pattern \"" + rawPattern + "\" contains a leading slash. These patterns resolve " +
                ("to paths under the \"" + this.buildConfig.libFolder + "\" directory, so they are intended to be ") +
                'relative. A leading slash is not recommended and may produce Unexpected behavior.');
        }
        return new Promise(function (resolve, reject) {
            if (!pattern.match(CollectLocalizedResourcesTask._localeTokenRegExp)) {
                // Singleton locale, no pattern token
                var fullPath_1 = path.join(libPath, pattern);
                fs.stat(fullPath_1, function (error) {
                    if (error) {
                        // Singleton not found, throw an error
                        reject("Singleton resource \"" + rawPattern + "\" not found.");
                    }
                    else {
                        // Singleton found, resolve as the default locale
                        resolve({
                            default: fullPath_1
                        });
                    }
                });
            }
            else {
                var globPattern = pattern.replace(CollectLocalizedResourcesTask._localeTokenRegExp, '*');
                glob(globPattern, { cwd: libPath }, function (error, files) {
                    if (error) {
                        reject(error.message);
                    }
                    else if (files.length === 0) {
                        reject("No localized files found under the \"" + _this.buildConfig.libFolder + "\" directory matching " +
                            ("pattern \"" + rawPattern + "\""));
                    }
                    else {
                        // This turns a pattern that looks something like this: "asdf\{locale}/{locale}/{locale}.js"
                        //  into a regex that looks something like this: /asdf\/(.+)\/(?:\\1)\/(?:\\1).js/
                        var normalizedPattern = path.posix.resolve('/', pattern).substr(1);
                        var regexPattern_1 = new RegExp(lodash_1.escapeRegExp(normalizedPattern)
                            .replace(exports.escapedTokenRegExp, '(.+)')
                            .replace(exports.escapedTokenGlobalRegExp, '(?:\\1)'));
                        var result_1 = {};
                        files.forEach(function (file) {
                            var posixFile = file.replace(/\\/g, '/');
                            var match = posixFile.match(regexPattern_1);
                            if (!match) {
                                _this.logWarning("Unexpected file path: \"" + file + "\"");
                            }
                            else {
                                var locale = match[1];
                                _this.logVerbose("Found file \"" + file + "\", identified as locale \"" + locale + "\"");
                                result_1[locale] = path.join(libPath, file);
                            }
                        });
                        resolve(result_1);
                    }
                });
            }
        });
    };
    return CollectLocalizedResourcesTask;
}(OdspGulpTask_1.default));
CollectLocalizedResourcesTask._localeToken = '{locale}';
CollectLocalizedResourcesTask._localeTokenRegExp = new RegExp(CollectLocalizedResourcesTask._localeToken, 'g');
exports.CollectLocalizedResourcesTask = CollectLocalizedResourcesTask;

//# sourceMappingURL=CollectLocalizedResourcesTask.js.map
