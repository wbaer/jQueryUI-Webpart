export declare function checkIfStateIsBeingModifiedDuringView(context: IContextInfoStruct): void;
export declare function transaction<T>(action: () => T, thisArg?: any): T;
export declare function runAfterTransaction(action: () => void): void;
export declare function isInTransaction(): boolean;
export declare function untracked<T>(action: () => T): T;
export declare enum NodeState {
    STALE = 0,
    PENDING = 1,
    READY = 2,
}
export declare class DataNode {
    id: number;
    state: NodeState;
    observers: ViewNode[];
    protected isDisposed: boolean;
    externalRefenceCount: number;
    context: IContextInfoStruct;
    constructor(context: IContextInfoStruct);
    setRefCount(delta: number): void;
    addObserver(node: ViewNode): void;
    removeObserver(node: ViewNode): void;
    markStale(): void;
    markReady(stateDidActuallyChange: boolean): void;
    notifyObservers(stateDidActuallyChange?: boolean): void;
    notifyObserved(): void;
    dispose(): void;
    toString(): string;
}
export declare class ViewNode extends DataNode {
    isSleeping: boolean;
    hasCycle: boolean;
    observing: DataNode[];
    private prevObserving;
    private dependencyChangeCount;
    private dependencyStaleCount;
    private onSleepEmitter;
    setRefCount(delta: number): void;
    removeObserver(node: ViewNode): void;
    tryToSleep(): void;
    wakeUp(): void;
    notifyStateChange(observable: DataNode, stateDidActuallyChange: boolean): void;
    computeNextState(): void;
    compute(): boolean;
    private trackDependencies();
    private bindDependencies();
    private findCycle(node);
    onceSleep(onSleep: (lastValue: any) => void): void;
    dispose(): void;
}
export declare function stackDepth(): any;
export declare function isComputingView(): boolean;
import { IContextInfoStruct } from './interfaces';
