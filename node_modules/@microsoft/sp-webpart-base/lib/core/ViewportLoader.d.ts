import IViewportAwareWebpart from './IViewportAwareWebpart';
/**
 * Class that helps lazy loading of web parts. This class centrally manages
 * registered web parts to be rendered lazily when in the viewport. i.e. Web parts
 * that are not in the view port will not be rendered on the initial load. They will
 * be rendered only when the user scrolls to the web part. This class manages the
 * scroll/resize event handling and notification to the web parts to render when
 * they are near the viewport.
 *
 * E.g. Modern pages web parts in viewport will be loaded. All other web parts are
 * lazily loaded when the user scrolls the view port and that perticular web part is
 * in the view.
 *
 * @internal
 */
export default class ViewportLoader {
    /**
     * Registered web parts.
     */
    private _webparts;
    /**
     * This attribute managed the number of scroll event handlers that are registered to
     * a scrollable parent. When the number of events becomes zero, the event handler is
     * unregistered.
     */
    private readonly _lazyLoadedTrackerAttribute;
    private readonly SCROLL;
    private readonly RESIZE;
    /**
     * This is a throttled version of the lazy event handler. This is used to make sure
     * we do not call the scroll event handler too often.
     */
    private _lazyHandler;
    private _isInitialized;
    private _logSource;
    private _initTime;
    private _isListeningWindow;
    /**
    * Contructor to bind all methods
    */
    constructor();
    /**
     * Determines if a web part should be lazily loaded and register such web parts.
     */
    register(webpart: IViewportAwareWebpart): void;
    /**
     * Unregister a loaded web part which should not be tracked any more.
     */
    unregister(webpart: IViewportAwareWebpart): void;
    /**
     * Bind all functions to this instance
     */
    private _bind();
    /**
     * Event handler which is called upon scroll and resize events.
     */
    private _lazyLoaderEventHandler();
    /**
    * Handler to start rendering web part if it is close enough to the viewport.
    */
    private _checkVisibilityAndRender(webpart);
    /**
    * Check if web part is close enough to the viewport to be shown.
    */
    private _isCloseToViewport(webpartNode);
    /**
    * Returns all scrollable parent DOM Elements of the given element
    */
    private _findScrollableParents(startingElement);
    /**
     * Traverses up the DOM tree for the element with the data-is-scrollable=true attribute,
     * or return the window object.
     */
    private _findScrollableParent(startingElement);
    private _initialize();
    private _dispose();
    /**
    * Start listening to scroll and resize events. It is safe to call this API multiple times on a DOM
    * element, it does not lead to multiple attached events.
    */
    private _listenEvents(parent);
    /**
     * Add Listener to scroll and resize events for given element or window
     */
    private _addEventListerer(element);
    /**
    * Stop listening to scroll and resize events.
    */
    private _unlistenEvents(parent);
    /**
     * Remove Listeners from scroll and resize events for given element or window
     */
    private _removeEventListener(element);
    /**
     * It keeps track of how many lazily loaded children are registered to a scrollable parent.
     * This record keeping is required to deregister event handler from the parent when There
     * are no children listening to events.
     */
    private _updateRegisteredChildren(element, count);
    /**
     * Ask web part to load.
     */
    private _renderWebpartInViewport(webpart);
}
