"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lodash = require("lodash");
var path = require("path");
var ExternalsProcessor_1 = require("./ExternalsProcessor");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var constants_1 = require("./../constants");
var CopyAssetsTask_1 = require("./../copyAssets/CopyAssetsTask");
/**
 * Configures the @microsoft/gulp-core-build-webpack task to bundle localized externals into another, pre-built package.
 *
 * Example:
 *  IN:
 *    setConfig({
 *      webpack: <reference to webpack task>,
 *      localizedResources: <optional - list of localized externals>
 *      configureWebpackTask: <reference to the ConfigureWebpackTask task>,
 *      debugLocale: <optional - locale to use for a debug build>,
 *      additionalLoaders: <optional - additional loaders for localized resources>
 *    })
 *
 *  OUT:
 *    If any resources are specified and found, set webpack config to:
 *      {
 *        entry: <entries with locales>,
 *        module: {
 *          loaders: ([
 *            {
 *              loader: 'json-loader',
 *              test: /\.json$/
 *            }
 *          ] <and additional loaders, if specified>,
 *          noParse: [ /\.map$/ ],
 *          postLoaders: [],
 *          preLoaders: []
 *        },
 *        resolve: {
 *          alias: <localized resources>,
 *          modulesDirectories: [
 *            '',
 *            'node_modules',
 *            'lib'
 *          ]
 *        },
 *        resolveLoader: {
 *          root: <node modules folder>
 *        },
 *        context: <dist directory>,
 *        devtool: 'source-map',
 *        externals: <externals and non-specified locales>,
 *        entry: webpackEntries,
 *        output: {
 *          libraryTarget: <library target from configureWebpackTask, if specified> or 'amd',
 *          path: this.outputDirectory
 *        },
 *        plugins: []
 *      }
 */
var ConfigureExternalBundlingWebpackTask = (function (_super) {
    __extends(ConfigureExternalBundlingWebpackTask, _super);
    function ConfigureExternalBundlingWebpackTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'configure-webpack-external-bundling';
        _this.taskConfig = {
            webpack: undefined,
            localizedResources: undefined,
            bundleAllLocalizedResources: false
        };
        return _this;
    }
    ConfigureExternalBundlingWebpackTask.prototype.loadSchema = function () {
        return require('./configure-webpack-external-bundling.schema.json');
    };
    ConfigureExternalBundlingWebpackTask.prototype.setConfig = function (config) {
        if (config.webpack && config.webpack.name !== 'webpack') {
            this.logWarning('Setting webpack property to non-"@microsoft/gulp-core-build-webpack"-type will ' +
                'prevent configuration');
        }
        _super.prototype.mergeConfig.call(this, config);
    };
    ConfigureExternalBundlingWebpackTask.prototype.executeTask = function (gulp, completeCallback) {
        if (!this.taskConfig.webpack) {
            this.logWarning('"webpack" is not defined in the task configuration. Nothing to configure.');
            completeCallback();
            return;
        }
        if (!this.taskConfig.configureWebpackTask) {
            this.logError('"configureWebpackTask" is not defined in the task configuration.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        if (!this._shouldBeEnabled) {
            this.logVerbose('No localized resources specified, nothing to do.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        if (!this.properties.webpackStats) {
            this.logError('Missing webpack stats object. Unable to configure.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        var resourcesToBundle = this._pruneLocalizedResources();
        if (resourcesToBundle.length === 0) {
            this.logVerbose('None of the specified localized resources were present in the webpack stats object. Nothing ' +
                'to do.');
            this._setWebpackConfig(undefined);
            completeCallback();
            return;
        }
        // When we run webpack again, it'll overwrite this.properties.webpackStats, and we want to remember the
        //  webpack stats object from the first webpack run.
        this.properties.initialWebpackStats = this.properties.webpackStats;
        var resolveResult;
        try {
            resolveResult = this._resolveResources(resourcesToBundle);
        }
        catch (error) {
            completeCallback(error);
            return;
        }
        var locales = resolveResult.locales;
        var localizedResourcesToBundle = resolveResult.localizedResourcesToBundle;
        var externalsKeys = ExternalsProcessor_1.getExternalsKeys(this);
        var localizedResources = this.properties.localizedResources || {};
        var localizedResourcesKeys = Object.keys(localizedResources).filter(function (key) {
            return localizedResourcesToBundle.indexOf(key) === -1;
        });
        if (!this.properties.bundledExternals) {
            this.properties.bundledExternals = [];
        }
        (_a = this.properties.bundledExternals).push.apply(_a, localizedResourcesToBundle);
        var webpackEntries = this._generateWebpackEntries(locales);
        var config = {
            module: {
                loaders: [
                    {
                        loader: 'json-loader',
                        test: /\.json$/
                    }
                ].concat(this.taskConfig.additionalLoaders || []),
                noParse: [/\.map$/],
                postLoaders: [],
                preLoaders: this.buildConfig.production
                    ? []
                    : [
                        {
                            test: /\.js$/,
                            loader: 'source-map-loader'
                        }
                    ]
            },
            resolve: {
                alias: {},
                modulesDirectories: [
                    '',
                    'node_modules',
                    'lib'
                ]
            },
            resolveLoader: {
                root: path.join(__dirname, '..', '..', 'node_modules')
            },
            context: this.outputDirectory,
            devtool: this.buildConfig.production ? undefined : 'source-map',
            externals: externalsKeys.concat(localizedResourcesKeys),
            entry: webpackEntries,
            output: {
                library: this.properties.webpackLibraryName,
                libraryTarget: 'amd',
                path: this.outputDirectory,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[hash]'
            }
        };
        // VSO#258841: Minification here doesn't make a big deal (<1kb gzipped), but adds a lot of build time.
        //  This can updated eventually to drop a fake base bundle, run webpack, and then replace the fake bundle
        //  with the real payload.
        // if (this.buildConfig.production) {
        //   config.plugins.push(new webpack.optimize.UglifyJsPlugin({
        //     compress: {
        //       dead_code: false,
        //       warnings: false
        //     },
        //     mangle: true
        //   }));
        // }
        this.taskConfig.configureWebpackTask.tinkerWithLocConfig(config);
        var configs = [];
        for (var _i = 0, locales_1 = locales; _i < locales_1.length; _i++) {
            var locale = locales_1[_i];
            var localeWebpackConfig = lodash.cloneDeep(config);
            for (var _b = 0, localizedResourcesToBundle_1 = localizedResourcesToBundle; _b < localizedResourcesToBundle_1.length; _b++) {
                var resourceName = localizedResourcesToBundle_1[_b];
                var path_1 = this.properties.discoveredLocalizedResources[resourceName][locale];
                localeWebpackConfig.resolve.alias[resourceName] = path_1;
            }
            localeWebpackConfig.output.filename = "[name]_" + locale + ".js";
            localeWebpackConfig.output.chunkFilename = "[id].[name]_" + locale + "_[chunkhash].js";
            configs.push(localeWebpackConfig);
        }
        this._setWebpackConfig(configs);
        completeCallback();
        var _a;
    };
    /**
     * Modify the base webpack config to make sure we get what we need after that webpack intance runs.
     *
     * @internal
     */
    ConfigureExternalBundlingWebpackTask.prototype.tinkerWithBaseWebpackConfig = function (config) {
        if (this._shouldBeEnabled) {
            config.output.libraryTarget = 'amd';
        }
    };
    ConfigureExternalBundlingWebpackTask.prototype._resolveResources = function (localizedResources) {
        // Ensure that all localized resoureces specified exist.
        var localizedResourcesToBundle = [];
        var notFoundResources = [];
        var mismatchResources = [];
        var locales;
        for (var _i = 0, localizedResources_1 = localizedResources; _i < localizedResources_1.length; _i++) {
            var resourceName = localizedResources_1[_i];
            var discoveredResources = (this.properties.discoveredLocalizedResources || {})[resourceName];
            if (!discoveredResources || Object.keys(discoveredResources).length === 0) {
                notFoundResources.push(resourceName);
            }
            else {
                var resourceLocales = this._filterLocales(Object.keys(discoveredResources));
                if (!locales) {
                    locales = resourceLocales;
                    localizedResourcesToBundle.push(resourceName);
                    continue;
                }
                var notMatch = resourceLocales.length !== locales.length;
                for (var i = 0; i < resourceLocales.length && !notMatch; i++) {
                    notMatch = notMatch || (locales.indexOf(resourceLocales[i]) === -1);
                }
                if (notMatch) {
                    mismatchResources.push(resourceName);
                }
                else {
                    localizedResourcesToBundle.push(resourceName);
                }
            }
        }
        if (notFoundResources.length > 0) {
            throw "Specified resources not found: " + notFoundResources.join(', ') + ".";
        }
        if (mismatchResources.length > 0) {
            throw 'All resources must have exactly the same locales. Some resources do not match the locales ' +
                ("specified by the first (" + locales.join(', ') + "): " + mismatchResources.join(', '));
        }
        return { locales: locales, localizedResourcesToBundle: localizedResourcesToBundle };
    };
    ConfigureExternalBundlingWebpackTask.prototype._filterLocales = function (locales) {
        if (!this.buildConfig.production) {
            // If this is a non-production build, don't build every locale. Just build the specified or default locale.
            var localeHasBeenFiltered = false;
            if (locales.indexOf(this.taskConfig.debugLocale) !== -1) {
                locales = [this.taskConfig.debugLocale];
                localeHasBeenFiltered = true;
            }
            else if (locales.indexOf(constants_1.default.defaultLocale) !== -1) {
                locales = [constants_1.default.defaultLocale];
                localeHasBeenFiltered = true;
            }
            else {
                this.logError("Unable to find a debug locale (" + (this.taskConfig.debugLocale || 'unspecified') + ") or a default " +
                    ("locale (" + constants_1.default.defaultLocale + "). All locales will be built. This may be time-consuming."));
            }
            if (localeHasBeenFiltered) {
                this.logVerbose("Locales have been filtered to " + JSON.stringify(locales) + " for debug build.");
            }
        }
        return locales;
    };
    ConfigureExternalBundlingWebpackTask.prototype._generateWebpackEntries = function (locales) {
        var _this = this;
        var entries = this.properties.bundleEntries || [];
        var webpackEntries = {};
        entries.forEach(function (entry) {
            var entryName = path.basename(entry.nonLocalizedEntrypointPath, '.js');
            webpackEntries[entryName] = path.join(_this.outputDirectory, entryName + ".js");
            entry.nonLocalizedEntrypointPath = undefined;
            entry.localizedEntrypointPaths = {};
            locales.forEach(function (locale) {
                entry.localizedEntrypointPaths[locale] = path.join(_this.outputDirectory, entryName + "_" + locale + ".js");
            });
        });
        return webpackEntries;
    };
    ConfigureExternalBundlingWebpackTask.prototype._pruneLocalizedResources = function () {
        var modules = this.properties.webpackStats.toJson({ modules: true }).modules;
        var filteredResources = [];
        for (var _i = 0, modules_1 = modules; _i < modules_1.length; _i++) {
            var module_1 = modules_1[_i];
            var matches = module_1.name.match(CopyAssetsTask_1.externalsRegex);
            if (matches) {
                var externalName = matches[1];
                if ((this.taskConfig.bundleAllLocalizedResources &&
                    this.properties.discoveredLocalizedResources[externalName]) ||
                    (this.taskConfig.localizedResources && this.taskConfig.localizedResources.indexOf(externalName) !== -1)) {
                    filteredResources.push(externalName);
                }
            }
        }
        return filteredResources;
    };
    Object.defineProperty(ConfigureExternalBundlingWebpackTask.prototype, "_shouldBeEnabled", {
        get: function () {
            return this.taskConfig.configureWebpackTask &&
                (this.taskConfig.bundleAllLocalizedResources &&
                    this.taskConfig.configureWebpackTask.properties.discoveredLocalizedResources &&
                    Object.keys(this.taskConfig.configureWebpackTask.properties.discoveredLocalizedResources).length !== 0) ||
                (this.taskConfig.localizedResources &&
                    this.taskConfig.localizedResources.length !== 0);
        },
        enumerable: true,
        configurable: true
    });
    ConfigureExternalBundlingWebpackTask.prototype._setWebpackConfig = function (config) {
        var webpackTask = this.taskConfig.webpack;
        if (webpackTask) {
            if (!config) {
                // We're just going to disable the second webpack task
                webpackTask.isEnabled = function () { return false; };
            }
            else {
                webpackTask.setConfig({
                    config: config,
                    configPath: null // tslint:disable-line:no-null-keyword
                });
            }
        }
    };
    return ConfigureExternalBundlingWebpackTask;
}(OdspGulpTask_1.default));
exports.ConfigureExternalBundlingWebpackTask = ConfigureExternalBundlingWebpackTask;

//# sourceMappingURL=ConfigureExternalBundlingWebpackTask.js.map
