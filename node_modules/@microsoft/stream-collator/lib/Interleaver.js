/**
 * @file Interleaver.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * A factory which creates streams designed for processes running in parallel to write their output to.
 */
"use strict";
var colors = require('colors');
var os = require('os');
var TaskWriterState;
(function (TaskWriterState) {
    TaskWriterState[TaskWriterState["Open"] = 1] = "Open";
    TaskWriterState[TaskWriterState["ClosedUnwritten"] = 2] = "ClosedUnwritten";
    TaskWriterState[TaskWriterState["Written"] = 3] = "Written";
})(TaskWriterState || (TaskWriterState = {}));
var ITaskOutputStream;
(function (ITaskOutputStream) {
    ITaskOutputStream[ITaskOutputStream["stdout"] = 1] = "stdout";
    ITaskOutputStream[ITaskOutputStream["stderr"] = 2] = "stderr";
    ITaskOutputStream[ITaskOutputStream["warning"] = 3] = "warning";
})(ITaskOutputStream || (ITaskOutputStream = {}));
/**
 * A static class which manages the output of multiple threads.
 * @todo #168348: make this class not be static
 * @todo #168349: add ability to inject stdout WritableStream
 * @todo #168350: add unit testing
 */
var Interleaver = (function () {
    /**
     * A constructor which throws an exception if used
     */
    function Interleaver() {
        throw Error('do not use constructor directly, only static functions');
    }
    /**
     * Resets the default output stream
     */
    Interleaver.setStdOut = function (stdout) {
        this._stdout = stdout;
    };
    /**
     * Registers a task into the list of active buffers and returns a ITaskWriter for the
     * calling process to use to manage output.
     */
    Interleaver.registerTask = function (taskName, quietMode) {
        var _this = this;
        if (quietMode === void 0) { quietMode = false; }
        if (this._tasks.has(taskName)) {
            throw new Error('A task with that name has already been registered');
        }
        this._tasks.set(taskName, {
            quietMode: quietMode,
            state: TaskWriterState.Open,
            stderr: [],
            stdout: []
        });
        if (this._activeTask === undefined) {
            this._activeTask = taskName;
        }
        return {
            close: function () { return _this._completeTask(taskName); },
            getStdError: function () { return _this._getTaskOutput(taskName, ITaskOutputStream.stderr); },
            getStdOutput: function () { return _this._getTaskOutput(taskName); },
            write: function (data) { return _this._writeTaskOutput(taskName, data); },
            writeError: function (data) {
                var stream = (data.indexOf('Warning - ') === 0) ?
                    ITaskOutputStream.warning :
                    ITaskOutputStream.stderr;
                _this._writeTaskOutput(taskName, data, stream);
            },
            writeLine: function (data) { return _this._writeTaskOutput(taskName, data + os.EOL); }
        };
    };
    /**
     * Removes information about all running tasks
     */
    Interleaver.reset = function () {
        this._activeTask = undefined;
        this._tasks = new Map();
    };
    /**
     * Adds the text to the tasks's buffer, and writes it to the console if it is the active task
     */
    Interleaver._writeTaskOutput = function (taskName, data, stream) {
        if (stream === void 0) { stream = ITaskOutputStream.stdout; }
        var taskInfo = this._tasks.get(taskName);
        if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {
            throw new Error('The task is not registered or has been completed and written.');
        }
        var outputBuffer = (stream === ITaskOutputStream.stderr ? taskInfo.stderr : taskInfo.stdout);
        if (!this._activeTask) {
            this._activeTask = taskName;
            this._writeTask(taskName, taskInfo);
            taskInfo.state = TaskWriterState.Open;
        }
        outputBuffer.push(data);
        if (this._activeTask === taskName) {
            if (stream === ITaskOutputStream.stdout && !taskInfo.quietMode) {
                this._stdout.write(data);
            }
            else if (stream === ITaskOutputStream.warning && !taskInfo.quietMode) {
                this._stdout.write(colors.yellow(data));
            }
            else if (stream === ITaskOutputStream.stderr) {
                this._stdout.write(colors.red(data));
            }
        }
    };
    /**
     * Returns the current value of the task's buffer
     */
    Interleaver._getTaskOutput = function (taskName, stream) {
        if (stream === void 0) { stream = ITaskOutputStream.stdout; }
        var taskInfo = this._tasks.get(taskName);
        return (stream === ITaskOutputStream.stdout ? taskInfo.stdout : taskInfo.stderr).join('');
    };
    /**
     * Marks a task as completed. There are 3 cases:
     *  - If the task was the active task, also write out all completed, unwritten tasks
     *  - If there is no active task, write the output to the screen
     *  - If there is an active task, mark the task as completed and wait for active task to complete
     */
    Interleaver._completeTask = function (taskName) {
        var taskInfo = this._tasks.get(taskName);
        if (!taskInfo || taskInfo.state !== TaskWriterState.Open) {
            throw new Error('The task is not registered or has been completed and written.');
        }
        if (this._activeTask === undefined) {
            this._writeTask(taskName, taskInfo);
        }
        else if (taskName === this._activeTask) {
            this._activeTask = undefined;
            taskInfo.state = TaskWriterState.Written;
            this._writeAllCompletedTasks();
        }
        else {
            taskInfo.state = TaskWriterState.ClosedUnwritten;
        }
    };
    /**
     * Helper function which writes all completed tasks
     */
    Interleaver._writeAllCompletedTasks = function () {
        var _this = this;
        this._tasks.forEach(function (task, taskName) {
            if (task && task.state === TaskWriterState.ClosedUnwritten) {
                _this._writeTask(taskName, task);
            }
        });
    };
    /**
     * Write and delete task
     */
    Interleaver._writeTask = function (taskName, taskInfo) {
        taskInfo.state = TaskWriterState.Written;
        if (!taskInfo.quietMode) {
            this._stdout.write(taskInfo.stdout.join(''));
        }
        this._stdout.write(colors.red(taskInfo.stderr.join('')));
    };
    Interleaver._tasks = new Map();
    Interleaver._activeTask = undefined;
    Interleaver._stdout = process.stdout;
    return Interleaver;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Interleaver;

//# sourceMappingURL=Interleaver.js.map
