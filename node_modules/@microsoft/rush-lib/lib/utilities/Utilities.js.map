{"version":3,"sources":["utilities/Utilities.ts"],"names":[],"mappings":"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","file":"utilities/Utilities.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as child_process from 'child_process';\r\nimport * as fsx from 'fs-extra';\r\nimport * as os from 'os';\r\nimport * as rimraf from 'rimraf';\r\nimport * as tty from 'tty';\r\n\r\nexport default class Utilities {\r\n  /**\r\n   * For a scoped NPM package name this separates the scope and name parts.  For example:\r\n   * parseScopedPackageName('@my-scope/myproject') = { scope: '@my-scope', name: 'myproject' }\r\n   * parseScopedPackageName('myproject') = { scope: '', name: 'myproject' }\r\n   */\r\n  public static parseScopedPackageName(scopedName: string): { scope: string, name: string } {\r\n    if (scopedName.substr(0, 1) !== '@') {\r\n      return { scope: '', name: scopedName };\r\n    }\r\n\r\n    const slashIndex: number = scopedName.indexOf('/');\r\n    if (slashIndex >= 0) {\r\n      return { scope: scopedName.substr(0, slashIndex), name: scopedName.substr(slashIndex + 1) };\r\n    } else {\r\n      throw new Error('Invalid scoped name: ' + scopedName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * NodeJS equivalent of performance.now().\r\n   */\r\n  public static getTimeInMs(): number {\r\n    let seconds: number;\r\n    let nanoseconds: number;\r\n    [seconds, nanoseconds] = process.hrtime();\r\n    return seconds * 1000 + nanoseconds / 1000000;\r\n  }\r\n\r\n  /**\r\n   * Returns the values from a Set<T>\r\n   */\r\n  public static getSetAsArray<T>(set: Set<T>): T[] {\r\n    // When ES6 is supported, we can use Array.from() instead.\r\n    const result: T[] = [];\r\n    set.forEach((value: T) => {\r\n      result.push(value);\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Retries a function until a timeout is reached. The function is expected to throw if it failed and\r\n   *  should be retried.\r\n   */\r\n  public static retryUntilTimeout<TResult>(fn: () => TResult,\r\n                                           maxWaitTimeMs: number,\r\n                                           getTimeoutError: (innerError: Error) => Error,\r\n                                           fnName: string): TResult {\r\n    const startTime: number = Utilities.getTimeInMs();\r\n    let looped: boolean = false;\r\n\r\n    let result: TResult;\r\n    // tslint:disable-next-line:no-constant-condition\r\n    while (true) {\r\n      try {\r\n        result = fn();\r\n        break;\r\n      } catch (e) {\r\n        looped = true;\r\n        const currentTime: number = Utilities.getTimeInMs();\r\n        if (currentTime - startTime > maxWaitTimeMs) {\r\n          throw getTimeoutError(e);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (looped) {\r\n      const currentTime: number = Utilities.getTimeInMs();\r\n      const totalSeconds: string = ((currentTime - startTime) / 1000.0).toFixed(2);\r\n      console.log(`${fnName}() stalled for ${totalSeconds} seconds`);\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  public static createFolderWithRetry(folderName: string): void {\r\n    // We need to do a simple \"fs.mkdirSync(localModulesFolder)\" here,\r\n    // however if the folder we deleted above happened to contain any files,\r\n    // then there seems to be some OS process (virus scanner?) that holds\r\n    // a lock on the folder for a split second, which causes mkdirSync to\r\n    // fail.  To workaround that, retry for up to 7 seconds before giving up.\r\n    const maxWaitTimeMs: number = 7 * 1000;\r\n\r\n    return Utilities.retryUntilTimeout(() => fsx.mkdirSync(folderName),\r\n                                       maxWaitTimeMs,\r\n                                       (e) => new Error(`Error: ${e}${os.EOL}Often this is caused by a file lock ` +\r\n                                                        'from a process such as your text editor, command prompt, ' +\r\n                                                        'or \"gulp serve\"'),\r\n                                       'createFolderWithRetry');\r\n  }\r\n\r\n  /**\r\n   * Determines if the path points to a file and that it exists.\r\n   */\r\n  public static fileExists(path: string): boolean {\r\n    let exists: boolean = false;\r\n\r\n    try {\r\n      const lstat: fsx.Stats = fsx.lstatSync(path);\r\n      exists = lstat.isFile();\r\n    } catch (e) { /* no-op */ }\r\n\r\n    return exists;\r\n  }\r\n\r\n  /**\r\n   * Determines if a path points to a directory and that it exists.\r\n   */\r\n  public static directoryExists(path: string): boolean {\r\n    let exists: boolean = false;\r\n\r\n    try {\r\n      const lstat: fsx.Stats = fsx.lstatSync(path);\r\n      exists = lstat.isDirectory();\r\n    } catch (e) { /* no-op */ }\r\n\r\n    return exists;\r\n  }\r\n\r\n  /**\r\n   * BE VERY CAREFUL CALLING THIS FUNCTION!\r\n   * If you specify the wrong folderPath (e.g. \"/\"), it could potentially delete your entire\r\n   * hard disk.\r\n   */\r\n  public static dangerouslyDeletePath(folderPath: string): void {\r\n    try {\r\n      rimraf.sync(folderPath, { disableGlob: true });\r\n    } catch (e) {\r\n      throw new Error(e.message + os.EOL + 'Often this is caused by a file lock'\r\n        + ' from a process such as your text editor, command prompt, or \"gulp serve\"');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempts to delete a file. If it does not exist, or the path is not a file, it no-ops.\r\n   */\r\n  public static deleteFile(filePath: string): void {\r\n    if (Utilities.fileExists(filePath)) {\r\n      console.log(`Deleting: ${filePath}`);\r\n      fsx.unlinkSync(filePath);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * Returns true if outputFilename has a more recent last modified timestamp\r\n   * than all of the inputFilenames, which would imply that we don't need to rebuild it.\r\n   * Returns false if any of the files does not exist.\r\n   * NOTE: The filenames can also be paths for directories, in which case the directory\r\n   * timestamp is compared.\r\n   */\r\n  public static isFileTimestampCurrent(outputFilename: string, inputFilenames: string[]): boolean {\r\n    if (!fsx.existsSync(outputFilename)) {\r\n      return false;\r\n    }\r\n    const outputStats: fsx.Stats = fsx.statSync(outputFilename);\r\n\r\n    for (const inputFilename of inputFilenames) {\r\n      if (!fsx.existsSync(inputFilename)) {\r\n        return false;\r\n      }\r\n\r\n      const inputStats: fsx.Stats = fsx.statSync(inputFilename);\r\n      if (outputStats.mtime < inputStats.mtime) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Returns the width of the console, measured in columns\r\n   */\r\n  public static getConsoleWidth(): number {\r\n    const stdout: tty.WriteStream = process.stdout as tty.WriteStream;\r\n    if (stdout && stdout.columns) {\r\n      return stdout.columns;\r\n    }\r\n    return 80;\r\n  }\r\n\r\n  /**\r\n   * Executes the command with the specified command-line parameters, and waits for it to complete.\r\n   * The current directory will be set to the specified workingDirectory.\r\n   */\r\n  public static executeCommand(command: string, args: string[], workingDirectory: string,\r\n    suppressOutput: boolean = false, environmentVariables?: { [key: string]: string }): void {\r\n\r\n    Utilities._executeCommandInternal(command, args, workingDirectory,\r\n      suppressOutput ? undefined : [0, 1, 2],\r\n      environmentVariables);\r\n  }\r\n\r\n  /**\r\n   * Executes the command with the specified command-line parameters, and waits for it to complete.\r\n   * The current directory will be set to the specified workingDirectory.\r\n   */\r\n  public static executeCommandAndCaptureOutput(command: string, args: string[], workingDirectory: string,\r\n    environmentVariables?: { [key: string]: string }): string {\r\n\r\n    const  result: child_process.SpawnSyncReturns<Buffer>\r\n      = Utilities._executeCommandInternal(command, args, workingDirectory,\r\n        ['pipe', 'pipe', 'pipe'], environmentVariables);\r\n\r\n    return result.stdout.toString();\r\n  }\r\n\r\n  /**\r\n   * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.\r\n   */\r\n  public static executeCommandWithRetry(command: string, args: string[], maxAttempts: number,\r\n    workingDirectory: string, suppressOutput: boolean = false): void {\r\n\r\n    if (maxAttempts < 1) {\r\n      throw new Error('The maxAttempts parameter cannot be less than 1');\r\n    }\r\n\r\n    let attemptNumber: number = 1;\r\n\r\n    // tslint:disable-next-line:no-constant-condition\r\n    while (true) {\r\n      try {\r\n        Utilities.executeCommand(command, args, workingDirectory, suppressOutput);\r\n      } catch (error) {\r\n        console.log(os.EOL + 'The command failed:');\r\n        console.log(` ${command} ` + args.join(' '));\r\n        console.log(`ERROR: ${error.toString()}`);\r\n\r\n        if (attemptNumber < maxAttempts) {\r\n          ++attemptNumber;\r\n          console.log(`Trying again (attempt #${attemptNumber})...` + os.EOL);\r\n          continue;\r\n        } else {\r\n          console.error(`Giving up after ${attemptNumber} attempts` + os.EOL);\r\n          throw error;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes the command with the specified command-line parameters, and waits for it to complete.\r\n   * The current directory will be set to the specified workingDirectory.\r\n   */\r\n  public static executeCommandAsync(command: string, args: string[], workingDirectory: string,\r\n    environmentVariables?: { [key: string]: string }): child_process.ChildProcess {\r\n    // This is a workaround for GitHub issue #25330.  It is not as complete as the workaround above,\r\n    // but there doesn't seem to be an easy asynchronous solution.\r\n    // https://github.com/nodejs/node-v0.x-archive/issues/25330\r\n    if (fsx.existsSync(command + '.cmd')) {\r\n      command += '.cmd';\r\n    }\r\n\r\n    return child_process.spawn(command, args, {\r\n      cwd: workingDirectory,\r\n      shell: true,\r\n      env: environmentVariables\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the same thing as targetString.replace(searchValue, replaceValue), except that\r\n   * all matches are replaced, rather than just the first match.\r\n   * @param targetString  The string to be modified\r\n   * @param searchValue   The value to search for\r\n   * @param replaceValue  The replacement text\r\n   */\r\n  public static getAllReplaced(targetString: string, searchValue: string, replaceValue: string): string {\r\n    return targetString.split(searchValue).join(replaceValue);\r\n  }\r\n\r\n  /**\r\n   * Executes the command with the specified command-line parameters, and waits for it to complete.\r\n   * The current directory will be set to the specified workingDirectory.\r\n   */\r\n  private static _executeCommandInternal(\r\n    command: string, args: string[], workingDirectory: string,\r\n    stdio: (string|number)[],\r\n    environmentVariables: { [key: string]: string }): child_process.SpawnSyncReturns<Buffer> {\r\n\r\n    const options: child_process.SpawnSyncOptions = {\r\n      cwd: workingDirectory,\r\n      shell: true,\r\n      stdio: stdio,\r\n      env: environmentVariables\r\n    };\r\n\r\n    let result: child_process.SpawnSyncReturns<Buffer> = child_process.spawnSync(command, args, options);\r\n\r\n    /* tslint:disable:no-any */\r\n    if (result.error && (result.error as any).errno === 'ENOENT') {\r\n      // This is a workaround for GitHub issue #25330\r\n      // https://github.com/nodejs/node-v0.x-archive/issues/25330\r\n      result = child_process.spawnSync(command + '.cmd', args, options);\r\n    }\r\n    /* tslint:enable:no-any */\r\n\r\n    if (result.error) {\r\n      result.error.message += os.EOL + (result.stderr ? result.stderr.toString() + os.EOL : '');\r\n      throw result.error;\r\n    }\r\n\r\n    if (result.status) {\r\n      throw new Error('The command failed with exit code ' + result.status + os.EOL +\r\n        (result.stderr ? result.stderr.toString() : ''));\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}