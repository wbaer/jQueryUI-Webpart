{"version":3,"sources":["DocItemLoader.ts"],"names":[],"mappings":"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","file":"DocItemLoader.js","sourcesContent":["import * as fsx from 'fs-extra';\r\nimport * as os  from 'os';\r\nimport * as path from 'path';\r\nimport { IDocItem, IDocPackage, IDocMember } from './IDocItem';\r\nimport ApiDefinitionReference, { IScopedPackageName, IApiDefinintionReferenceParts } from './ApiDefinitionReference';\r\nimport ApiItem from './definitions/ApiItem';\r\nimport ApiItemContainer from './definitions/ApiItemContainer';\r\nimport ApiPackage from './definitions/ApiPackage';\r\nimport ResolvedApiItem from './ResolvedApiItem';\r\nimport JsonFile from './JsonFile';\r\n\r\n/**\r\n * Used to describe a parsed package name in the form of\r\n * scopedName/packageName. Ex: @microsoft/sp-core-library.\r\n */\r\nexport interface IParsedScopeName {\r\n  /**\r\n   * The scope prefix. Ex: @microsoft.\r\n   */\r\n  scope: string;\r\n\r\n  /**\r\n   * The specific package name. Ex: sp-core-library.\r\n   */\r\n  name: string;\r\n}\r\n\r\n/**\r\n * A loader for locating the IDocItem associated with a given project and API item, or \r\n * for locating an ApiItem  locally.\r\n * No processing on the IDocItem orApiItem  should be done in this class, this class is only\r\n * concerned with communicating state.\r\n * The IDocItem can then be used to enforce correct API usage, like enforcing internal.\r\n * To use DocItemLoader: provide a projectFolder to construct a instance of the DocItemLoader,\r\n * then use DocItemLoader.getItem to retrieve the IDocItem of a particular API item.\r\n */\r\nexport default class DocItemLoader {\r\n  private _cache: Map<string, IDocPackage>;\r\n  private _projectFolder: string; // Root directory to check for node modules\r\n\r\n  /**\r\n   * The projectFolder is the top-level folder containing package.json for a project\r\n   * that we are compiling.\r\n   */\r\n  constructor(projectFolder: string) {\r\n    if (!fsx.existsSync(path.join(projectFolder, 'package.json'))) {\r\n      throw new Error(`An NPM project was not found in the specified folder: ${projectFolder}`);\r\n    }\r\n\r\n    this._projectFolder = projectFolder;\r\n    this._cache = new Map<string, IDocPackage>();\r\n  }\r\n\r\n  /**\r\n   * {@inheritdoc IReferenceResolver.resolve}\r\n   */\r\n  public resolve(apiDefinitionRef: ApiDefinitionReference,\r\n    apiPackage: ApiPackage,\r\n    reportError: (message: string) => void): ResolvedApiItem {\r\n\r\n    // If there is a packageName then there must be a scopeName, and they \r\n    // both must match the current scope and package we are in.\r\n    // We can take advantage of '&&' being evaluated left to right.\r\n    if (!apiDefinitionRef.packageName && !apiDefinitionRef.scopeName) {\r\n      // Resolution for local references \r\n      return this.resolveLocalReferences(apiDefinitionRef, apiPackage, reportError);\r\n    } else {\r\n       // Resolution for references in JSON files\r\n       return this.resolveJsonReferences(apiDefinitionRef, reportError);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resolution of API definition references in the scenario that the reference given indicates \r\n   * that we should search within the current ApiPackage to resolve.\r\n   * No processing on the ApiItem should be done here, this class is only concerned\r\n   * with communicating state.\r\n   */\r\n  public resolveLocalReferences(apiDefinitionRef: ApiDefinitionReference,\r\n    apiPackage: ApiPackage,\r\n    reportError: (message: string) => void): ResolvedApiItem {\r\n\r\n    let apiItem: ApiItem = apiPackage.getMemberItem(apiDefinitionRef.exportName);\r\n    // Check if export name was not found\r\n    if (!apiItem) {\r\n      reportError(`Unable to find referenced export \\\"${apiDefinitionRef.toExportString()}\\\"`);\r\n      return undefined;\r\n    }\r\n\r\n    // If memberName exists then check for the existense of the name\r\n    if (apiDefinitionRef.memberName) {\r\n      if (apiItem instanceof ApiItemContainer) {\r\n        const apiItemContainer: ApiItemContainer = (apiItem as ApiItemContainer);\r\n        // get() returns undefined if there is no match\r\n        apiItem = apiItemContainer.memberItems.get(apiDefinitionRef.memberName);\r\n      } else {\r\n        // There are no other instances of apiItem that has members,\r\n        // thus there must be a mistake with the apiDefinitionRef.\r\n        apiItem = undefined;\r\n      }\r\n    }\r\n\r\n    if (!apiItem) {\r\n      // If we are here, we can be sure there was a problem with the memberName.\r\n      // memberName was not found, apiDefinitionRef is invalid\r\n      reportError(`Unable to find referenced member \\\"${apiDefinitionRef.toMemberString()}\\\"`);\r\n      return undefined;\r\n    }\r\n\r\n    return ResolvedApiItem.createFromApiItem(apiItem);\r\n  }\r\n\r\n  /**\r\n   * Resolution of API definition references in the scenario that the reference given indicates \r\n   * that we should search outside of this ApiPackage and instead search within the JSON API file\r\n   * that is associated with the apiDefinitionRef. \r\n   */\r\n  public resolveJsonReferences(apiDefinitionRef: ApiDefinitionReference,\r\n    reportError: (message: string) => void): ResolvedApiItem {\r\n\r\n    // Check if package can be not found\r\n    const docPackage: IDocPackage =  this.getPackage(apiDefinitionRef, reportError);\r\n    if (!docPackage) {\r\n      // Error is reported in this.getPackage()\r\n      return undefined;\r\n    }\r\n\r\n    // found JSON package, now ensure export name is there \r\n    // hasOwnProperty() not needed for JJU objects\r\n    if (!(apiDefinitionRef.exportName in docPackage.exports)) {\r\n      reportError(`Unable to find referenced export \\\"${apiDefinitionRef.toExportString()}\\\"\"`);\r\n      return undefined;\r\n    }\r\n\r\n    let docItem: IDocItem = docPackage.exports[apiDefinitionRef.exportName];\r\n\r\n    // If memberName exists then check for the existense of the name\r\n    if (apiDefinitionRef.memberName) {\r\n      let member: IDocMember = undefined;\r\n      switch (docItem.kind) {\r\n        case 'class':\r\n\r\n          // hasOwnProperty() not needed for JJU objects\r\n          member = apiDefinitionRef.memberName in docItem.members ?\r\n            docItem.members[apiDefinitionRef.memberName] : undefined;\r\n          break;\r\n        case 'interface':\r\n          // hasOwnProperty() not needed for JJU objects\r\n          member = apiDefinitionRef.memberName in docItem.members ?\r\n            docItem.members[apiDefinitionRef.memberName] : undefined;\r\n          break;\r\n        case 'enum':\r\n        // hasOwnProperty() not needed for JJU objects\r\n          member = apiDefinitionRef.memberName in docItem.values ?\r\n            docItem.values[apiDefinitionRef.memberName] : undefined;\r\n          break;\r\n        default:\r\n          // Any other docItem.kind does not have a 'members' property\r\n          break;\r\n      }\r\n\r\n      if (member) {\r\n        docItem = member;\r\n      } else {\r\n        // member name was not found, apiDefinitionRef is invalid\r\n        reportError(`Unable to find referenced member \\\"${apiDefinitionRef.toMemberString()}\\\"`);\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    return ResolvedApiItem.createFromJson(docItem);\r\n  }\r\n\r\n  /**\r\n   * Attempts to locate and load the IDocPackage object from the project folder's\r\n   * node modules. If the package already exists in the cache, nothing is done.\r\n   *\r\n   * @param apiDefinitionRef - interface with propropties pertaining to the API definition reference\r\n   */\r\n  public getPackage(apiDefinitionRef: ApiDefinitionReference, reportError: (message: string) => void): IDocPackage {\r\n    let cachePackageName: string = '';\r\n\r\n    // We concatenate the scopeName and packageName in case there are packageName conflicts\r\n    if (apiDefinitionRef.scopeName) {\r\n      cachePackageName = `${apiDefinitionRef.scopeName}/${apiDefinitionRef.packageName}`;\r\n    } else {\r\n      cachePackageName = apiDefinitionRef.packageName;\r\n    }\r\n    // Check if package exists in cache\r\n    if (this._cache.has(cachePackageName)) {\r\n        return this._cache.get(cachePackageName);\r\n    }\r\n\r\n    // Doesn't exist in cache, attempt to load the json file\r\n    const packageJsonFilePath: string =  path.join(\r\n      this._projectFolder,\r\n      'node_modules',\r\n      apiDefinitionRef.scopeName,\r\n      apiDefinitionRef.packageName,\r\n      `dist/${apiDefinitionRef.packageName}.api.json`\r\n    );\r\n\r\n    if (!fsx.existsSync(path.join(packageJsonFilePath))) {\r\n      // package not found in node_modules\r\n      reportError(`Unable to find referenced package \\\"${apiDefinitionRef.toScopePackageString()}\\\"`);\r\n      return;\r\n    }\r\n\r\n    return this.loadPackageIntoCache(packageJsonFilePath);\r\n  }\r\n\r\n  /**\r\n   * Loads the API documentation json file and validates that it conforms to our schema. If it does, \r\n   * then the json file is saved in the cache and returned.\r\n   */\r\n  public loadPackageIntoCache(packageJsonFilePath: string): IDocPackage {\r\n    const apiPackage: IDocPackage = JsonFile.loadJsonFile(packageJsonFilePath) as IDocPackage;\r\n\r\n    // Validate that the output conforms to our JSON schema\r\n    const apiJsonSchema: { } = JsonFile.loadJsonFile(path.join(__dirname, './schemas/api-json-schema.json'));\r\n    JsonFile.validateSchema(apiPackage, apiJsonSchema,\r\n      (errorDetail: string): void => {\r\n        const errorMessage: string\r\n          = `ApiJsonGenerator validation error - output does not conform to api-json-schema.json:` + os.EOL\r\n          + errorDetail;\r\n\r\n        console.log(os.EOL + 'ERROR: ' + errorMessage + os.EOL + os.EOL);\r\n        throw new Error(errorMessage);\r\n      }\r\n    );\r\n\r\n    const packageName: string = path.basename(packageJsonFilePath).split('.').shift();\r\n    this._cache.set(packageName, apiPackage);\r\n    return apiPackage;\r\n  }\r\n}"],"sourceRoot":"..\\src"}