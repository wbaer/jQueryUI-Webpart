{"version":3,"sources":["tasks/CleanTask.ts"],"names":[],"mappings":";;;;;;AAAA,uCAAsC;AAItC,wEAAuE;AAEvE;;;;GAIG;AACH;IAA+B,6BAAc;IAC3C,yDAAyD;IACzD;QAAA,YACE,iBAAO,SAER;QADC,KAAI,CAAC,IAAI,GAAG,OAAO,CAAC;;IACtB,CAAC;IAED;;;;OAIG;IACI,+BAAW,GAAlB,UACE,IAAe,EACf,gBAA2C;QAG3C,yBAAyB;QACnB,IAAA,qBAAsE,EAApE,0BAAU,EAAE,wBAAS,EAAE,8BAAY,EAAE,0BAAU,CAAsB;QAC7E,IAAI,UAAU,GAAG;YACf,UAAU;YACV,YAAY;YACZ,SAAS;YACT,UAAU;SACX,CAAC;QAEF,yEAAyE;QACzE,GAAG,CAAC,CAAqB,UAA4B,EAA5B,KAAA,IAAI,CAAC,WAAW,CAAC,WAAW,EAA5B,cAA4B,EAA5B,IAA4B;YAAhD,IAAM,UAAU,SAAA;YACnB,EAAE,CAAC,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC;gBAC7B,6DAA6D;gBAC7D,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,aAAa,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YAC7E,CAAC;SACF;QAED,IAAM,WAAW,GAA8B,EAAE,CAAC;QAElD,uEAAuE;QACvE,UAAU,CAAC,OAAO,CAAC,UAAA,IAAI;YACrB,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACX,WAAW,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;YAC3B,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,mDAAmD;QACnD,UAAU,GAAG,EAAE,CAAC;QAChB,GAAG,CAAC,CAAC,IAAM,MAAI,IAAI,WAAW,CAAC,CAAC,CAAC;YAC/B,EAAE,CAAC,CAAC,WAAW,CAAC,cAAc,CAAC,MAAI,CAAC,CAAC,CAAC,CAAC;gBACrC,UAAU,CAAC,IAAI,CAAC,MAAI,CAAC,CAAC;YACxB,CAAC;QACH,CAAC;QAED,IAAI,CAAC;YACH,yCAAmB,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;YAC/C,gBAAgB,EAAE,CAAC;QACrB,CAAC;QAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,gBAAgB,CAAC,CAAC,CAAC,CAAC;QACtB,CAAC;IACH,CAAC;IACH,gBAAC;AAAD,CA1DA,AA0DC,CA1D8B,mBAAQ,GA0DtC;AA1DY,8BAAS","file":"tasks/CleanTask.js","sourcesContent":["import { GulpTask } from './GulpTask';\r\nimport gulp = require('gulp');\r\nimport * as path from 'path';\r\n\r\nimport { FileDeletionUtility } from '../utilities/FileDeletionUtility';\r\n\r\n/**\r\n * The clean task is a special task which iterates through all registered\r\n * tasks and subtasks, collecting a list of patterns which should be deleted.\r\n * An instance of this task is automatically registered to the 'clean' command.\r\n */\r\nexport class CleanTask extends GulpTask<void> {\r\n  /** Instantiates a new CleanTask with the name 'clean' */\r\n  constructor() {\r\n    super();\r\n    this.name = 'clean';\r\n  }\r\n\r\n  /**\r\n   * The main function, which iterates through all uniqueTasks registered\r\n   * to the build, and by calling the getCleanMatch() function, collects a list of\r\n   * glob patterns which are then passed to the `del` plugin to delete them from disk.\r\n   */\r\n  public executeTask(\r\n    gulp: gulp.Gulp,\r\n    completeCallback: (result?: Object) => void\r\n  ): void {\r\n\r\n    // tslint:disable:typedef\r\n    const { distFolder, libFolder, libAMDFolder, tempFolder } = this.buildConfig;\r\n    let cleanPaths = [\r\n      distFolder,\r\n      libAMDFolder,\r\n      libFolder,\r\n      tempFolder\r\n    ];\r\n\r\n    // Give each registered task an opportunity to add their own clean paths.\r\n    for (const executable of this.buildConfig.uniqueTasks) {\r\n      if (executable.getCleanMatch) {\r\n        // Set the build config, as tasks need this to build up paths\r\n        cleanPaths = cleanPaths.concat(executable.getCleanMatch(this.buildConfig));\r\n      }\r\n    }\r\n\r\n    const uniquePaths: { [key: string]: string } = {};\r\n\r\n    // Create dictionary of unique paths. (Could be replaced with ES6 set.)\r\n    cleanPaths.forEach(path => {\r\n      if (!!path) {\r\n        uniquePaths[path] = path;\r\n      }\r\n    });\r\n\r\n    // Reset cleanPaths to only unique non-empty paths.\r\n    cleanPaths = [];\r\n    for (const path in uniquePaths) {\r\n      if (uniquePaths.hasOwnProperty(path)) {\r\n        cleanPaths.push(path);\r\n      }\r\n    }\r\n\r\n    try {\r\n      FileDeletionUtility.deletePatterns(cleanPaths);\r\n      completeCallback();\r\n    } catch (e) {\r\n      completeCallback(e);\r\n    }\r\n  }\r\n}"],"sourceRoot":"..\\..\\src"}