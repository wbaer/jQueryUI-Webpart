/* tslint:disable:no-bitwise */
/* tslint:disable:no-constant-condition */
"use strict";
var ts = require("typescript");
var ApiDocumentation_1 = require("./ApiDocumentation");
var TypeScriptHelpers_1 = require("../TypeScriptHelpers");
var DocElementParser_1 = require("../DocElementParser");
/**
 * Indicates the type of definition represented by a ApiItem object.
 */
var ApiItemKind;
(function (ApiItemKind) {
    /**
      * A TypeScript class.
      */
    ApiItemKind[ApiItemKind["Class"] = 0] = "Class";
    /**
      * A TypeScript enum.
      */
    ApiItemKind[ApiItemKind["Enum"] = 1] = "Enum";
    /**
      * A TypeScript value on an enum.
      */
    ApiItemKind[ApiItemKind["EnumValue"] = 2] = "EnumValue";
    /**
      * A TypeScript function.
      */
    ApiItemKind[ApiItemKind["Function"] = 3] = "Function";
    /**
      * A TypeScript interface.
      */
    ApiItemKind[ApiItemKind["Interface"] = 4] = "Interface";
    /**
      * A TypeScript method.
      */
    ApiItemKind[ApiItemKind["Method"] = 5] = "Method";
    /**
      * A TypeScript package.
      */
    ApiItemKind[ApiItemKind["Package"] = 6] = "Package";
    /**
      * A TypeScript parameter.
      */
    ApiItemKind[ApiItemKind["Parameter"] = 7] = "Parameter";
    /**
      * A TypeScript property.
      */
    ApiItemKind[ApiItemKind["Property"] = 8] = "Property";
    /**
      * A TypeScript type literal expression, i.e. which defines an anonymous interface.
      */
    ApiItemKind[ApiItemKind["TypeLiteral"] = 9] = "TypeLiteral";
    /**
     * A Typescript class constructor function.
     */
    ApiItemKind[ApiItemKind["Constructor"] = 10] = "Constructor";
})(ApiItemKind = exports.ApiItemKind || (exports.ApiItemKind = {}));
/**
 * The state of completing the ApiItem's doc comment references inside a recursive call to ApiItem.resolveReferences().
 */
var InitializationState;
(function (InitializationState) {
    /**
     * The references of this ApiItem have not begun to be completed.
     */
    InitializationState[InitializationState["Incomplete"] = 0] = "Incomplete";
    /**
     * The refernces of this ApiItem are in the process of being completed.
     * If we encounter this state again during completing, a circular dependency
     * has occured.
     */
    InitializationState[InitializationState["Completing"] = 1] = "Completing";
    /**
     * The references of this ApiItem have all been completed and the documentation can
     * now safely be created.
     */
    InitializationState[InitializationState["Completed"] = 2] = "Completed";
})(InitializationState || (InitializationState = {}));
/**
 * ApiItem is an abstract base that represents TypeScript API definitions such as classes,
 * interfaces, enums, properties, functions, and variables.  Rather than directly using the
 * abstract syntax tree from the TypeScript Compiler API, we use ApiItem to extract a
 * simplified tree which correponds to the major topics for our API documentation.
 */
var ApiItem = (function () {
    function ApiItem(options) {
        /**
         * A superset of memberItems. Includes memberItems and also other ApiItems that
         * comprise this ApiItem.
         *
         * Ex: if this ApiItem is an ApiFunction, then in it's innerItems would
         * consist of ApiParameters.
         * Ex: if this ApiItem is an ApiMember that is a type literal, then it's
         * innerItems would contain ApiProperties.
         */
        this.innerItems = [];
        /**
         * True if this ApiItem either itself has missing type information or one
         * of it's innerItems is missing type information.
         *
         * Ex: if this ApiItem is an ApiMethod and has no type on the return value, then
         * we consider the ApiItem as 'itself' missing type informations and this property
         * is set to true.
         * Ex: If this ApiItem is an ApiMethod and one of its innerItems is an ApiParameter
         * that has no type specified, then we say an innerItem of this ApiMethod is missing
         * type information and this property is set to true.
         */
        this.hasIncompleteTypes = false;
        this.reportError = this.reportError.bind(this);
        this.jsdocNode = options.jsdocNode;
        this.declaration = options.declaration;
        this._errorNode = options.declaration;
        this._state = InitializationState.Incomplete;
        this.warnings = [];
        this.extractor = options.extractor;
        this.declarationSymbol = options.declarationSymbol;
        this.exportSymbol = options.exportSymbol || this.declarationSymbol;
        this.name = this.exportSymbol.name || '???';
        this.typeChecker = this.extractor.typeChecker;
        var originalJsDoc = '';
        if (this.jsdocNode) {
            originalJsDoc = TypeScriptHelpers_1.default.getJsDocComments(this.jsdocNode, this.reportError);
        }
        this.documentation = new ApiDocumentation_1.default(originalJsDoc, this.extractor.docItemLoader, this.extractor, this.reportError);
    }
    /**
     * Return the compiler's underlying Declaration object
     * @todo Generally ApiItem classes don't expose ts API objects; we should add
     *       an appropriate member to avoid the need for this.
     */
    ApiItem.prototype.getDeclaration = function () {
        return this.declaration;
    };
    /**
     * Return the compiler's underlying Symbol object that contains semantic information about the item
     * @todo Generally ApiItem classes don't expose ts API objects; we should add
     *       an appropriate member to avoid the need for this.
     */
    ApiItem.prototype.getDeclarationSymbol = function () {
        return this.declarationSymbol;
    };
    /**
     * Whether this APiItem should have documentation or not.  If false, then
     * ApiItem.missingDocumentation will never be set.
     */
    ApiItem.prototype.shouldHaveDocumentation = function () {
        return true;
    };
    /**
     * This traverses any type aliases to find the original place where an item was defined.
     * For example, suppose a class is defined as "export default class MyClass { }"
     * but exported from the package's index.ts like this:
     *
     *    export { default as _MyClass } from './MyClass';
     *
     * In this example, calling followAliases() on the _MyClass symbol will return the
     * original definition of MyClass, traversing any intermediary places where the
     * symbol was imported and re-exported.
     */
    ApiItem.prototype.followAliases = function (symbol) {
        var current = symbol;
        while (true) {
            if (!(current.flags & ts.SymbolFlags.Alias)) {
                break;
            }
            var currentAlias = this.typeChecker.getAliasedSymbol(current);
            if (!currentAlias || currentAlias === current) {
                break;
            }
            current = currentAlias;
        }
        return current;
    };
    /**
     * Reports an error through the ApiErrorHandler interface that was registered with the Extractor,
     * adding the filename and line number information for the declaration of this ApiItem.
     */
    ApiItem.prototype.reportError = function (message) {
        this.extractor.reportError(message, this._errorNode.getSourceFile(), this._errorNode.getStart());
    };
    /**
      * Adds a warning to the ApiItem.warnings list.  These warnings will be emtted in the API file
      * produced by ApiFileGenerator.
      */
    ApiItem.prototype.reportWarning = function (message) {
        this.warnings.push(message);
    };
    /**
     * This function assumes all references from this ApiItem have been resolved and we can now safely create
     * the documentation.
     */
    ApiItem.prototype.onCompleteInitialization = function () {
        this.documentation.completeInitialization();
        // TODO: this.collectTypeReferences(this);
        var summaryTextCondensed = DocElementParser_1.default.getAsText(this.documentation.summary, this.reportError).replace(/\s\s/g, ' ');
        this.needsDocumentation = this.shouldHaveDocumentation() && summaryTextCondensed.length <= 10;
        if (this.kind === ApiItemKind.Package) {
            if (this.documentation.apiTag !== ApiDocumentation_1.ApiTag.None) {
                var tag = '@' + ApiDocumentation_1.ApiTag[this.documentation.apiTag].toLowerCase();
                this.reportError("The " + tag + " tag is not allowed on the package, which is always public");
            }
            this.documentation.apiTag = ApiDocumentation_1.ApiTag.Public;
        }
        if (this.documentation.preapproved) {
            if (!(this.getDeclaration().kind & (ts.SyntaxKind.InterfaceDeclaration | ts.SyntaxKind.ClassDeclaration))) {
                this.reportError('The @preapproved tag may only be applied to classes and interfaces');
                this.documentation.preapproved = false;
            }
        }
    };
    /**
     * This function is a second stage that happens after Extractor.analyze() calls ApiItem constructor to build up
     * the abstract syntax tree. In this second stage, we are creating the documentation for each ApiItem.
     *
     * This function makes sure we create the documentation for each ApiItem in the correct order.
     * In the event that a circular dependency occurs, an error is reported. For example, if ApiItemOne has
     * an \@inheritdoc referencing ApiItemTwo, and ApiItemTwo has an \@inheritdoc refercing ApiItemOne then
     * we have a circular dependency and an error will be reported.
     */
    ApiItem.prototype.completeInitialization = function () {
        switch (this._state) {
            case InitializationState.Completed:
                return;
            case InitializationState.Incomplete:
                this._state = InitializationState.Completing;
                this.onCompleteInitialization();
                this._state = InitializationState.Completed;
                for (var _i = 0, _a = this.innerItems; _i < _a.length; _i++) {
                    var innerItem = _a[_i];
                    innerItem.completeInitialization();
                }
                return;
            case InitializationState.Completing:
                this.reportError('circular reference');
                return;
            default:
                throw new Error('ApiItem state is invalid');
        }
    };
    /**
     * A procedure for determining if this ApiItem is missing type
     * information. We first check if the ApiItem itself is missing
     * any type information and if not then we check each of it's
     * innerItems for missing types.
     *
     * Ex: On the ApiItem itself, there may be missing type information
     * on the return value or missing type declaration of itself
     * (const name;).
     * Ex: For each innerItem, there may be an ApiParameter that is missing
     * a type. Or for an ApiMember that is a type literal, there may be an
     * ApiProperty that is missing type information.
     */
    ApiItem.prototype.hasAnyIncompleteTypes = function () {
        if (this.hasIncompleteTypes) {
            return true;
        }
        for (var _i = 0, _a = this.innerItems; _i < _a.length; _i++) {
            var innerItem = _a[_i];
            if (innerItem.hasIncompleteTypes) {
                return true;
            }
        }
        return false;
    };
    return ApiItem;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ApiItem;

//# sourceMappingURL=ApiItem.js.map
