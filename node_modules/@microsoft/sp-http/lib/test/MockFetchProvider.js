"use strict";
var assert = chai.assert;
var MockedHeader = (function () {
    function MockedHeader(name, value) {
        this.name = name;
        this.value = value;
    }
    return MockedHeader;
}());
exports.MockedHeader = MockedHeader;
var MockFetchProvider = (function () {
    function MockFetchProvider(serviceScope) {
        this.mockedRequest = [];
        this.practiceRun = false;
    }
    MockFetchProvider.getNormalizedText = function (text) {
        return text.split('\n')
            .map(function (line) { return line.trim(); })
            .join('\n')
            .trim();
    };
    MockFetchProvider.prototype.expect = function (mockedRequest) {
        this.mockedRequest.push(mockedRequest);
    };
    MockFetchProvider.prototype.assertQueueEmpty = function () {
        if (this.practiceRun) {
            return;
        }
        if (this.mockedRequest.length !== 0) {
            var next = this.mockedRequest.shift();
            assert.isTrue(false, 'A request was expected but never issued: ' + next.expectedUrl);
        }
    };
    MockFetchProvider.prototype.fetch = function (request) {
        var _this = this;
        return request.text().then(function (requestBodyText) {
            var url = request.url || '(undefined url)';
            assert.isTrue(_this.mockedRequest.length > 0, 'No request expected at this time: '
                + url.toString());
            var mockedRequest = _this.mockedRequest.shift();
            if (_this.practiceRun) {
                var observeOnlyCounter = ++MockFetchProvider._observeOnlyCounter;
                console.log("MockFetchProvider: REQUEST #" + observeOnlyCounter);
                var headerLines_1 = '';
                request.headers.forEach(function (value, name) {
                    headerLines_1 += "  " + name + ": " + value + "\n";
                });
                console.log([
                    '',
                    "==[REQUEST #" + observeOnlyCounter + "]===========================================",
                    "URL: " + request.url,
                    "HEADERS:",
                    "" + headerLines_1 +
                        "== BODY: ====================================================================",
                    "" + requestBodyText,
                    "=============================================================================",
                    ''
                ].join('\n'));
            }
            else {
                assert.isTrue(url === mockedRequest.expectedUrl, "Expecting this: " + mockedRequest.expectedUrl
                    + ("\r\nBut got this:" + url));
                (mockedRequest.expectedRequestHeaders || []).forEach(function (mockedHeader) {
                    var value = request.headers.get(mockedHeader.name);
                    if (mockedHeader.value !== undefined) {
                        assert.isOk(value, "The \"" + mockedHeader.name + "\" header was expected,"
                            + " but is missing from the response");
                        assert.isTrue(value === mockedHeader.value, "The \"" + mockedHeader.name + "\" header had this value:\r\n"
                            + ("\"" + value + "\"\r\nbut this was expected:\r\n\"" + mockedHeader.value + "\""));
                    }
                    else {
                        assert.isNotOk(value, "The \"" + mockedHeader.name + "\" header was NOT expected,"
                            + (" but it appeared in the response with this value:\r\n\"" + value + "\""));
                    }
                });
                if (mockedRequest.expectedRequestObject) {
                    var expectedBodyText = mockedRequest.expectedRequestObject;
                    assert.equal(MockFetchProvider.getNormalizedText(expectedBodyText), MockFetchProvider.getNormalizedText(requestBodyText), "The body text for this request did not match:\n" + url);
                }
                if (mockedRequest.requestAssertions) {
                    mockedRequest.requestAssertions(request);
                }
            }
            var responseText = (typeof mockedRequest.responseObject === 'string')
                ? mockedRequest.responseObject
                : JSON.stringify(mockedRequest.responseObject);
            var responseOptions = mockedRequest.responseOptions
                || { status: 200, statusText: 'OK' };
            var response = new Response(responseText, responseOptions);
            if (mockedRequest.responseHeaders) {
                for (var _i = 0, _a = mockedRequest.responseHeaders; _i < _a.length; _i++) {
                    var responseHeader = _a[_i];
                    response.headers.append(responseHeader.name, responseHeader.value);
                }
            }
            if (mockedRequest.responseContentLengthHeader) {
                response.headers.append('Content-Length', responseText.length.toString());
            }
            return response;
        });
    };
    return MockFetchProvider;
}());
MockFetchProvider._observeOnlyCounter = 0;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MockFetchProvider;
