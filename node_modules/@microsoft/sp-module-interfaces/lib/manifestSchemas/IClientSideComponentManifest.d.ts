/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file Client side component manifest definition.
 */
import { IClientSideComponentLoaderConfiguration } from './IClientSideComponentLoaderConfiguration';
/**
 * Definition: A set of localized strings.
 * Supported values:
 * * An Id referring to a localized resource. In this case it requires an 'id' key.
 * * A dictionary of locale keys to strings. In this case it requires a 'default' key.
 * Example 1: "My Application"
 *          {
 *            "id": "$myStrings:myStrings.MyApplication;"
 *          }
 * Example 2: "My Application"
 *          {
 *            "default": "My Application"
 *            "en-us": "My Application",
 *            "fr-fr": "Ma demande",
 *            "zh": "我的應用程式"
 *          }
 *
 * Notes on strings id:
 * Ids have the following structure: $<resourceName>:<expression>;
 * resourceName needs to be a localizedResource in the config.json.
 * expression is an expression that will be evaluated to access the string from the resource module.
 *
 * If your resource is a dictionary, access it through "$resource:resource.MyString;"
 * or "$resource:resource[\"MyString\"];"
 * For more complex cases, run an appropriate expression to access your resource and return the string.
 *
 */
export interface ILocalizedString {
    default?: string;
    id?: string;
    [locale: string]: string | undefined;
}
/**
 * All client side components built on the SharePoint framework need a valid component manifest. This interface
 * represents properties that are required by all types of client side components like Applications and Web Parts.
 * Component specific manifests will extend this interface to add properties required by that component type.
 *
 * The schema of this manifest is owned and vesioned by Microsoft. Following rules should be followed while changing
 * this schema. This set of rules can also be called the "manifest upgrade rules".
 *
 *   -  For minor changes, new properties can be added to this schema in a backwards-compatible way. i.e. the code
 *      that processes the manifest should be able to handle the absense of those new properties.
 *   -  Try to model your changes as minor SemVer increments.  Major version changes should be avoided because they
 *      impose a migration cost on developers.
 *   -  The 'manifestVersion' should be bumped for all small or big changes.
 *
 * @internalremarks - This schema should be at all times kept in sync with the server-side code file
 *   SPClientSideComponentManifest.cs.
 *
 * @public
 */
export interface IClientSideComponentManifest {
    /**
     * Definition: Version of the component manifest schema. The value of this field is controlled by Microsoft. The
     *  purpose of this field is to help manage upgrades of the component manifest schema. A component developer needs to
     *  only confirm that they are using the correct value per the manifest schema. Please read the "manifest upgrade
     *  rules" for more details on when the schema could change. Note, manifest schema version upgrade will be considered
     *  a big API change event and will be advertised broadly.
     * Usage: To help support multiple manifest schema versions.
     * Required: yes
     * Localized: no
     * Supported values: +ve integer.
     * Example: 1
     */
    manifestVersion: number;
    /**
     * Definition: Type of client side component. Components with the "Application" type are defined by the
     *  "IClientSideApplicationManifest" interface. Components with the "WebPart" type are defined by the
     *  "IClientSideWebPartManifest" interface. Components with the "Library" type are defined by the
     *  "IClientSideLibraryManifest" interface.
     * Usage: To help bundling, loading, enumeration, and initialization of components based on their contents.
     * Required: yes
     * Localized: no
     * Supported values: "Application", "WebPart", "Library", "CodePart"
     * Example: "Application"
     */
    componentType: 'Application' | 'WebPart' | 'Library' | 'CodePart';
    /**
     * Definition: A universally unique component id. Each client side component is required to have this id. Once an
     *  id has been used for a component, it cannot be changed. A change in this value is treated same as the creation of
     *  a new component. Two components are never expected to have the same id.
     * Usage: Uniquely identify a client side component.
     * Required: yes
     * Localized: no
     * Supported values: any GUID
     * Example: "dbef608d-3ad5-4f8f-b139-d916f2f0a294"
     */
    id: string;
    /**
     * Definition: A short name usually given by developer. It does not need to be localized and is expected to stay
     * the same through the lifetime of the component. If an application overrides the ClientSideApplication.alias
     * property, ClientSideApplication.alias is given precedence over the value provided in the manifest.
     * Usage: A short name to identify a client side component by developer.
     * Required: no
     * Localized: no
     * Supported values: Allowed characters are a-z, A-Z, and '-'. Not longer than 40 characters.
     * Example: "NewFeed"
     *
     * @internalremarks - telemetry data is categorized based on alias. If alias changes, new telemetry date for this
     * component will be put in a new category. It breaks history data if alias changes.
     */
    alias: string;
    /**
     * Definition: An auto-generated value for internal use. Do not add or use it.
     * Usage: Not to be used by third party developers.
     * Required: no
     *
     * @internal
     *
     * @internalremarks - this property indicates whether the component is first-party or third-party. IsInternal is true
     * for first-party, false for third-party. The value is controlled by server side code. It is used when framework
     * needs to differentiate between behaviors for first-party components and third-party, like in telemetry.
     */
    isInternal?: boolean;
    /**
     * Definition: Client side component version. The value of this field is expected to be controlled by the developer
     *  of the client side component. The purpose of this field is to help client side component developers upgrade their
     *  client side components in a managed way. This helps the consumers of the client side component make decisions
     *  about when and how to upgrade the client side component. As the developer evolves the code for their client side
     *  component, they can decide to bump the MAJOR, MINOR or PATCH version of the component. All incompatible API
     *  changes should result in a MAJOR version bump. Backwards compatible functionality changes should result in a
     *  MINOR version bump, and backwards compatible bug fixes should result in a PATCH version bump. Please see
     *  http://semver.org for more details on how to manage the version of your components.
     * Usage: Versioning and evolving a client side component safely in a controlled way.
     * Required: yes
     * Localized: no
     * Supported values: string representing a semantic version (http://semver.org) i.e. MAJOR.MINOR.PATCH
     * Example: "1.0.0"
     */
    version: string;
    /**
     * Definition: This portion of the configuration describes how the component is to be loaded and initialized by a
     *  client. It contains an enumeration of scripts that the component requires along with a single entrypoint script.
     * Usage: Loading a component.
     * Required: yes
     *
     * @see IClientSideComponentLoaderConfiguration.ts for more information and examples.
     */
    loaderConfig: IClientSideComponentLoaderConfiguration;
}
