{"version":3,"sources":["errorDetection/ErrorDetector.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;;AAI3D,IAAY,kBAIX;AAJD,WAAY,kBAAkB;IAC5B,uEAAc,CAAA;IACd,2EAAgB,CAAA;IAChB,uFAAsB,CAAA;AACxB,CAAC,EAJW,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAI7B;AAMD;;GAEG;AACH,4BAAmC,KAAa,EAC5C,QAA+C;IAEjD,MAAM,CAAC,UAAC,IAAY;QAClB,IAAM,KAAK,GAAoB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACzB,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC,CAAC;AACJ,CAAC;AAVD,gDAUC;AAED;;;;GAIG;AACH;IAGE,uBAAY,KAA4B;QACtC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACtB,CAAC;IAEM,+BAAO,GAAd,UAAe,IAAY;QAA3B,iBASC;QARC,IAAM,MAAM,GAAgB,EAAE,CAAC;QAC/B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,UAAC,IAAY;YACpC,IAAM,KAAK,GAAc,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAC/C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrB,CAAC;QACH,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAEO,kCAAU,GAAlB,UAAmB,IAAY;QAC7B,GAAG,CAAC,CAAe,UAAW,EAAX,KAAA,IAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW;YAAzB,IAAM,IAAI,SAAA;YACb,IAAM,KAAK,GAAc,IAAI,CAAC,IAAI,CAAC,CAAC;YACpC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC,KAAK,CAAC;YACf,CAAC;SACF;QACD,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC;IACH,oBAAC;AAAD,CA3BA,AA2BC,IAAA","file":"errorDetection/ErrorDetector.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport TaskError from './TaskError';\r\n\r\nexport enum ErrorDetectionMode {\r\n  LocalBuild = 1,\r\n  VisualStudio = 2,\r\n  VisualStudioOnline = 3\r\n}\r\n\r\nexport interface IErrorDetectionRule {\r\n  (line: string): TaskError;\r\n}\r\n\r\n/**\r\n * Creates an Error Detection Rule based on a regex and a function which converts a regex match to a TaskError\r\n */\r\nexport function RegexErrorDetector(regex: RegExp,\r\n    getError: (match: RegExpExecArray) => TaskError): IErrorDetectionRule {\r\n\r\n  return (line: string): TaskError => {\r\n    const match: RegExpExecArray = regex.exec(line);\r\n    if (match) {\r\n      return getError(match);\r\n    }\r\n    return undefined;\r\n  };\r\n}\r\n\r\n/**\r\n * The error detector will find all errors in a chunk of text by running a number\r\n * of error detection rules against each line of text.\r\n * @todo #168353: add unit tests for the ErrorDetector & for each individual rule in rules/\r\n */\r\nexport default class ErrorDetector {\r\n  private _rules: IErrorDetectionRule[];\r\n\r\n  constructor(rules: IErrorDetectionRule[]) {\r\n    this._rules = rules;\r\n  }\r\n\r\n  public execute(data: string): TaskError[] {\r\n    const errors: TaskError[] = [];\r\n    data.split('\\n').forEach((line: string) => {\r\n      const error: TaskError = this._checkLine(line);\r\n      if (error) {\r\n        errors.push(error);\r\n      }\r\n    });\r\n    return errors;\r\n  }\r\n\r\n  private _checkLine(line: string): TaskError {\r\n    for (const rule of this._rules) {\r\n      const error: TaskError = rule(line);\r\n      if (error) {\r\n        return error;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}