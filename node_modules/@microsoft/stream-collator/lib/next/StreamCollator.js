/**
 * @file StreamCollator.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * A special stream which will manage the output of multiple parallel streams,
 * ensuring that only 1 stream is writing to the console at a given time.
 */
/* istanbul ignore next */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var stream = require('stream');
var StreamState;
(function (StreamState) {
    StreamState[StreamState["Open"] = 0] = "Open";
    StreamState[StreamState["ClosedUnwritten"] = 1] = "ClosedUnwritten";
    StreamState[StreamState["Written"] = 2] = "Written";
})(StreamState || (StreamState = {}));
var StreamInfo = (function () {
    function StreamInfo(stream) {
        this.stream = stream;
        this.buffer = [];
        this.state = StreamState.Open;
    }
    StreamInfo.prototype.flush = function () {
        var data = this.buffer.join('');
        this.buffer = [];
        return data;
    };
    return StreamInfo;
}());
/**
 * A class which manages the output of multiple threads.
 */
var StreamCollator = (function (_super) {
    __extends(StreamCollator, _super);
    function StreamCollator() {
        _super.apply(this, arguments);
        this._streams = [];
        this._activeStream = undefined;
    }
    StreamCollator.prototype._read = function () {
        /* no-op */
    };
    ;
    /**
     * Registers a stream into the list of active buffers.
     */
    StreamCollator.prototype.register = function (stream) {
        var streamState = new StreamInfo(stream);
        stream.on('end', this._streamEnd(streamState));
        stream.on('data', this._streamData(streamState));
        this._streams.push(streamState);
        this._ensureActiveTask();
    };
    /**
     * Locates a suitable stream which could be set as the new active stream
     */
    StreamCollator.prototype._findActiveTaskCandidate = function () {
        for (var _i = 0, _a = this._streams; _i < _a.length; _i++) {
            var stream_1 = _a[_i];
            if (stream_1.state === StreamState.Open && stream_1 !== this._activeStream) {
                return stream_1;
            }
        }
    };
    /**
     * Ensures that a stream is set as active, will set the passed in stream as the active stream if none exists
     */
    StreamCollator.prototype._ensureActiveTask = function () {
        if (!this._activeStream) {
            var stream_2 = this._findActiveTaskCandidate();
            this._activeStream = stream_2;
            // In some cases there may be no streams which we can make active
            if (stream_2) {
                this._writeTaskBuffer(stream_2);
            }
        }
    };
    /**
     * Flushes a streams buffer and writes it to disk
     */
    StreamCollator.prototype._writeTaskBuffer = function (stream) {
        if (stream.buffer.length) {
            this.push(stream.flush());
        }
    };
    /**
     * The on('data') callback handler, which either writes or buffers the data
     */
    StreamCollator.prototype._streamData = function (stream) {
        var _this = this;
        return function (data) {
            if (_this._activeStream === stream) {
                _this.push(data.toString());
            }
            else {
                stream.buffer.push(data.toString());
            }
        };
    };
    /**
     * Marks a stream as completed. There are 3 cases:
     *  - If the stream was the active stream, also write out all completed, unwritten streams
     *  - If there is no active stream, write the output to the screen
     *  - If there is an active stream, mark the stream as completed and wait for active stream to complete
     */
    StreamCollator.prototype._streamEnd = function (stream) {
        var _this = this;
        return function () {
            if (stream === _this._activeStream) {
                _this._writeAllCompletedTasks();
                stream.state = StreamState.Written;
                _this._activeStream = undefined;
                _this._ensureActiveTask();
            }
            else {
                stream.state = StreamState.ClosedUnwritten;
            }
            // Close this if all substreams are closed
            if (_this._areStreamsClosedAndWritten()) {
                _this.push(null); // tslint:disable-line
            }
        };
    };
    /**
     * Helper function which returns true if all streams have been closed
     */
    StreamCollator.prototype._areStreamsClosedAndWritten = function () {
        for (var _i = 0, _a = this._streams; _i < _a.length; _i++) {
            var streamInfo = _a[_i];
            if (streamInfo.state !== StreamState.Written) {
                return false;
            }
        }
        return true;
    };
    /**
     * Helper function which writes all completed streams
     */
    StreamCollator.prototype._writeAllCompletedTasks = function () {
        for (var _i = 0, _a = this._streams; _i < _a.length; _i++) {
            var stream_3 = _a[_i];
            if (stream_3 && stream_3.state === StreamState.ClosedUnwritten) {
                this._writeTaskBuffer(stream_3);
                stream_3.state = StreamState.Written;
            }
        }
    };
    return StreamCollator;
}(stream.Readable));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StreamCollator;

//# sourceMappingURL=StreamCollator.js.map
