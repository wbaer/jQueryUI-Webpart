"use strict";
/* tslint:disable:max-line-length */
var path = require("path");
var fs = require("fs");
var logging_1 = require("../logging");
var gutil = require("gulp-util");
var through2 = require("through2");
/* tslint:disable:typedef */
var eos = require('end-of-stream');
/* tslint:enable:typedef */
var State_1 = require("../State");
var SchemaValidator_1 = require("../jsonUtilities/SchemaValidator");
/**
 * The base GulpTask class, should be extended by any classes which represent build tasks.
 * It provides convenient mechanisms for reading configuration files, validating their schema,
 * etc. It also provides convenient utility and logging functions.
 */
var GulpTask = (function () {
    function GulpTask() {
        /**
         * Indicates whether this task should be executed or not. This toggle is used by isEnabled() to determine
         * if the task should run. Since some tasks have more complex logic to determine if they should run or
         * not, the isEnabled() function can be overriden.
         */
        this.enabled = true;
    }
    /**
     * Overridable function which returns true if this task should be executed, or false if it should be skipped.
     * @param buildConfig - the build configuration which should be used when determining if the task is enabled
     * @returns true if the build is not redundant and the enabled toggle is true
     */
    GulpTask.prototype.isEnabled = function (buildConfig) {
        return (!buildConfig || !buildConfig.isRedundantBuild) && this.enabled;
    };
    Object.defineProperty(GulpTask.prototype, "schema", {
        /**
         * A JSON Schema object which will be used to validate this task's configuration file.
         * @returns a z-schema schema definition
         */
        get: function () {
            return this._schema ?
                this._schema :
                this._schema = this.loadSchema();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Override this function to provide a schema which will be used to validate
     * the task's configuration file. This function is called once per task instance.
     * @returns a z-schema schema definition
     */
    GulpTask.prototype.loadSchema = function () {
        return undefined;
    };
    ;
    /**
     * Shallow merges config settings into the task config.
     * Note this will override configuration options for those which are objects.
     * @param taskConfig - configuration settings which should be applied
     */
    GulpTask.prototype.setConfig = function (taskConfig) {
        /* tslint:disable:typedef */
        var objectAssign = require('object-assign');
        /* tslint:enable:typedef */
        this.taskConfig = objectAssign({}, this.taskConfig, taskConfig);
    };
    /**
     * Deep merges config settings into task config.
     * Do not use this function if the configuration contains complex objects that cannot be merged.
     * @param taskConfig - configuration settings which should be applied
     */
    GulpTask.prototype.mergeConfig = function (taskConfig) {
        /* tslint:disable:typedef */
        var merge = require('lodash.merge');
        /* tslint:enable:typedef */
        this.taskConfig = merge({}, this.taskConfig, taskConfig);
    };
    /**
     * Replaces all of the task config settings with new settings.
     * @param taskConfig - the new task configuration
     */
    GulpTask.prototype.replaceConfig = function (taskConfig) {
        this.taskConfig = taskConfig;
    };
    /**
     * This function is called when the task is initially registered into gulp-core-build as a task or subtask. It reads
     * the configuration file, validates it against the schema, then applies it to the task instance's configuration.
     */
    GulpTask.prototype.onRegister = function () {
        var configFilename = this._getConfigFilePath();
        var schema = this.schema;
        var rawConfig = this._readConfigFile(configFilename, schema);
        if (rawConfig) {
            this.mergeConfig(rawConfig);
        }
    };
    /**
     * Logs a message to standard output.
     * @param message - the message to log to standard output.
     */
    GulpTask.prototype.log = function (message) {
        logging_1.log("[" + gutil.colors.cyan(this.name) + "] " + message);
    };
    /**
     * Logs a message to standard output if the verbose flag is specified.
     * @param message - the message to log when in verbose mode
     */
    GulpTask.prototype.logVerbose = function (message) {
        logging_1.verbose("[" + gutil.colors.cyan(this.name) + "] " + message);
    };
    /**
     * Logs a warning. It will be logged to standard error and cause the build to fail
     * if buildConfig.shouldWarningsFailBuild is true, otherwise it will be logged to standard output.
     * @param message - the warning description
     */
    GulpTask.prototype.logWarning = function (message) {
        logging_1.warn("[" + gutil.colors.cyan(this.name) + "] " + message);
    };
    /**
     * Logs an error to standard error and causes the build to fail.
     * @param message - the error description
     */
    GulpTask.prototype.logError = function (message) {
        logging_1.error("[" + gutil.colors.cyan(this.name) + "] " + message);
    };
    /**
     * Logs an error regarding a specific file to standard error and causes the build to fail.
     * @param filePath - the path to the file which encountered an issue
     * @param line - the line in the file which had an issue
     * @param column - the column in the file which had an issue
     * @param errorCode - the custom error code representing this error
     * @param message - a description of the error
     */
    GulpTask.prototype.fileError = function (filePath, line, column, errorCode, message) {
        logging_1.fileError(this.name, filePath, line, column, errorCode, message);
    };
    /**
     * Logs a warning regarding a specific file.
     * @param filePath - the path to the file which encountered an issue
     * @param line - the line in the file which had an issue
     * @param column - the column in the file which had an issue
     * @param warningCode - the custom warning code representing this warning
     * @param message - a description of the warning
     */
    GulpTask.prototype.fileWarning = function (filePath, line, column, warningCode, message) {
        logging_1.fileWarning(this.name, filePath, line, column, warningCode, message);
    };
    /**
     * An overridable function which returns a list of glob patterns representing files that should be deleted
     * by the CleanTask.
     * @param buildConfig - the current build configuration
     * @param taskConfig - a task instance's configuration
     */
    GulpTask.prototype.getCleanMatch = function (buildConfig, taskConfig) {
        if (taskConfig === void 0) { taskConfig = this.taskConfig; }
        return this.cleanMatch;
    };
    /**
     * This function is called once to execute the task. It calls executeTask() and handles the return
     * value from that function. It also provides some utilities such as logging how long each
     * task takes to execute.
     * @param config - the buildConfig which is applied to the task instance before execution\
     * @returns a Promise which is completed when the task is finished executing
     */
    GulpTask.prototype.execute = function (config) {
        var _this = this;
        this.buildConfig = config;
        var startTime = process.hrtime();
        logging_1.logStartSubtask(this.name);
        return new Promise(function (resolve, reject) {
            /* tslint:disable:typedef */
            var stream;
            /* tslint:enable:typedef */
            try {
                if (!_this.executeTask) {
                    throw new Error('The task subclass is missing the "executeTask" method.');
                }
                stream = _this.executeTask(_this.buildConfig.gulp, function (result) {
                    if (!result) {
                        resolve();
                    }
                    else {
                        reject(result);
                    }
                });
            }
            catch (e) {
                _this.logError(e);
                reject(e);
            }
            if (stream) {
                if (stream.then) {
                    stream.then(resolve, reject);
                }
                else if (stream.pipe) {
                    // wait for stream to end
                    eos(stream, {
                        error: true,
                        readable: stream.readable,
                        writable: stream.writable && !stream.readable
                    }, function (err) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                    // Make sure the stream is completly read
                    stream.pipe(through2.obj(function (file, encoding, callback) {
                        'use strict';
                        callback();
                    }, function (callback) {
                        'use strict';
                        callback();
                    }));
                }
                else if (_this.executeTask.length === 1) {
                    resolve(stream);
                }
            }
            else if (_this.executeTask.length === 1) {
                resolve(stream);
            }
        })
            .then(function () {
            logging_1.logEndSubtask(_this.name, startTime);
        }, function (ex) {
            logging_1.logEndSubtask(_this.name, startTime, ex);
            throw ex;
        });
    };
    /**
     * Resolves a path relative to the buildConfig.rootPath.
     * @param localPath - a relative or absolute path
     * @returns If localPath is relative, returns an absolute path relative to the rootPath. Otherwise, returns localPath.
     */
    GulpTask.prototype.resolvePath = function (localPath) {
        /* tslint:disable:typedef */
        var path = require('path');
        /* tslint:enable:typedef */
        if (path.isAbsolute(localPath)) {
            return path.resolve(localPath);
        }
        return path.resolve(path.join(this.buildConfig.rootPath, localPath));
    };
    /**
     * Synchronously detect if a file exists.
     * @param localPath - the path to the file [resolved using resolvePath()]
     * @returns true if the file exists, false otherwise
     */
    GulpTask.prototype.fileExists = function (localPath) {
        /* tslint:disable:typedef */
        var fs = require('fs');
        /* tslint:enable:typedef */
        var doesExist = false;
        var fullPath = this.resolvePath(localPath);
        try {
            doesExist = fs.statSync(fullPath).isFile();
        }
        catch (e) { }
        return doesExist;
    };
    /**
     * Copy a file from one location to another.
     * @param localSourcePath - path to the source file
     * @param localDestPath - path to the destination file
     */
    GulpTask.prototype.copyFile = function (localSourcePath, localDestPath) {
        /* tslint:disable:typedef */
        var path = require('path');
        var fs = require('fs-extra');
        /* tslint:enable:typedef */
        var fullSourcePath = path.resolve(__dirname, localSourcePath);
        var fullDestPath = path.resolve(this.buildConfig.rootPath, (localDestPath || path.basename(localSourcePath)));
        fs.copySync(fullSourcePath, fullDestPath);
    };
    /**
     * Read a JSON file into an object
     * @param localPath - the path to the JSON file
     */
    GulpTask.prototype.readJSONSync = function (localPath) {
        var fullPath = this.resolvePath(localPath);
        var result = undefined;
        /* tslint:disable:typedef */
        var fs = require('fs');
        /* tslint:enable:typedef */
        try {
            var content = fs.readFileSync(fullPath, 'utf8');
            result = JSON.parse(content);
        }
        catch (e) { }
        return result;
    };
    /**
     * Returns the path to the config file used to configure this task
     */
    GulpTask.prototype._getConfigFilePath = function () {
        return path.join(process.cwd(), 'config', this.name + ".json");
    };
    /**
     * Helper function which loads a custom configuration file from disk and validates it against the schema
     * @param filePath - the path to the custom configuration file
     * @param schema - the z-schema schema object used to validate the configuration file
     * @returns If the configuration file is valid, returns the configuration as an object.
     */
    GulpTask.prototype._readConfigFile = function (filePath, schema) {
        if (!fs.existsSync(filePath)) {
            return undefined;
        }
        else {
            if (State_1.args['verbose']) {
                console.log("Found config file: " + path.basename(filePath));
            }
            var rawData = SchemaValidator_1.SchemaValidator.readCommentedJsonFile(filePath);
            if (schema) {
                SchemaValidator_1.SchemaValidator.validate(rawData, schema, filePath);
            }
            return rawData;
        }
    };
    return GulpTask;
}());
exports.GulpTask = GulpTask;

//# sourceMappingURL=GulpTask.js.map
