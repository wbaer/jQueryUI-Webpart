{"version":3,"sources":["writeManifests/cumulativeManifest/cumulativeManifestProcessor.ts"],"names":[],"mappings":";AAAA,yBAA2B;AAC3B,2BAA6B;AAC7B,uBAAyB;AAEzB,iCAAmC;AAGnC,yDAAgE;AAChE,qDAA2D;AAE3D,8CAAiD;AAEjD,oDAAuD;AACvD,6CAG+B;AAE/B,IAAM,0BAA0B,GAAW,WAAW,CAAC;AAEvD,IAAY,WA2BX;AA3BD,WAAY,WAAW;IACrB;;OAEG;IACH,6CAAI,CAAA;IAEJ;;OAEG;IACH,mDAAO,CAAA;IAEP;;OAEG;IACH,6CAAI,CAAA;IAEJ;;OAEG;IACH,yDAAU,CAAA;IAEV;;;;OAIG;IACH,6FAA4B,CAAA;AAC9B,CAAC,EA3BW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QA2BtB;AA8CD;IAKE,qCAAY,UAAyB,EAAE,OAAwC;QAAxC,wBAAA,EAAA,YAAwC;QAC7E,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,eAAe,GAAG,IAAI,GAAG,EAAiC,CAAC;IAClE,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACI,gEAA0B,GAAjC,UAAkC,IAAe,EACf,cAA8C;QADhF,iBA8CC;QA5CC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YACnB,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,oFAAoF,CAAC,CAAC;YAClH,MAAM,CAAC;QACT,CAAC;QAED,IAAM,0BAA0B,GAC9B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,QAAQ,EAAE,WAAW,CAAC,OAAO,CAAC,CAAC;QAErF,IAAM,MAAM,GAA6B,EAAE,CAAC;QAE5C,IAAM,OAAO,GAAW,IAAI,CAAC,QAAQ,CAAC,OAAO,IAAI,wBAAwB,CAAC,CAAC,uCAAuC;QAElH,IAAM,SAAS,GAAmD,EAAE,CAAC;QACrE,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,0BAA0B,CAAC,CAAC,CAAC;YAC5C,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,uBAAuB,IAAI,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACvG,SAAS,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,uBAAuB,CAAC,0BAA0B,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC;YACxF,CAAC;QACH,CAAC;QAED,cAAc,CAAC,OAAO,CAAC,UAAC,QAAsC;YAC5D,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,QAAQ,CAAC,uBAAuB,IAAI,KAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChH,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC;YACpC,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,IAAM,cAAc,GAAmC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,UAAC,EAAU,IAAK,OAAA,SAAS,CAAC,EAAE,CAAC,EAAb,CAAa,CAAC,CAAC;QAEjH,gCAAgC;QAChC,MAAM,CAAC,IAAI,CAAC,6BAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC,CAAC,EACzC,0BAA0B,UAAO,CAAC;aACpD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAEzE,8BAA8B;QAC9B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,iBAAiB,CAAC;aAC3B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,6BAA6B,CAAC,cAAc,CAAC,EACtE,SAAS,EACT,UAAC,KAAY,EAAE,KAA6B;YAC1C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACV,KAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,2CAAyC,KAAK,CAAC,QAAQ,EAAI,CAAC,CAAC;YACzF,CAAC;QACH,CAAC,CAAC,CAAC;aACF,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAE3E,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAED,sBAAW,0DAAiB;aAA5B;YACE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,kBAAkB,CAAC,CAAC;QAClD,CAAC;;;OAAA;IAEM,mEAA6B,GAApC,UAAqC,cAA8C;QACjF,eAAe,CAAC,cAAc,GAAG,cAAc,CAAC;QAChD,MAAM,CAAC;YACL,MAAM,EAAE;gBACN,OAAO,EAAE,gBAAgB;gBACzB,aAAa,EAAE,KAAK;gBACpB,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,CAAC;gBAC/F,QAAQ,EAAK,0BAA0B,QAAK;aAC7C;YACD,aAAa,EAAE;gBACb,IAAI,EAAE,SAAS;gBACf,KAAK,EAAE,SAAS;aACjB;SACF,CAAC;IACJ,CAAC;IAEM,2CAAK,GAAZ;QACE,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;IAEM,uDAAiB,GAAxB,UAAyB,WAAmB,EAAE,eAA4B;QAA1E,iBAwIC;QAvIC,IAAM,mBAAmB,GAAW,EAAE,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAEjE,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;YAClD,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;QACvD,CAAC;QAED,IAAM,0BAA0B,GAA0B,EAAE,CAAC;QAE7D,IAAM,QAAQ,GAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,IAAI,MAAM,CAAC,CAAC;QAC3G,IAAM,QAAQ,GAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,UAAU,IAAI,MAAM,CAAC,CAAC;QAC3G,IAAM,eAAe,GAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC;QAE/E,0GAA0G;QAC1G,gCAAgC;QAChC,IAAI,gBAAgB,GAAW,CAAC,CAAC;QACjC,IAAI,sBAAsB,GAAmC,SAAS,CAAC;QACvE,IAAI,4BAA4B,GAAY,KAAK,CAAC;QAClD,EAAE,CAAC,CAAC,eAAe,KAAK,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;YACzC,IAAI,CAAC;gBACH,IAAM,eAAe,GAAW,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAK,0BAA0B,UAAO,CAAC,CAAC;gBAC1F,IAAM,SAAS,GAAa,EAAE,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;gBACzD,gBAAgB,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;gBAC7C,sBAAsB,GAAG,kBAAS,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC;gBAC7D,4BAA4B,GAAG,IAAI,CAAC;YACtC,CAAC;YAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACX,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,4DAAuD,WAAW,eAAW;oBAC7E,qCAAqC,CAAC,CAAC;YACrE,CAAC;QACH,CAAC;QAED,mGAAmG;QACnG,EAAE,CAAC,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAC5B,sBAAsB,GAAG,EAAE,CAAC;YAC5B,2GAA2G;YAC3G,IAAM,oBAAkB,GAAW,8BAA8B,CAAC;YAClE,IAAI,CAAC;gBACH,EAAE,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,UAAC,YAAoB;oBACpD,EAAE,CAAC,CAAC,YAAY,CAAC,KAAK,CAAC,oBAAkB,CAAC,CAAC,CAAC,CAAC;wBAC3C,IAAI,CAAC;4BACH,IAAM,YAAY,GAAW,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;4BAC/D,IAAM,SAAS,GAAa,EAAE,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;4BACtD,IAAM,YAAY,GAAiC,kBAAS,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC;4BACpF,sBAAsB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;4BAC1C,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,gBAAgB,EAAE,SAAS,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;wBAC3E,CAAC;wBAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAa,CAAC;oBAC7B,CAAC;gBACH,CAAC,CAAC,CAAC;YACL,CAAC;YAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAEb,CAAC;QACH,CAAC;QAED,EAAE,CAAC,CAAC,CAAC,4BAA4B,IAAI,CAAC,eAAe,KAAK,WAAW,CAAC,IAAI;YACpC,eAAe,KAAK,WAAW,CAAC,4BAA4B;YAC5D,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACzE,yGAAyG;YACzG,IAAM,UAAQ,GAAyB,IAAI,GAAG,EAAmB,CAAC;YAClE,IAAI,CAAC;gBACH,IAAM,WAAW,GAAgB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC,CAAC;gBAEzF,IAAM,WAAW,GACE,UAAC,IAAyB,EAAE,QAAiB;oBAC9D,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACT,GAAG,CAAC,CAAC,IAAM,WAAW,IAAI,IAAI,CAAC,CAAC,CAAC;4BAC/B,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gCACrC,UAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;4BACtC,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC,CAAC;gBAEF,WAAW,CAAC,WAAW,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;gBAC7C,WAAW,CAAC,WAAW,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;gBAC/C,WAAW,CAAC,WAAW,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC;YACtD,CAAC;YAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAa,CAAC;YAE3B,+CAA+C;YAC/C,UAAQ,CAAC,OAAO,CAAC,UAAC,QAAiB,EAAE,WAAmB;gBACtD,IAAI,qBAA6B,CAAC;gBAClC,IAAI,CAAC;oBACH,qBAAqB,GAAG,wBAAc,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;gBACnE,CAAC;gBAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAa,CAAC;gBAE3B,EAAE,CAAC,CAAC,qBAAqB,CAAC,CAAC,CAAC;oBAC1B,IAAM,wBAAwB,GAAgB,CAAC,eAAe,KAAK,WAAW,CAAC,OAAO,CAAC;0BACnF,WAAW,CAAC,IAAI;0BAChB,CAAC,eAAe,KAAK,WAAW,CAAC,4BAA4B;8BACzD,WAAW,CAAC,UAAU;8BACtB,eAAe,CAAC,CAAC;oBACzB,IAAM,SAAS,GACb,KAAI,CAAC,iBAAiB,CAAC,qBAAqB,EAAE,wBAAwB,CAAC,CAAC;oBAE1E,GAAG,CAAC,CAAC,IAAM,UAAU,IAAI,SAAS,CAAC,CAAC,CAAC;wBACnC,EAAE,CAAC,CAAC,SAAS,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;4BACzC,0BAA0B,CAAC,UAAU,CAAC,GAAG,SAAS,CAAC,UAAU,CAAC,CAAC;wBACjE,CAAC;oBACH,CAAC;gBACH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;oBACrB,8CAA8C;oBAC9C,KAAI,CAAC,WAAW,CAAC,UAAU,CAAC,iCAA8B,WAAW,SAAK;wBAC9C,4BAA4B,CAAC,CAAC;gBAC5D,CAAC;YACH,CAAC,CAAC,CAAC;QACL,CAAC;QAED,+GAA+G;QAC/G,WAAW;QACX,EAAE,CAAC,CAAC,sBAAsB,CAAC,CAAC,CAAC;YAC3B,IAAI,WAAW,SAAQ,CAAC;YACxB,oFAAoF;YACpF,EAAE,CAAC,CAAC,sBAAsB,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,CAAC;oBACH,IAAM,WAAW,GAAgB,OAAO,CAAC,eAAe,CAAC,CAAC;oBAC1D,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC;gBACjC,CAAC;gBAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAa,CAAC;YAC7B,CAAC;YAED,GAAG,CAAC,CAAmB,UAAsB,EAAtB,iDAAsB,EAAtB,oCAAsB,EAAtB,IAAsB;gBAAxC,IAAM,QAAQ,+BAAA;gBACjB,IAAM,EAAE,GAAW,QAAQ,CAAC,EAAE,CAAC;gBAC/B,IAAM,gBAAgB,GAAuB,0BAA0B,CAAC,EAAE,CAAC,CAAC;gBAC5E,EAAE,CAAC,CAAC,CAAC,gBAAgB,IAAI,gBAAgB,GAAG,gBAAgB,CAAC,oBAAoB,CAAC,CAAC,CAAC;oBAClF,yCAAyC;oBACzC,0BAA0B,CAAC,EAAE,CAAC,GAAG;wBAC/B,oBAAoB,EAAE,gBAAgB;wBACtC,WAAW,aAAA;wBACX,WAAW,aAAA;wBACX,YAAY,EAAE,QAAQ;qBACvB,CAAC;gBACJ,CAAC;aACF;QACH,CAAC;QAED,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,mBAAmB,EAAE,0BAA0B,CAAC,CAAC;QAE1E,MAAM,CAAC,0BAA0B,CAAC;IACpC,CAAC;IAEO,6DAAuB,GAA/B,UAAgC,gBAAoC,EAAE,OAAe;QACnF,IAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,QAAQ,EAAE,gBAAgB,CAAC,WAAW,CAAC,CAAC;QAChH,IAAM,QAAQ,GAAiC,gBAAgB,CAAC,YAAY,CAAC;QAE7E,IAAM,QAAQ,GAAa,QAAQ,CAAC,YAAY,CAAC,sBAAsB,IAAI,EAAE,CAAC;QAE9E,IAAM,GAAG,GAAW,qBAAe,CAAC,OAAO,EAAE,SAAS,CAAC,YAAY,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QAC1F,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACxB,IAAM,WAAW,GAAY,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACpD,QAAQ,CAAC,CAAC,CAAC,GAAG,qBAAe,CAAC,GAAG,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;QAC3D,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,QAAQ,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;QACpB,CAAC;QAED,QAAQ,CAAC,YAAY,CAAC,sBAAsB,GAAG,QAAQ,CAAC,GAAG,CAAC,UAAC,qBAA6B;YACxF,IAAM,aAAa,GAAY,GAAG,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;YAChE,aAAa,CAAC,QAAQ,GAAG,aAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACtE,qBAAqB,GAAG,GAAG,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YAElD,MAAM,CAAC,yBAAmB,CAAC,qBAAqB,CAAC,CAAC;QACpD,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,QAAQ,CAAC;IAClB,CAAC;IACF,kCAAC;AAAD,CAtQD,AAsQE,IAAA","file":"writeManifests/cumulativeManifest/cumulativeManifestProcessor.js","sourcesContent":["import * as Url from 'url';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport * as gulp from 'gulp';\r\nimport { cloneDeep } from 'lodash';\r\nimport { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';\r\nimport { GulpTask } from '@microsoft/gulp-core-build';\r\nimport { writeStringToFile } from './../../utilities/FileUtils';\r\nimport { resolvePackage } from './../../utilities/Resolve';\r\nimport * as Webpack from 'webpack';\r\nimport webpackStream = require('webpack-stream');\r\n\r\nimport manifestsLoader = require('./manifests-loader');\r\nimport {\r\n  joinUrlSegments,\r\n  ensureTrailingSlash\r\n} from './../../utilities/url';\r\n\r\nconst cumulativeManifestFileName: string = 'manifests';\r\n\r\nexport enum ForceSearch {\r\n  /**\r\n   * Don't force a manifest search anywhere. Use the manifests.json file everywhere if it's found.\r\n   */\r\n  none,\r\n\r\n  /**\r\n   * Don't force a manifest search in the first project, but use the manifests.json file in other packages.\r\n   */\r\n  shallow,\r\n\r\n  /**\r\n   * Don't use the manifests.json file anywhere, and search every single package.\r\n   */\r\n  deep,\r\n\r\n  /**\r\n   * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found.\r\n   */\r\n  deepSparse,\r\n\r\n  /**\r\n   * Don't use the manifests.json file anywhere, but only recurse in packages where other manifests were found,\r\n   *  except for the first project. Always recurse from the first project. This option is useful if it's uncertain\r\n   *  whether the first project has been built, but otherwise \"deepSparse\" is intended behavior.\r\n   */\r\n  deepSparseIgnoreFirstProject\r\n}\r\n\r\nexport interface ICumulativeManifestOptions {\r\n  /**\r\n   * IDs of manifests to exclude from the manifest map file.\r\n   */\r\n  ignoreOutputManifestIds?: string[];\r\n\r\n  /**\r\n   * The base path for debug manifests. Expected to match the result of the \"debugBasePath\" function passed to the\r\n   *  WriteManifestsTask task.\r\n   */\r\n  baseUrl?: string;\r\n}\r\n\r\nexport interface IReferencedProject {\r\n  /**\r\n   * The creation time of the newest version of this manifest we've found\r\n   */\r\n  manifestCreationTime: number;\r\n\r\n  /**\r\n   * The project's manifest data\r\n   */\r\n  manifestData: IClientSideComponentManifest;\r\n\r\n  /**\r\n   * The root path of the project.\r\n   */\r\n  packagePath: string;\r\n\r\n  /**\r\n   * The name of the package, if it can be inferred. The name can only be inferred if it's in a project with only\r\n   *  one manifest.\r\n   */\r\n  packageName: string;\r\n}\r\n\r\nexport interface IReferencedProjectMap {\r\n  [id: string]: IReferencedProject;\r\n}\r\n\r\ninterface IReferenceContainer {\r\n  [packageName: string]: string;\r\n}\r\n\r\nexport default class CumulativeManifestProcessor {\r\n  private _options: ICumulativeManifestOptions;\r\n  private _parentTask: GulpTask<{}>;\r\n  private _discoveryCache: Map<string, IReferencedProjectMap>;\r\n\r\n  constructor(parentTask: GulpTask<any>, options: ICumulativeManifestOptions = {}) { // tslint:disable-line:no-any\r\n    this._options = options;\r\n    this._parentTask = parentTask;\r\n    this._discoveryCache = new Map<string, IReferencedProjectMap>();\r\n  }\r\n\r\n  /**\r\n   * Ths function:\r\n   *  1. discovers all packages referenced in package.json\r\n   *  2a. looks for a file in each discovered project's temp folder called manifests.json\r\n   *  2b. looks for <id>.manifest.json files in the dist folder\r\n   *  3. keeps a record of all of the manifests discovered in the referenced projects, and resolves duplicates by\r\n   *      taking the newest file\r\n   *  4. generates new base URLs for each of the referenced projects' manifests to make them valid when \"gulp serve\"\r\n   *      is run from this current project's directory\r\n   *  5. collects all of these discovered manifests and the debugManifests parameter and generates an array of all\r\n   *      manifests\r\n   *  6. filters this array by the ignoreOutputManifestIds options\r\n   *  7. drops a JSON file in the temp directory called manifests.json containing this array\r\n   *  9. drops an initialization script in the temp directory called manifests.js that\r\n   *      exports two functions. One that retruns the array with the manifests' base URLs as fully-qualified, and the\r\n   *      other with manifests' base URLs as relative to the page root.\r\n   */\r\n  public generateCumulativeManifest(gulp: gulp.Gulp,\r\n                                    debugManifests: IClientSideComponentManifest[]): NodeJS.ReadWriteStream[] {\r\n    if (!this._options) {\r\n      this._parentTask.logVerbose('No cumulative manifest options specified. Skipping cumulative manifest generation.');\r\n      return;\r\n    }\r\n\r\n    const referencedProjectManifests: IReferencedProjectMap =\r\n      this.discoverManifests(this._parentTask.buildConfig.rootPath, ForceSearch.shallow);\r\n\r\n    const result: NodeJS.ReadWriteStream[] = [];\r\n\r\n    const baseUrl: string = this._options.baseUrl || 'https://localhost:4321'; // Default if one isn't already defined\r\n\r\n    const manifests: { [id: string]: IClientSideComponentManifest } = {};\r\n    for (const id in referencedProjectManifests) {\r\n      if (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(id) === -1) {\r\n        manifests[id] = this._getTransformedManifest(referencedProjectManifests[id], baseUrl);\r\n      }\r\n    }\r\n\r\n    debugManifests.forEach((manifest: IClientSideComponentManifest) => {\r\n      if (!this._options.ignoreOutputManifestIds || this._options.ignoreOutputManifestIds.indexOf(manifest.id) === -1) {\r\n        manifests[manifest.id] = manifest;\r\n      }\r\n    });\r\n\r\n    const manifestsArray: IClientSideComponentManifest[] = Object.keys(manifests).map((id: string) => manifests[id]);\r\n\r\n    // Write the manifests.json file\r\n    result.push(writeStringToFile(JSON.stringify(manifestsArray, undefined, 2),\r\n                                  `${cumulativeManifestFileName}.json`)\r\n                  .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));\r\n\r\n    // Write the manifests.js file\r\n    result.push(gulp.src(this.manifestsFilePath)\r\n                    .pipe(webpackStream(this.getManifestsFileWebpackConfig(manifestsArray),\r\n                    undefined,\r\n                    (error: Error, stats: Webpack.compiler.Stats) => {\r\n                      if (error) {\r\n                        this._parentTask.logError(`Error generating cumulative manifest: ${error.toString()}`);\r\n                      }\r\n                    }))\r\n                    .pipe(gulp.dest(this._parentTask.buildConfig.tempFolder)));\r\n\r\n    return result;\r\n  }\r\n\r\n  public get manifestsFilePath(): string {\r\n    return path.join(__dirname, 'manifestsFile.js');\r\n  }\r\n\r\n  public getManifestsFileWebpackConfig(manifestsArray: IClientSideComponentManifest[]): Webpack.Configuration {\r\n    manifestsLoader.manifestObject = manifestsArray;\r\n    return {\r\n      output: {\r\n        library: 'debugManifests',\r\n        libraryTarget: 'umd',\r\n        path: path.join(this._parentTask.buildConfig.rootPath, this._parentTask.buildConfig.tempFolder),\r\n        filename: `${cumulativeManifestFileName}.js`\r\n      },\r\n      resolveLoader: {\r\n        root: __dirname,\r\n        alias: undefined\r\n      }\r\n    };\r\n  }\r\n\r\n  public reset(): void {\r\n    this._discoveryCache.clear();\r\n  }\r\n\r\n  public discoverManifests(packagePath: string, forceSearchMode: ForceSearch): IReferencedProjectMap {\r\n    const resolvedPackagePath: string = fs.realpathSync(packagePath);\r\n\r\n    if (this._discoveryCache.has(resolvedPackagePath)) {\r\n      return this._discoveryCache.get(resolvedPackagePath);\r\n    }\r\n\r\n    const referencedProjectManifests: IReferencedProjectMap = {};\r\n\r\n    const tempPath: string = path.join(resolvedPackagePath, this._parentTask.buildConfig.tempFolder || 'temp');\r\n    const distPath: string = path.join(resolvedPackagePath, this._parentTask.buildConfig.distFolder || 'dist');\r\n    const packageJsonPath: string = path.join(resolvedPackagePath, 'package.json');\r\n\r\n    // We want to make sure if we have multiple files with the same component's manifest, we pick the one that\r\n    //  was generated most recently.\r\n    let fileModifiedtime: number = 0;\r\n    let linkedProjectManifests: IClientSideComponentManifest[] = undefined;\r\n    let foundCumulativeManifestsFile: boolean = false;\r\n    if (forceSearchMode === ForceSearch.none) {\r\n      try {\r\n        const manifestMapPath: string = path.join(tempPath, `${cumulativeManifestFileName}.json`);\r\n        const fileStats: fs.Stats = fs.statSync(manifestMapPath);\r\n        fileModifiedtime = fileStats.mtime.getTime();\r\n        linkedProjectManifests = cloneDeep(require(manifestMapPath));\r\n        foundCumulativeManifestsFile = true;\r\n      } catch (e) {\r\n        this._parentTask.logVerbose(`Unable to get \"manifests.json\" file for project in \"${packagePath}\". We'll ` +\r\n                                    'try to get each manifest seperately');\r\n      }\r\n    }\r\n\r\n    // If we didn't find a manifests.json file, we should look for individual <id>.manifest.json files.\r\n    if (!linkedProjectManifests) {\r\n      linkedProjectManifests = [];\r\n      // Look for files called something like \"abc123.manifest.json\" without any leading slashes or extra periods\r\n      const manifestFileRegExp: RegExp = /^[^\\.\\\\\\/]+\\.manifest\\.json$/;\r\n      try {\r\n        fs.readdirSync(distPath).forEach((distFilename: string) => {\r\n          if (distFilename.match(manifestFileRegExp)) {\r\n            try {\r\n              const distFilePath: string = path.join(distPath, distFilename);\r\n              const fileStats: fs.Stats = fs.statSync(distFilePath);\r\n              const manifestData: IClientSideComponentManifest = cloneDeep(require(distFilePath));\r\n              linkedProjectManifests.push(manifestData);\r\n              fileModifiedtime = Math.max(fileModifiedtime, fileStats.mtime.getTime());\r\n            } catch (e) { /* empty */ }\r\n          }\r\n        });\r\n      } catch (e) {\r\n        /* Error getting manifest file data */\r\n      }\r\n    }\r\n\r\n    if (!foundCumulativeManifestsFile && (forceSearchMode === ForceSearch.deep ||\r\n                                          forceSearchMode === ForceSearch.deepSparseIgnoreFirstProject ||\r\n                                          linkedProjectManifests.length > 0)) {\r\n      // If this project has manifests, or we're forcing search, let's look in its references in other projects\r\n      const packages: Map<string, boolean> = new Map<string, boolean>();\r\n      try {\r\n        const packageJson: PackageJson = require(path.join(resolvedPackagePath, 'package.json'));\r\n\r\n        const getPackages: (refs: IReferenceContainer, optional: boolean) => void =\r\n                           (refs: IReferenceContainer, optional: boolean) => {\r\n          if (refs) {\r\n            for (const packageName in refs) {\r\n              if (refs.hasOwnProperty(packageName)) {\r\n                packages.set(packageName, optional);\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        getPackages(packageJson.dependencies, false);\r\n        getPackages(packageJson.devDependencies, true);\r\n        getPackages(packageJson.optionalDependencies, true);\r\n      } catch (e) { /* empty */ }\r\n\r\n      // Search each referenced project for manifests\r\n      packages.forEach((optional: boolean, packageName: string) => {\r\n        let referencedPackagePath: string;\r\n        try {\r\n          referencedPackagePath = resolvePackage(packageName, packagePath);\r\n        } catch (e) { /* empty */ }\r\n\r\n        if (referencedPackagePath) {\r\n          const recursiveForceSearchMode: ForceSearch = (forceSearchMode === ForceSearch.shallow)\r\n            ? ForceSearch.none\r\n            : (forceSearchMode === ForceSearch.deepSparseIgnoreFirstProject\r\n                ? ForceSearch.deepSparse\r\n                : forceSearchMode);\r\n          const manifests: IReferencedProjectMap =\r\n            this.discoverManifests(referencedPackagePath, recursiveForceSearchMode);\r\n\r\n          for (const manifestId in manifests) {\r\n            if (manifests.hasOwnProperty(manifestId)) {\r\n              referencedProjectManifests[manifestId] = manifests[manifestId];\r\n            }\r\n          }\r\n        } else if (!optional) {\r\n          // Only warn if this isn't an optional package\r\n          this._parentTask.logWarning(`Unable to resolve project \"${packageName}\". ` +\r\n                                      'Ensure it has been linked.');\r\n        }\r\n      });\r\n    }\r\n\r\n    // If we found any manifests directly linked to this project, merge them into the manifests discovered in other\r\n    // projects\r\n    if (linkedProjectManifests) {\r\n      let packageName: string;\r\n      // Include the package name if we found a single project manifest in the dist folder\r\n      if (linkedProjectManifests.length === 1) {\r\n        try {\r\n          const packageJson: PackageJson = require(packageJsonPath);\r\n          packageName = packageJson.name;\r\n        } catch (e) { /* empty */ }\r\n      }\r\n\r\n      for (const manifest of linkedProjectManifests) {\r\n        const id: string = manifest.id;\r\n        const existingManifest: IReferencedProject = referencedProjectManifests[id];\r\n        if (!existingManifest || fileModifiedtime > existingManifest.manifestCreationTime) {\r\n          // Only update if this manifest is newer.\r\n          referencedProjectManifests[id] = {\r\n            manifestCreationTime: fileModifiedtime,\r\n            packagePath,\r\n            packageName,\r\n            manifestData: manifest\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    this._discoveryCache.set(resolvedPackagePath, referencedProjectManifests);\r\n\r\n    return referencedProjectManifests;\r\n  }\r\n\r\n  private _getTransformedManifest(referenceProject: IReferencedProject, baseUrl: string): IClientSideComponentManifest {\r\n    const relativePath: string = path.relative(this._parentTask.buildConfig.rootPath, referenceProject.packagePath);\r\n    const manifest: IClientSideComponentManifest = referenceProject.manifestData;\r\n\r\n    const baseUrls: string[] = manifest.loaderConfig.internalModuleBaseUrls || [];\r\n\r\n    const url: string = joinUrlSegments(baseUrl, encodeURI(relativePath.replace(/\\\\/g, '/')));\r\n    if (baseUrls.length > 0) {\r\n      const existingUrl: Url.Url = Url.parse(baseUrls[0]);\r\n      baseUrls[0] = joinUrlSegments(url, existingUrl.pathname);\r\n    } else {\r\n      baseUrls[0] = url;\r\n    }\r\n\r\n    manifest.loaderConfig.internalModuleBaseUrls = baseUrls.map((internalModuleBaseUrl: string) => {\r\n      const baseUrlObject: Url.Url = Url.parse(internalModuleBaseUrl);\r\n      baseUrlObject.pathname = baseUrlObject.pathname.replace(/\\/\\//g, '/');\r\n      internalModuleBaseUrl = Url.format(baseUrlObject);\r\n\r\n      return ensureTrailingSlash(internalModuleBaseUrl);\r\n    });\r\n\r\n    return manifest;\r\n  }\r\n }"],"sourceRoot":"..\\..\\..\\src"}