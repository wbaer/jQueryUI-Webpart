export declare enum PackageDependencyKind {
    Normal = 0,
    /**
     * The dependency was listed in the optionalDependencies section of package.json.
     */
    Optional = 1,
    /**
     * The dependency should be a symlink to a project that is locally built by Rush..
     */
    LocalLink = 2,
}
export interface IPackageDependency {
    /**
     * The name of the dependency
     */
    name: string;
    /**
     * The requested version, which may be a pattern such as "^1.2.3"
     */
    versionRange: string;
    /**
     * The kind of dependency
     */
    kind: PackageDependencyKind;
}
export interface IPackageJson extends PackageJson {
    /**
     * An extra setting written into package.json for temp packages, to track
     * references to locally built projects.
     */
    rushDependencies?: {
        [key: string]: string;
    };
}
export default class Package {
    /**
     * The "name" field from package.json
     */
    name: string;
    /**
     * The "version" field from package.json
     */
    version: string;
    /**
     * Names of packages that we explicitly depend on.  The actual dependency
     * package may be found in this.children, or possibly in this.children of
     * one of the parents.
     * If a dependency is listed in the "optionalDependencies" section of package.json
     * then its name here will be prepended with a "?" character, which means that Rush
     * will not report an error if the module cannot be found in the Common folder.
     */
    dependencies: IPackageDependency[];
    /**
     * The absolute path to the folder that contains package.json.
     */
    folderPath: string;
    /**
     * The parent package, or undefined if this is the root of the tree.
     */
    parent: Package;
    /**
     * If this is a local path that we are planning to symlink to a target folder,
     * then symlinkTargetFolderPath keeps track of the intended target.
     */
    symlinkTargetFolderPath: string;
    /**
     * If this was loaded using createFromNpm(), then the parsed package.json is stored here.
     */
    originalPackageJson: PackageJson;
    /**
     * Packages that were placed in node_modules subfolders of this package.
     * The child packages are not necessarily dependencies of this package.
     */
    children: Package[];
    private _childrenByName;
    /**
     * Recursive constructs a tree of Package objects using information returned
     * by the "read-package-tree" library.
     */
    static createFromNpm(npmPackage: PackageNode): Package;
    constructor(name: string, version: string, dependencies: IPackageDependency[], folderPath: string);
    readonly nameAndVersion: string;
    addChild(child: Package): void;
    getChildByName(childPackageName: string): Package;
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  Note that the nearest match may have an incompatible version.
     * If a match is found, then the "found" result will not be undefined.
     * In either case, the parentForCreate result indicates where the missing
     * dependency can be added, i.e. if the requested dependency was not found
     * or was found with an incompatible version.
     *
     * "cyclicSubtreeRoot" is a special optional parameter that specifies a different
     * root for the tree; the cyclicDependencyProjects feature uses this to isolate
     * certain devDependencies in their own subtree.
     */
    resolveOrCreate(dependencyName: string, cyclicSubtreeRoot?: Package): IResolveOrCreateResult;
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  If no match is found, then undefined is returned.
     */
    resolve(dependencyName: string): Package;
    printTree(indent?: string): void;
}
export interface IResolveOrCreateResult {
    found: Package;
    parentForCreate: Package;
}
