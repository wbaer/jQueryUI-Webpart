import { ObservableValue } from './observablevalue';
import { Lambda, IObjectChange } from './interfaces';
export interface KeyValueMap<V> {
    [key: string]: V;
}
export declare type Entries<V> = [string, V][];
export declare type IObservableMapChange<T> = IObjectChange<T, ObservableMap<T>>;
export declare class ObservableMap<V> {
    $mobservable: {};
    private _data;
    private _hasMap;
    private _keys;
    private _valueMode;
    private _events;
    constructor(initialData?: Entries<V> | KeyValueMap<V>, valueModeFunc?: Function);
    _has(key: string): boolean;
    has(key: string): boolean;
    set(key: string, value: V): void;
    delete(key: string): void;
    _updateHasMapEntry(key: string, value: boolean): ObservableValue<boolean>;
    get(key: string): V;
    keys(): string[];
    values(): V[];
    entries(): Entries<V>;
    forEach(callback: (value: V, key: string, object: KeyValueMap<V>) => void, thisArg?: any): void;
    merge(other: ObservableMap<V> | KeyValueMap<V>): ObservableMap<V>;
    clear(): void;
    size: number;
    toJs(): KeyValueMap<V>;
    private isValidKey(key);
    private assertValidKey(key);
    toString(): string;
    observe(callback: (changes: IObservableMapChange<V>) => void): Lambda;
}
