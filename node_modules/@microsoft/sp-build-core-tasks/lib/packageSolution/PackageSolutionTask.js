'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require("path");
var through2 = require("through2");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var createPackage_1 = require("./packageSolution/createPackage");
var manifestSchemaValidator_1 = require("@microsoft/sp-module-interfaces/lib/manifestSchemaValidator");
var PackageSolutionTask = (function (_super) {
    __extends(PackageSolutionTask, _super);
    function PackageSolutionTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'package-solution';
        _this.taskConfig = {
            paths: {
                packageDir: 'sharepoint',
                debugDir: path.join('solution', 'debug'),
                zippedPackage: path.join('solution', 'ClientSolution.sppkg'),
                featureXmlDir: 'feature_xml',
                sharepointAssetDir: 'assets',
                manifestsMatch: '*.json'
            },
            solution: {
                'name': 'A Sample Solution',
                'id': '00000000-0000-0000-0000-000000000000'
            }
        };
        _this._hasPrependedPaths = false;
        return _this;
    }
    PackageSolutionTask.prototype.loadSchema = function () {
        return require('./package-solution.schema.json');
    };
    PackageSolutionTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        if (!this.taskConfig.paths.manifestDir) {
            this.taskConfig.paths.manifestDir = this.buildConfig.distFolder;
        }
        this._prependBaseToConfigPaths();
        var manifestMap = new Map();
        var foundAnyManifests = false;
        return gulp.src(this.taskConfig.paths.manifestsMatch)
            .pipe(through2.obj(function (file, enc, callback) {
            foundAnyManifests = true;
            var manifest = JSON.parse(file.contents.toString(enc));
            var validationResult = manifestSchemaValidator_1.default.validateManifest(manifest);
            if (!validationResult.result) {
                _this.log("Ignoring manifest due to validation error: (" + file.path + ") use '--verbose' for more information");
                _this.logVerbose(manifestSchemaValidator_1.default.getFormattedErrorMessage(validationResult.errors));
                callback();
                return;
            }
            _this.log("Found manifest: " + file.path);
            manifestMap.set(manifest.id, manifest);
            callback();
        }, function (callback) {
            if (!manifestMap.size) {
                if (foundAnyManifests) {
                    callback(new Error("Some manifests were found in '" + _this.taskConfig.paths.manifestsMatch + "' " +
                        ', but were not valid. Ensure paths.manifestsMatch is correct'));
                }
                else {
                    callback(new Error("No manifests were found in '" + _this.taskConfig.paths.manifestsMatch + "'. " +
                        'Ensure a build has completed successfully and that paths.manifestsMatch is correct'));
                }
            }
            createPackage_1.default(_this.taskConfig, manifestMap).then(callback, callback);
        }));
    };
    PackageSolutionTask.prototype.getCleanMatch = function (buildConfig) {
        this.buildConfig = buildConfig;
        if (!this.taskConfig.paths.manifestDir) {
            this.taskConfig.paths.manifestDir = this.buildConfig.distFolder;
        }
        this._prependBaseToConfigPaths();
        return [
            this.taskConfig.paths.debugDir,
            this.taskConfig.paths.zippedPackage
        ];
    };
    PackageSolutionTask.prototype._prependBaseToConfigPaths = function () {
        if (!this._hasPrependedPaths) {
            this.taskConfig.paths.manifestsMatch =
                path.join(this.taskConfig.paths.manifestDir, this.taskConfig.paths.manifestsMatch);
            this.taskConfig.paths.debugDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.debugDir);
            this.taskConfig.paths.zippedPackage =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.zippedPackage);
            this.taskConfig.paths.featureXmlDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.featureXmlDir);
            this.taskConfig.paths.sharepointAssetDir =
                path.join(this.taskConfig.paths.packageDir, this.taskConfig.paths.sharepointAssetDir);
            this._hasPrependedPaths = true;
        }
    };
    return PackageSolutionTask;
}(gulp_core_build_1.GulpTask));
exports.PackageSolutionTask = PackageSolutionTask;

//# sourceMappingURL=PackageSolutionTask.js.map
