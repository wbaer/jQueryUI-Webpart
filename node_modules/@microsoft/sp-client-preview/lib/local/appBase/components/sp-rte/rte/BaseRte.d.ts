/// <reference types="es6-promise" />
/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
import * as React from 'react';
import { _QosMonitor } from '@ms/sp-telemetry';
import { IRange } from './IRange';
import { IRichTextEditor } from './IRichTextEditor';
import { IRichTextEditorOptions } from './IRichTextEditorOptions';
import { DisplayMode } from '@microsoft/sp-core-library';
import { IRichTextEditorConfiguration } from './IRichTextEditorConfiguration';
import SPRteFormattingBar, { ISPRteFormattingBarPosition } from '../formattingbar/SPRteFormattingBar';
import SPRteLinkDialog from '../formattingbar/SPRteLinkDialog';
import { ButtonState } from '../../sp-canvas/toolbar/toolbarButton/ToolbarButton';
import { BaseComponent } from 'office-ui-fabric-react';
import './BaseRte.scss';
export interface IBaseRteProps {
    displayMode: DisplayMode;
    options?: IRichTextEditorOptions;
    innerHTML?: string;
    editorType?: string;
}
export interface IBaseRteState {
    currentSubmenuOpen?: 'format';
    displayMode?: DisplayMode;
    formattingBarPosition?: ISPRteFormattingBarPosition;
    isFormattingBarHidden?: boolean;
    isLinkDialogOpen?: boolean;
    isImageWrappedWithText?: boolean;
    isPasteInProgress?: boolean;
    isContextMenuVisible?: boolean;
    contextMenuTarget?: Element;
}
export declare const CREATE_EDITOR_MONITOR: string;
export declare const CREATE_EDITOR_MONITOR_FAILURE: string;
/**
 * @class Rich Text Editor class. This component wraps around all the RTE logic including the formatting bar.
 */
export declare abstract class BaseRte<P extends IBaseRteProps, S extends IBaseRteState> extends BaseComponent<P, IBaseRteState> {
    protected static _URL_VALIDATION_REGEX: RegExp;
    protected readonly abstract TAG_NAME: string;
    protected _options: IRichTextEditorOptions;
    protected _config: IRichTextEditorConfiguration;
    protected _currentSelection: IRange;
    protected _editor: IRichTextEditor;
    protected _editorElement: HTMLDivElement;
    protected _editableDiv: HTMLElement;
    protected _formattingbar: SPRteFormattingBar;
    protected _formattingbarElement: HTMLElement;
    protected _formattingbarWidth: number;
    protected _isRtl: boolean;
    protected _buttonStates: Map<string, ButtonState>;
    protected _linkAddress: string;
    protected _linkDialog: SPRteLinkDialog;
    protected _linkElement: HTMLElement;
    /**
     * _previousHTML is set when a the _quill instance is destroyed.
     * We destroy the quill editor when SPRte is in read mode. The Quill HTML content is used to create a new
     * Quill instance if SPRte is switched from edit -> read -> edit modes in one session.
     */
    protected _previousHTML: string;
    /**
     * This stores reference to .ql-editor element to avoid finding it on every render
     */
    protected _restoreSelectionOnNextFocus: boolean;
    protected _selectionInitiated: boolean;
    protected _selectionShouldEnd: boolean;
    protected _createNewEditorMonitor: _QosMonitor;
    /**
     * Logic in updateFormattingBar depends on document.activeElement being a button in the Formatting Bar
     * if the selection change came from the Formatting Bar. However, on Safari 10 document.activeElement is the
     * ControlZone because it is has a tab-index. The Formatting Bar buttons are in a FocusZone, which has some
     * logic that manipulates tab-index and in Safari 10's case doesn't allow the Formatting Bar button to become
     * document.activeElement. _isSelectionChangeFromToolbar keeps track of when a Formatting Bar button's handler
     * is invoked and to then not hide the Formatting Bar.
     */
    protected _isSelectionChangeFromToolbar: boolean;
    constructor(props: P, rteOptions?: IRichTextEditorOptions);
    protected _initState(): void;
    render(): React.ReactElement<P>;
    componentWillMount(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: P, prevState: S): void;
    componentWillUnmount(): void;
    componentWillUpdate(nextProps: P, nextState: S): void;
    protected focus(): void;
    focusFormattingBar(): void;
    setDisplayMode(newMode: DisplayMode): void;
    /**
     * Return the serialized instance of this control
     */
    serialize(): P;
    protected _createNewEditor(innerHTML: string, startupFocus?: boolean): Promise<IRichTextEditor>;
    protected _afterEditorCreated(editor: IRichTextEditor): void;
    protected _openLinkDialog(defaultAddress?: string): void;
    protected _closeLinkDialog(): void;
    protected _handleTextChange(): void;
    protected _finalizeAction(ariaActionName?: string): void;
    protected _onImagePaste(isImageValid: boolean, imageBlob?: Blob, innerHTML?: string): void;
    protected _onContextualMenu(isRightClicked: boolean, target: Element): void;
    protected _onPaste(isPasteInProgress: boolean): void;
    /**
      * Checks if a selection change should initiate, then:
      * - If the selection was marked for completion, completes it
      * - Otherwise, markes the selection as initiated to be completed later
      */
    protected _handleSelectionChange(range: IRange, forceUpdate?: boolean): void;
    protected _updateSelection(range: IRange, forceUpdate?: boolean): void;
    protected _restoreOnFocus(): boolean;
    protected _onBeforePaste(): void;
    protected _handleKeyDown(evt: KeyboardEvent): void;
    protected _handleLink(): void;
    protected _handleFormattingBarKeyDown(evt: KeyboardEvent): void;
    /**
     * Hide/Show the formatting bar and update the formatting bar position if needed.
     */
    protected _updateFormattingBar(isHidden: boolean): void;
    protected _engagementLoggerClickTagName(key: string): string;
    private _onSPRteLoad(e);
    private _ariaConfirmAction(formatKeyOrName);
    /**
     * Note: keyup and mouseup can happen before or after selection-change depending on the user input
     * That's why we need to mark these events in separate flags (_selectionInitiated and _selectionShouldEnd)
     * Whenever one of them happens, we check if the other one has happened so we could complete the action
     *
     * Checks if a selection change should complete, then:
     * - If the selection was already initiated, completes it
     * - Otherwise, markes the selection to be completed after initiation
     */
    private _checkSelectionChange();
    private _getFormatButtonProps(formatKey, onClick);
    private _handleCloseSubmenu(isDocumentClick);
    private readonly _formattingBarButtons;
    /**
     * @param format - Name of the format to apply
     */
    private _formatOrPrepare(formatKey);
    private _handleAlignCenter();
    private _handleAlignLeft();
    private _handleAlignRight();
    private _handleBold();
    private _handleHeading2();
    private _handleHeading3();
    private _handleHeading4();
    private _handleItalic();
    private _handleListBullets();
    private _handleListNumbered();
    private _handlePlainText();
    private _handleQuote();
    private _handleClearFormatting();
    private _handleUnderline();
    private _handleUnlink();
    /**
     * Clean up the existing formatting of given range before applying the new format, by doing:
     *  - Clear all styling formats if new format is also a styling format
     *  - Clear all the formats masked by the new format
     *
     * @param start - Start of the range getting formatted
     * @param end - End of the range getting formatted
     * @param newFormat - Name of new format being applied
     *
     * @return if the newFormat was cleared as a result of clean-up
     */
    private _cleanupBeforeFormatting(start, end, newFormat);
    private _onMessageBarDismiss();
    private _onContextualMenuDismiss();
    private _onLinkDialogSaved();
    private _handleEditorFocus(evt);
    private _handleFormattingBarBlur(evt);
    private _handleEditorBlur(evt);
    private _hideFormattingBarOnBlur(target);
    private _handleKeyUp(evt);
    private _setButtonStates();
    /**
     * This should be called whenever the activeness of buttons could have changed
     * It rerenders the component to make sure the change is rendered
     */
    private _updateActiveButtons();
}
