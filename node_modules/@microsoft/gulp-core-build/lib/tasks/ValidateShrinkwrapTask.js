"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var GulpTask_1 = require("./GulpTask");
var path = require("path");
var semver = require("semver");
/**
 * This task attempts to detect if package.json file has been updated without the
 * shrinkwrap file being regenerated.
 *
 * It does this by checking that every dependency and dev dependency exists in the
 * shrinkwrap file and that the version in the shrinkwrap file satisfies what is
 * defined in the package.json file.
 */
var ValidateShrinkwrapTask = (function (_super) {
    __extends(ValidateShrinkwrapTask, _super);
    /** Instantiates an instance of the ValidateShrinkwrap task */
    function ValidateShrinkwrapTask() {
        var _this = _super.call(this) || this;
        _this.name = 'validate-shrinkwrap';
        return _this;
    }
    /**
     * Iterates through dependencies listed in a project's package.json and ensures that they are all
     * resolvable in the npm-shrinkwrap file.
     */
    ValidateShrinkwrapTask.prototype.executeTask = function (gulp) {
        var pathToPackageJson = path.join(this.buildConfig.rootPath, 'package.json');
        var pathToShrinkwrap = path.join(this.buildConfig.rootPath, 'npm-shrinkwrap.json');
        if (!this.fileExists(pathToPackageJson)) {
            this.logError('Failed to find package.json at ' + pathToPackageJson);
            return;
        }
        else if (!this.fileExists(pathToShrinkwrap)) {
            this.logError('Failed to find package.json at ' + pathToShrinkwrap);
            return;
        }
        var packagejson = require(pathToPackageJson);
        var shrinkwrapjson = require(pathToShrinkwrap);
        this._validate(packagejson.dependencies, shrinkwrapjson.dependencies);
        this._validate(packagejson.devDependencies, shrinkwrapjson.dependencies);
        return;
    };
    ValidateShrinkwrapTask.prototype._validate = function (packageDep, shrinkwrapDep) {
        for (var pkg in packageDep) {
            if (!shrinkwrapDep.hasOwnProperty(pkg)) {
                this.logError("Failed to find package " + pkg + " in shrinkwrap file");
            }
            else if (!semver.satisfies(shrinkwrapDep[pkg].version, packageDep[pkg])) {
                this.logError("Shrinkwrap version for " + pkg + " (" + shrinkwrapDep[pkg].version + ") does not\n          satisfy package.json version of " + packageDep[pkg] + ".");
            }
        }
    };
    return ValidateShrinkwrapTask;
}(GulpTask_1.GulpTask));
exports.ValidateShrinkwrapTask = ValidateShrinkwrapTask;

//# sourceMappingURL=ValidateShrinkwrapTask.js.map
