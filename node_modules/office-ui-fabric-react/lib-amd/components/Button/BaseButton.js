var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(["require", "exports", "react", "../../Utilities"], function (require, exports, React, Utilities_1) {
    "use strict";
    var BaseButton = (function (_super) {
        __extends(BaseButton, _super);
        function BaseButton(props, rootClassName, deprecationMap) {
            var _this = _super.call(this, props, { 'rootProps': null }) || this;
            /**
             * _baseClassName can be overridden by subclasses to provide a unique class prefix to the class name used for
             * sub parts of the render template.
             */
            _this._baseClassName = 'ms-Button';
            /**
             * _variantClassName can be overridden by subclasses to add an extra default class name to the root element.
             */
            _this._variantClassName = '';
            _this._labelId = Utilities_1.getId();
            _this._descriptionId = Utilities_1.getId();
            _this._ariaDescriptionId = Utilities_1.getId();
            return _this;
        }
        BaseButton.prototype.render = function () {
            var _a = this.props, className = _a.className, description = _a.description, ariaLabel = _a.ariaLabel, ariaDescription = _a.ariaDescription, href = _a.href, disabled = _a.disabled;
            var _b = this, _ariaDescriptionId = _b._ariaDescriptionId, _labelId = _b._labelId, _descriptionId = _b._descriptionId;
            var renderAsAnchor = !!href;
            var tag = renderAsAnchor ? 'a' : 'button';
            var nativeProps = Utilities_1.getNativeProps(Utilities_1.assign({}, this.props.rootProps, this.props), renderAsAnchor ? Utilities_1.anchorProperties : Utilities_1.buttonProperties, [
                'disabled' // Let disabled buttons be focused and styled as disabled.
            ]);
            // Check for ariaDescription, description or aria-describedby in the native props to determine source of aria-describedby
            // otherwise default to null.
            var ariaDescribedBy;
            if (ariaDescription) {
                ariaDescribedBy = _ariaDescriptionId;
            }
            else if (description) {
                ariaDescribedBy = _descriptionId;
            }
            else if (nativeProps['aria-describedby']) {
                ariaDescribedBy = nativeProps['aria-describedby'];
            }
            else {
                ariaDescribedBy = null;
            }
            var buttonProps = Utilities_1.assign(nativeProps, {
                className: Utilities_1.css(className, this._baseClassName, this._variantClassName, { 'disabled': disabled }),
                ref: this._resolveRef('_buttonElement'),
                'aria-label': ariaLabel,
                'aria-labelledby': ariaLabel ? null : _labelId,
                'aria-describedby': ariaDescribedBy
            });
            return this.onRenderContent(tag, buttonProps);
        };
        BaseButton.prototype.focus = function () {
            if (this._buttonElement) {
                this._buttonElement.focus();
            }
        };
        BaseButton.prototype.onRenderContent = function (tag, buttonProps) {
            return React.createElement(tag, buttonProps, this.onRenderIcon(), this.onRenderLabel(), this.onRenderDescription(), this.onRenderAriaDescription(), this.onRenderChildren());
        };
        BaseButton.prototype.onRenderIcon = function () {
            var icon = this.props.icon;
            return icon ? (React.createElement("span", { className: this._baseClassName + "-icon" },
                React.createElement("i", { className: "ms-Icon ms-Icon--" + icon }))) : (null);
        };
        BaseButton.prototype.onRenderLabel = function () {
            var _a = this.props, children = _a.children, label = _a.label;
            // For backwards compat, we should continue to take in the label content from children.
            if (label === undefined && typeof (children) === 'string') {
                label = children;
            }
            return label ? (React.createElement("span", { className: this._baseClassName + "-label", id: this._labelId }, label)) : (null);
        };
        BaseButton.prototype.onRenderChildren = function () {
            var _a = this.props, children = _a.children, label = _a.label;
            // There is no label and the label will be rendered, we don't want the label to appear twice.
            // If there is a label and the children are of type string it was likely intentional and both
            // should render.
            if (label === undefined && typeof (children) === 'string') {
                return null;
            }
            return children;
        };
        BaseButton.prototype.onRenderDescription = function () {
            var description = this.props.description;
            // ms-Button-description is only shown when the button type is compound.
            // In other cases it will not be displayed.
            return description ? (React.createElement("span", { className: this._baseClassName + "-description", id: this._descriptionId }, description)) : (null);
        };
        BaseButton.prototype.onRenderAriaDescription = function () {
            var ariaDescription = this.props.ariaDescription;
            // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
            // otherwise it will be assigned to descriptionSpan.
            return ariaDescription ? (React.createElement("span", { className: 'ms-u-screenReaderOnly', id: this._ariaDescriptionId }, ariaDescription)) : (null);
        };
        return BaseButton;
    }(Utilities_1.BaseComponent));
    exports.BaseButton = BaseButton;
});

//# sourceMappingURL=BaseButton.js.map
