{"version":3,"sources":["DocElementParser.ts"],"names":[],"mappings":"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","file":"DocElementParser.js","sourcesContent":["import { ITextElement, IDocElement, IHrefLinkElement, ICodeLinkElement, ISeeDocElement } from './IDocElement';\r\nimport ApiDefinitionReference from './ApiDefinitionReference';\r\nimport ApiDocumentation from './definitions/ApiDocumentation';\r\nimport { ApiItemKind } from './definitions/ApiItem';\r\nimport Token, { TokenType } from './Token';\r\nimport Tokenizer from './Tokenizer';\r\nimport ResolvedApiItem from './ResolvedApiItem';\r\n\r\nexport default class DocElementParser {\r\n\r\n  /**\r\n   * Matches only strings that contain characters for words.\r\n   * Any non word characters or spaces, will be present in the third entry in the match results\r\n   * if they exist.\r\n   */\r\n  private static _wordRegEx: RegExp = /^([\\w\\s]*)/;\r\n\r\n  /**\r\n   * Matches a href reference. This is used to get an idea whether a given reference is for an href\r\n   * or an API definition reference.\r\n   *\r\n   * For example, the following would be matched:\r\n   * 'http://'\r\n   * 'https://'\r\n   *\r\n   * The following would not be matched:\r\n   * '@microsoft/sp-core-library:Guid.newGuid'\r\n   * 'Guid.newGuid'\r\n   * 'Guid'\r\n   */\r\n  private static _hrefRegEx: RegExp = /^[a-z]+:\\/\\//;\r\n\r\n  public static getAsText(collection: IDocElement[], reportError: (message: string) => void): string {\r\n    let text: string = '';\r\n\r\n    collection.forEach(docElement => {\r\n      switch (docElement.kind) {\r\n        case 'textDocElement':\r\n          text += `${(docElement as ITextElement).value} `;\r\n          break;\r\n        case 'linkDocElement':\r\n          // links don't count towards the summary\r\n          break;\r\n        case 'seeDocElement':\r\n          // see doesn't count towards the summary\r\n          break;\r\n        default:\r\n          reportError('Unexpected item in IDocElement collection');\r\n          break;\r\n      }\r\n    });\r\n\r\n    return text.trim();\r\n  }\r\n\r\n  public static makeTextElement(text: string): IDocElement {\r\n    if (!text) {\r\n      return;\r\n    }\r\n    return {kind: 'textDocElement', value: text} as ITextElement;\r\n  }\r\n\r\n  public static parse(documentation: ApiDocumentation, tokenizer: Tokenizer): IDocElement[] {\r\n    const docElements: IDocElement[] = [];\r\n    let parsing: boolean = true;\r\n    let token: Token;\r\n\r\n    while (parsing) {\r\n      token = tokenizer.peekToken();\r\n      if (!token) {\r\n        parsing = false; // end of stream\r\n        break;\r\n      }\r\n\r\n      if (token.type === TokenType.Tag) {\r\n        switch (token.tag) {\r\n          case '@see':\r\n            tokenizer.getToken();\r\n            docElements.push({\r\n              kind: 'seeDocElement',\r\n              seeElements: this.parse(documentation, tokenizer)\r\n            } as ISeeDocElement);\r\n            break;\r\n          default:\r\n            parsing = false; // end of summary tokens\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.Inline) {\r\n        switch (token.tag) {\r\n          case '@inheritdoc':\r\n            tokenizer.getToken();\r\n            if (docElements.length > 0 ||  documentation.summary.length > 0) {\r\n              documentation.reportError('Cannot provide summary in JsDoc if @inheritdoc tag is given');\r\n            }\r\n            documentation.incompleteInheritdocs.push(token);\r\n            documentation.isDocInherited = true;\r\n            break;\r\n          case '@link' :\r\n            const linkDocElement: ICodeLinkElement | IHrefLinkElement = this.parseLinkTag(documentation, token);\r\n            if (linkDocElement) {\r\n              // Push to docElements to retain position in the documentation\r\n              docElements.push(linkDocElement);\r\n              if (linkDocElement.referenceType === 'code') {\r\n                documentation.incompleteLinks.push(linkDocElement);\r\n              }\r\n            }\r\n            tokenizer.getToken(); // get the link token\r\n            break;\r\n          default:\r\n            parsing = false;\r\n            break;\r\n        }\r\n      } else if (token.type === TokenType.Text) {\r\n        docElements.push({kind: 'textDocElement', value: token.text} as ITextElement);\r\n          tokenizer.getToken();\r\n      } else {\r\n        documentation.reportError(`Unidentifiable Token ${token.type} ${token.tag} ${token.text}`);\r\n      }\r\n    }\r\n    return docElements;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@link JSDoc tag, creates and returns a\r\n   * linkDocElement with the corresponding information. If the corresponding inline tag \\@link is\r\n   * not formatted correctly an error will be reported.\r\n   *\r\n   * The format for the \\@link tag is {\\@link url or API defintion reference | display text}, where\r\n   * the '|' is only needed if the optional display text is given.\r\n   *\r\n   * Examples:\r\n   * \\{@link http://microsoft.com | microsoft home \\}\r\n   * \\{@link http://microsoft.com \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid | new Guid Object \\}\r\n   * \\{@link @microsoft/sp-core-library:Guid.newGuid \\}\r\n   */\r\n  public static parseLinkTag(documentation: ApiDocumentation, tokenItem: Token): IHrefLinkElement | ICodeLinkElement {\r\n    if (!tokenItem.text) {\r\n      documentation.reportError('Invalid @link inline token, a url or API definition reference must be given');\r\n       return;\r\n    }\r\n\r\n    // Make sure there are no extra pipes\r\n    let pipeSplitContent: string[] = tokenItem.text.split('|');\r\n    pipeSplitContent = pipeSplitContent.map( value => {\r\n      if (value) {\r\n        return value.trim();\r\n      }\r\n    });\r\n    if (pipeSplitContent.length > 2) {\r\n      documentation.reportError('Invalid @link parameters, at most one pipe character allowed.');\r\n      return;\r\n    }\r\n\r\n    // Try to guess if the tokenContent is a link or API definition reference\r\n    let linkDocElement: ICodeLinkElement | IHrefLinkElement;\r\n    if (tokenItem.text.match(this._hrefRegEx)) {\r\n      const urlContent: string[] = pipeSplitContent[0].split(' ');\r\n\r\n      // Make sure only a single url is given\r\n      if (urlContent.length > 1 && urlContent[1] !== '' ) {\r\n        documentation.reportError('Invalid @link parameter, url must be a single string.');\r\n        return;\r\n      }\r\n\r\n      linkDocElement = {\r\n        kind: 'linkDocElement',\r\n        referenceType: 'href',\r\n        targetUrl: urlContent[0],\r\n        value: ''\r\n      };\r\n\r\n    } else {\r\n      // we are processing an API definition reference\r\n      const apiDefitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n        pipeSplitContent[0],\r\n        documentation.reportError\r\n      );\r\n\r\n      // Once we can locate local API definitions, an error should be reported here if not found.\r\n      if (apiDefitionRef) {\r\n\r\n        linkDocElement = {\r\n          kind: 'linkDocElement',\r\n          referenceType: 'code',\r\n          scopeName: apiDefitionRef.scopeName,\r\n          packageName: apiDefitionRef.packageName,\r\n          exportName: apiDefitionRef.exportName,\r\n          memberName: apiDefitionRef.memberName\r\n        };\r\n      }\r\n    }\r\n\r\n    // If a display name is given, ensure it only contains characters for words.\r\n    if (linkDocElement && pipeSplitContent.length > 1) {\r\n      const displayTextParts: string[] = pipeSplitContent[1].match(this._wordRegEx);\r\n      if (displayTextParts && displayTextParts[0].length !== pipeSplitContent[1].length) {\r\n        documentation.reportError('Display name in @link token may only contain alphabetic characters.');\r\n        return;\r\n      }\r\n      // Full match is valid text\r\n      linkDocElement.value = displayTextParts[0].trim();\r\n    }\r\n\r\n    return linkDocElement;\r\n  }\r\n\r\n  /**\r\n   * This method parses the semantic information in an \\@inheritdoc JSDoc tag and sets\r\n   * all the relevant documenation properties from the inherited doc onto the documenation\r\n   * of the current api item.\r\n   *\r\n   * The format for the \\@inheritdoc tag is {\\@inheritdoc scopeName/packageName:exportName.memberName}.\r\n   * For more information on the format see IInheritdocRef.\r\n   */\r\n  public static parseInheritDoc(documentation: ApiDocumentation, token: Token): void {\r\n\r\n    // Check to make sure the API definition reference is at most one string\r\n    const tokenChunks: string[] = token.text.split(' ');\r\n    if (tokenChunks.length > 1) {\r\n      documentation.reportError('Too many parameters for @inheritdoc inline tag.' +\r\n        'The format should be {@inheritdoc scopeName/packageName:exportName}. Extra parameters are ignored');\r\n      return;\r\n    }\r\n\r\n    // Create the IApiDefinitionReference object\r\n    // Deconstruct the API reference expression 'scopeName/packageName:exportName.memberName'\r\n    const apiDefinitionRef: ApiDefinitionReference = ApiDefinitionReference.createFromString(\r\n      token.text,\r\n      documentation.reportError\r\n    );\r\n    // if API reference expression is formatted incorrectly then apiDefinitionRef will be undefined\r\n    if (!apiDefinitionRef) {\r\n      documentation.reportError('Incorrecty formatted API definition reference');\r\n      return;\r\n    }\r\n\r\n    // Atempt to locate the apiDefinitionRef\r\n    const resolvedApiItem: ResolvedApiItem = documentation.referenceResolver.resolve(\r\n      apiDefinitionRef,\r\n      documentation.extractor.package,\r\n      documentation.reportError\r\n    );\r\n\r\n    // If no resolvedApiItem found then nothing to inherit\r\n    // But for the time being set the summary to a text object\r\n    if (!resolvedApiItem) {\r\n      const textDocItem: IDocElement = {\r\n        kind: 'textDocElement',\r\n        value: `See documentation for ${tokenChunks[0]}`\r\n      } as ITextElement;\r\n      documentation.summary = [textDocItem];\r\n      return;\r\n    }\r\n\r\n    // We are going to copy the resolvedApiItem's documentation \r\n    // We must make sure it's documentation can be completed,\r\n    // if we cannot, an error will be reported viathe documentation error handler. \r\n    // This will only be the case our resolvedApiItem was created from a local \r\n    // ApiItem. Resolutions from JSON will have an undefined 'apiItem' property.\r\n    // Example: a circular reference will report an error. \r\n    if (resolvedApiItem.apiItem) {\r\n      resolvedApiItem.apiItem.completeInitialization();\r\n    }\r\n\r\n    // inheritdoc found, copy over IDocBase properties\r\n    documentation.summary =  resolvedApiItem.summary;\r\n    documentation.remarks = resolvedApiItem.remarks;\r\n\r\n    // Copy over detailed properties if neccessary\r\n    // Add additional cases if needed\r\n    switch (resolvedApiItem.kind) {\r\n      case ApiItemKind.Function:\r\n        documentation.parameters = resolvedApiItem.params;\r\n        documentation.returnsMessage = resolvedApiItem.returnsMessage;\r\n        break;\r\n      case ApiItemKind.Method:\r\n        documentation.parameters = resolvedApiItem.params;\r\n        documentation.returnsMessage = resolvedApiItem.returnsMessage;\r\n        break;\r\n    }\r\n\r\n    // Check if inheritdoc is depreacted\r\n    // We need to check if this documentation has a deprecated message\r\n    // but it may not appear until after this token.\r\n    if (resolvedApiItem.deprecatedMessage) {\r\n      documentation.isDocInheritedDeprecated = true;\r\n    }\r\n  }\r\n}"],"sourceRoot":"..\\src"}