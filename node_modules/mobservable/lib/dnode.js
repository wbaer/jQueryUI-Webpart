var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
if (global.__mobservableTrackingStack)
    throw new Error("[mobservable] An incompatible version of mobservable is already loaded.");
global.__mobservableViewStack = [];
var inTransaction = 0;
var changedValues = [];
var afterTransactionItems = [];
var mobservableId = 0;
function checkIfStateIsBeingModifiedDuringView(context) {
    if (core_1.getStrict() === true && isComputingView()) {
        var ts = global.__mobservableViewStack;
        throw new Error("[mobservable] It is not allowed to change the state during the computation of a reactive view. Should the data you are trying to modify actually be a view? \nUse 'mobservable.extras.withStrict(false, block)' to allow changes to be made inside views (unrecommended).\nView name: " + context.name + ".\nCurrent stack size is " + ts.length + ", active view: \"" + ts[ts.length - 1].toString() + "\".");
    }
}
exports.checkIfStateIsBeingModifiedDuringView = checkIfStateIsBeingModifiedDuringView;
function transaction(action, thisArg) {
    inTransaction += 1;
    try {
        return action.call(thisArg);
    }
    finally {
        if (--inTransaction === 0) {
            var values = changedValues.splice(0);
            for (var i = 0, l = values.length; i < l; i++)
                values[i].markReady(true);
            var actions = afterTransactionItems.splice(0);
            for (var i = 0, l = actions.length; i < l; i++)
                actions[i]();
        }
    }
}
exports.transaction = transaction;
function runAfterTransaction(action) {
    if (inTransaction === 0)
        action();
    else
        afterTransactionItems.push(action);
}
exports.runAfterTransaction = runAfterTransaction;
function isInTransaction() {
    return inTransaction > 0;
}
exports.isInTransaction = isInTransaction;
function untracked(action) {
    try {
        var dnode = new ViewNode({ object: null, name: "untracked" });
        global.__mobservableViewStack.push(dnode);
        return action();
    }
    finally {
        global.__mobservableViewStack.pop();
    }
}
exports.untracked = untracked;
(function (NodeState) {
    NodeState[NodeState["STALE"] = 0] = "STALE";
    NodeState[NodeState["PENDING"] = 1] = "PENDING";
    NodeState[NodeState["READY"] = 2] = "READY";
})(exports.NodeState || (exports.NodeState = {}));
var NodeState = exports.NodeState;
;
var DataNode = (function () {
    function DataNode(context) {
        this.id = ++mobservableId;
        this.state = NodeState.READY;
        this.observers = [];
        this.isDisposed = false;
        this.externalRefenceCount = 0;
        if (!context)
            context = { name: undefined, object: undefined };
        if (!context.name)
            context.name = "[m#" + this.id + "]";
        this.context = context;
    }
    DataNode.prototype.setRefCount = function (delta) {
        this.externalRefenceCount += delta;
    };
    DataNode.prototype.addObserver = function (node) {
        this.observers[this.observers.length] = node;
    };
    DataNode.prototype.removeObserver = function (node) {
        var obs = this.observers, idx = obs.indexOf(node);
        if (idx !== -1)
            obs.splice(idx, 1);
    };
    DataNode.prototype.markStale = function () {
        this.state = NodeState.STALE;
        if (extras_1.transitionTracker)
            extras_1.reportTransition(this, "STALE");
        this.notifyObservers();
    };
    DataNode.prototype.markReady = function (stateDidActuallyChange) {
        if (inTransaction > 0) {
            changedValues.push(this);
            return;
        }
        this.state = NodeState.READY;
        if (extras_1.transitionTracker)
            extras_1.reportTransition(this, "READY", true, this["_value"]);
        this.notifyObservers(stateDidActuallyChange);
    };
    DataNode.prototype.notifyObservers = function (stateDidActuallyChange) {
        if (stateDidActuallyChange === void 0) { stateDidActuallyChange = false; }
        var os = this.observers.slice();
        for (var l = os.length, i = 0; i < l; i++)
            os[i].notifyStateChange(this, stateDidActuallyChange);
    };
    DataNode.prototype.notifyObserved = function () {
        var ts = global.__mobservableViewStack, l = ts.length;
        if (l > 0) {
            var deps = ts[l - 1].observing, depslength = deps.length;
            if (deps[depslength - 1] !== this && deps[depslength - 2] !== this)
                deps[depslength] = this;
        }
    };
    DataNode.prototype.dispose = function () {
        if (this.observers.length)
            throw new Error("[mobservable] Cannot dispose DNode; it is still being observed");
        this.isDisposed = true;
    };
    DataNode.prototype.toString = function () {
        return "DNode[" + this.context.name + ", state: " + this.state + ", observers: " + this.observers.length + "]";
    };
    return DataNode;
})();
exports.DataNode = DataNode;
var ViewNode = (function (_super) {
    __extends(ViewNode, _super);
    function ViewNode() {
        _super.apply(this, arguments);
        this.isSleeping = true;
        this.hasCycle = false;
        this.observing = [];
        this.prevObserving = null;
        this.dependencyChangeCount = 0;
        this.dependencyStaleCount = 0;
        this.onSleepEmitter = null;
    }
    ViewNode.prototype.setRefCount = function (delta) {
        var rc = this.externalRefenceCount += delta;
        if (rc === 0)
            this.tryToSleep();
        else if (rc === delta)
            this.wakeUp();
    };
    ViewNode.prototype.removeObserver = function (node) {
        _super.prototype.removeObserver.call(this, node);
        this.tryToSleep();
    };
    ViewNode.prototype.tryToSleep = function () {
        if (!this.isSleeping && this.observers.length === 0 && this.externalRefenceCount === 0) {
            for (var i = 0, l = this.observing.length; i < l; i++)
                this.observing[i].removeObserver(this);
            this.observing = [];
            this.isSleeping = true;
            if (this.onSleepEmitter !== null)
                this.onSleepEmitter.emit(this._value);
        }
    };
    ViewNode.prototype.wakeUp = function () {
        if (this.isSleeping) {
            this.isSleeping = false;
            this.state = NodeState.PENDING;
            this.computeNextState();
        }
    };
    ViewNode.prototype.notifyStateChange = function (observable, stateDidActuallyChange) {
        if (observable.state === NodeState.STALE) {
            if (++this.dependencyStaleCount === 1)
                this.markStale();
        }
        else {
            if (stateDidActuallyChange)
                this.dependencyChangeCount += 1;
            if (this.dependencyStaleCount > 0 && --this.dependencyStaleCount === 0) {
                this.state = NodeState.PENDING;
                if (this.dependencyChangeCount > 0)
                    this.computeNextState();
                else
                    this.markReady(false);
                this.dependencyChangeCount = 0;
            }
        }
    };
    ViewNode.prototype.computeNextState = function () {
        var _this = this;
        this.trackDependencies();
        if (extras_1.transitionTracker)
            extras_1.reportTransition(this, "PENDING");
        var hasError = true;
        try {
            var stateDidChange;
            core_1.withStrict(this.externalRefenceCount === 0, function () {
                stateDidChange = _this.compute();
            });
            hasError = false;
        }
        finally {
            if (hasError)
                console.error("[mobservable.view '" + this.context.name + "'] There was an uncaught error during the computation of " + this.toString());
            this.isComputing = false;
            this.bindDependencies();
            this.markReady(stateDidChange);
        }
    };
    ViewNode.prototype.compute = function () {
        throw "Abstract!";
    };
    ViewNode.prototype.trackDependencies = function () {
        this.prevObserving = this.observing;
        this.observing = [];
        global.__mobservableViewStack[global.__mobservableViewStack.length] = this;
    };
    ViewNode.prototype.bindDependencies = function () {
        global.__mobservableViewStack.length -= 1;
        var _a = utils_1.quickDiff(this.observing, this.prevObserving), added = _a[0], removed = _a[1];
        this.prevObserving = null;
        this.hasCycle = false;
        for (var i = 0, l = added.length; i < l; i++) {
            var dependency = added[i];
            if (dependency instanceof ViewNode && dependency.findCycle(this)) {
                this.hasCycle = true;
                this.observing.splice(this.observing.indexOf(added[i]), 1);
                dependency.hasCycle = true;
            }
            else {
                added[i].addObserver(this);
            }
        }
        for (var i = 0, l = removed.length; i < l; i++)
            removed[i].removeObserver(this);
    };
    ViewNode.prototype.findCycle = function (node) {
        var obs = this.observing;
        if (obs.indexOf(node) !== -1)
            return true;
        for (var l = obs.length, i = 0; i < l; i++)
            if (obs[i] instanceof ViewNode && obs[i].findCycle(node))
                return true;
        return false;
    };
    ViewNode.prototype.onceSleep = function (onSleep) {
        if (this.onSleepEmitter === null)
            this.onSleepEmitter = new simpleeventemitter_1.default();
        this.onSleepEmitter.once(onSleep);
    };
    ViewNode.prototype.dispose = function () {
        if (this.observing)
            for (var l = this.observing.length, i = 0; i < l; i++)
                this.observing[i].removeObserver(this);
        this.observing = null;
        _super.prototype.dispose.call(this);
    };
    return ViewNode;
})(DataNode);
exports.ViewNode = ViewNode;
function stackDepth() {
    return global.__mobservableViewStack.length;
}
exports.stackDepth = stackDepth;
function isComputingView() {
    return global.__mobservableViewStack.length > 0;
}
exports.isComputingView = isComputingView;
var core_1 = require('./core');
var extras_1 = require('./extras');
var utils_1 = require('./utils');
var simpleeventemitter_1 = require('./simpleeventemitter');
