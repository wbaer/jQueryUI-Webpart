"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var os_1 = require("os");
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
var through2 = require("through2");
var path = require("path");
/* tslint:disable:typedef */
var merge = require('merge2');
/* tslint:enable:typedef */
var scssTsExtName = '.scss.ts';
var _classMaps = {};
var SassTask = (function (_super) {
    __extends(SassTask, _super);
    function SassTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'sass';
        _this.taskConfig = {
            preamble: '/* tslint:disable */',
            postamble: '/* tslint:enable */',
            sassMatch: [
                'src/**/*.scss'
            ],
            useCSSModules: false,
            dropCssFiles: false,
            warnOnNonCSSModules: false
        };
        _this.cleanMatch = [
            'src/**/*.scss.ts'
        ];
        return _this;
    }
    SassTask.prototype.loadSchema = function () {
        return require('./sass.schema.json');
    };
    SassTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        /* tslint:disable:typedef */
        var autoprefixer = require('autoprefixer');
        var cssModules = require('postcss-modules');
        /* tslint:enable:typedef */
        /* tslint:disable:no-any */
        var postCSSPlugins = [
            autoprefixer({ browsers: ['> 1%', 'last 2 versions', 'ie >= 10'] })
        ];
        var modulePostCssPlugins = postCSSPlugins.slice(0);
        /* tslint:enable:no-any */
        modulePostCssPlugins.push(cssModules({
            getJSON: this._generateModuleStub.bind(this),
            generateScopedName: this.generateScopedName.bind(this)
        }));
        var srcPattern = this.taskConfig.sassMatch.slice(0);
        var checkFilenameForCSSModule = function (file) {
            if (!path.basename(file.path).match(/module\.scss$/)) {
                var filepath = path.relative(_this.buildConfig.rootPath, file.path);
                _this.logWarning(filepath + ": filename should end with module.scss");
            }
        };
        if (this.taskConfig.useCSSModules) {
            this.logVerbose('Generating css modules.');
            return this._processFiles(gulp, srcPattern, completeCallback, modulePostCssPlugins);
        }
        else {
            var moduleSrcPattern = srcPattern.map(function (value) { return value.replace('.scss', '.module.scss'); });
            moduleSrcPattern.forEach(function (value) { return srcPattern.push("!" + value); });
            return merge(this._processFiles(gulp, srcPattern, completeCallback, postCSSPlugins, this.taskConfig.warnOnNonCSSModules ? checkFilenameForCSSModule : undefined), this._processFiles(gulp, moduleSrcPattern, completeCallback, modulePostCssPlugins));
        }
    };
    SassTask.prototype._processFiles = function (gulp, srcPattern, 
        /* tslint:disable:no-any */
        completeCallback, postCSSPlugins, 
        /* tslint:enable:no-any */
        checkFile) {
        var _this = this;
        /* tslint:disable:typedef */
        var changed = require('gulp-changed');
        var cleancss = require('gulp-clean-css');
        var clipEmptyFiles = require('gulp-clip-empty-files');
        var clone = require('gulp-clone');
        var path = require('path');
        var postcss = require('gulp-postcss');
        var sass = require('gulp-sass');
        var texttojs = require('gulp-texttojs');
        /* tslint:enable:typedef */
        var tasks = [];
        var srcStream = gulp.src(srcPattern);
        var checkedStream = (checkFile ?
            srcStream.pipe(through2.obj(
            // tslint:disable-next-line:no-function-expression
            function (file, encoding, callback) {
                // tslint:disable-next-line:no-unused-expression
                checkFile(file);
                this.push(file);
                callback();
            }))
            : srcStream);
        var baseTask = checkedStream
            .pipe(changed('src', { extension: scssTsExtName }))
            .pipe(sass.sync({
            importer: function (url, prev, done) { return ({ file: _patchSassUrl(url) }); }
        }).on('error', function (error) {
            sass.logError.call(this, error);
            completeCallback('Errors found in sass file(s).');
        }))
            .pipe(postcss(postCSSPlugins))
            .pipe(cleancss({
            advanced: false
        }))
            .pipe(clipEmptyFiles());
        if (this.taskConfig.dropCssFiles) {
            tasks.push(baseTask.pipe(clone())
                .pipe(gulp.dest(this.buildConfig.libFolder)));
        }
        tasks.push(baseTask.pipe(clone())
            .pipe(texttojs({
            ext: scssTsExtName,
            isExtensionAppended: false,
            template: function (file) {
                var content = file.contents.toString();
                var classNames = _classMaps[file.path];
                var exportClassNames = '';
                if (classNames) {
                    var classNamesLines_1 = [
                        'const styles = {'
                    ];
                    var classKeys_1 = Object.keys(classNames);
                    classKeys_1.forEach(function (key, index) {
                        var value = classNames[key];
                        var line = '';
                        if (key.indexOf('-') !== -1) {
                            _this.logWarning("The local CSS class '" + key + "' is not camelCase and will not be type-safe.");
                            line = "  '" + key + "': '" + value + "'";
                        }
                        else {
                            line = "  " + key + ": '" + value + "'";
                        }
                        if ((index + 1) <= classKeys_1.length) {
                            line += ',';
                        }
                        classNamesLines_1.push(line);
                    });
                    classNamesLines_1.push('};', '', 'export default styles;');
                    exportClassNames = classNamesLines_1.join(os_1.EOL);
                }
                var lines = [];
                lines.push(_this.taskConfig.preamble || '');
                if (_this.taskConfig.dropCssFiles) {
                    lines = lines.concat([
                        "require('./" + path.basename(file.path, scssTsExtName) + ".css');",
                        exportClassNames
                    ]);
                }
                else if (!!content) {
                    lines = lines.concat([
                        'import { loadStyles } from \'@microsoft/load-themed-styles\';',
                        '',
                        exportClassNames,
                        '',
                        "loadStyles(" + JSON.stringify(load_themed_styles_1.splitStyles(content)) + ");"
                    ]);
                }
                lines.push(_this.taskConfig.postamble || '');
                return (lines
                    .join(os_1.EOL)
                    .replace(new RegExp("(" + os_1.EOL + "){3,}", 'g'), "" + os_1.EOL + os_1.EOL)
                    .replace(new RegExp("(" + os_1.EOL + ")+$", 'm'), os_1.EOL));
            }
        }))
            .pipe(gulp.dest('src')));
        return merge(tasks);
    };
    SassTask.prototype._generateModuleStub = function (cssFileName, json) {
        cssFileName = cssFileName.replace('.css', '.scss.ts');
        _classMaps[cssFileName] = json;
    };
    SassTask.prototype.generateScopedName = function (name, fileName, css) {
        /* tslint:disable:typedef */
        var crypto = require('crypto');
        /* tslint:enable:typedef */
        return name + '_' + crypto.createHmac('sha1', fileName).update(css).digest('hex').substring(0, 8);
    };
    return SassTask;
}(gulp_core_build_1.GulpTask));
exports.SassTask = SassTask;
function _patchSassUrl(url) {
    if (url[0] === '~') {
        url = 'node_modules/' + url.substr(1);
    }
    else if (url === 'stdin') {
        url = '';
    }
    return url;
}

//# sourceMappingURL=SassTask.js.map
