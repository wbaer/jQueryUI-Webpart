/// <reference types="es6-collections" />
/// <reference types="node" />
import * as child_process from 'child_process';
export default class Utilities {
    /**
     * For a scoped NPM package name this separates the scope and name parts.  For example:
     * parseScopedPackageName('@my-scope/myproject') = { scope: '@my-scope', name: 'myproject' }
     * parseScopedPackageName('myproject') = { scope: '', name: 'myproject' }
     */
    static parseScopedPackageName(scopedName: string): {
        scope: string;
        name: string;
    };
    /**
     * NodeJS equivalent of performance.now().
     */
    static getTimeInMs(): number;
    /**
     * Returns the values from a Set<T>
     */
    static getSetAsArray<T>(set: Set<T>): T[];
    /**
     * Retries a function until a timeout is reached. The function is expected to throw if it failed and
     *  should be retried.
     */
    static retryUntilTimeout<TResult>(fn: () => TResult, maxWaitTimeMs: number, getTimeoutError: (innerError: Error) => Error, fnName: string): TResult;
    static createFolderWithRetry(folderName: string): void;
    /**
     * Determines if the path points to a file and that it exists.
     */
    static fileExists(path: string): boolean;
    /**
     * Determines if a path points to a directory and that it exists.
     */
    static directoryExists(path: string): boolean;
    /**
     * BE VERY CAREFUL CALLING THIS FUNCTION!
     * If you specify the wrong folderPath (e.g. "/"), it could potentially delete your entire
     * hard disk.
     */
    static dangerouslyDeletePath(folderPath: string): void;
    /**
     * Attempts to delete a file. If it does not exist, or the path is not a file, it no-ops.
     */
    static deleteFile(filePath: string): void;
    static isFileTimestampCurrent(outputFilename: string, inputFilenames: string[]): boolean;
    /**
     * Returns the width of the console, measured in columns
     */
    static getConsoleWidth(): number;
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommand(command: string, args: string[], workingDirectory: string, suppressOutput?: boolean, environmentVariables?: {
        [key: string]: string;
    }): void;
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAndCaptureOutput(command: string, args: string[], workingDirectory: string, environmentVariables?: {
        [key: string]: string;
    }): string;
    /**
     * Attempts to run Utilities.executeCommand() up to maxAttempts times before giving up.
     */
    static executeCommandWithRetry(command: string, args: string[], maxAttempts: number, workingDirectory: string, suppressOutput?: boolean): void;
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    static executeCommandAsync(command: string, args: string[], workingDirectory: string, environmentVariables?: {
        [key: string]: string;
    }): child_process.ChildProcess;
    /**
     * Returns the same thing as targetString.replace(searchValue, replaceValue), except that
     * all matches are replaced, rather than just the first match.
     * @param targetString  The string to be modified
     * @param searchValue   The value to search for
     * @param replaceValue  The replacement text
     */
    static getAllReplaced(targetString: string, searchValue: string, replaceValue: string): string;
    /**
     * Executes the command with the specified command-line parameters, and waits for it to complete.
     * The current directory will be set to the specified workingDirectory.
     */
    private static _executeCommandInternal(command, args, workingDirectory, stdio, environmentVariables);
}
