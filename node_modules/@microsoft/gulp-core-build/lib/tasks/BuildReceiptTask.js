"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var GulpTask_1 = require("./GulpTask");
var fs = require("fs");
var path = require("path");
var child_process = require("child_process");
var PROCESS_OUTPUT_DELIMITER = '///~X~X~X~X~X~X~///';
var _lastLocalHashes = {};
/**
 * This task is responsible for generating a build receipt, which is a hash of filePath to sha1 git hash,
 * based on the current folder's content. If a {buildConfig.packagePath}/build.json file exists, it will
 * parse it and object compare the computed build receipt with the contents. If everything is the same, it
 * will set buildConfig.isRedundantBuild flag to true, which can be used in task isEnabled methods to skip
 * unnecessary work.
 *
 * The utility function "_getLocalHashes" will use the git.exe process to get the hashes from the git
 * cache. It also asks for git status, which will tell us what has been changed since. It uses this info
 * to build the hash.
 *
 * The utility funciton "_readPackageHashes" will read the local build.json file from the packagePath
 * folder.
 */
var CheckBuildReceiptTask = (function (_super) {
    __extends(CheckBuildReceiptTask, _super);
    function CheckBuildReceiptTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'check-for-changes';
        return _this;
    }
    CheckBuildReceiptTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        _getLocalHashes().then(function (localHashes) {
            _lastLocalHashes = localHashes;
            _readPackageHashes(path.join(process.cwd(), _this.buildConfig.packageFolder, 'build.json')).then(function (packageHashes) {
                if (packageHashes) {
                    if (_areObjectsEqual(localHashes, packageHashes)) {
                        _this.buildConfig.isRedundantBuild = true;
                        _this.log('Build is redundant. Skipping steps.');
                    }
                    else {
                        _areObjectsEqual(localHashes, packageHashes);
                        _this.log('Build has new content, continuing execution.');
                    }
                }
                completeCallback();
            });
        });
    };
    return CheckBuildReceiptTask;
}(GulpTask_1.GulpTask));
exports.CheckBuildReceiptTask = CheckBuildReceiptTask;
/**
 * This task writes _lastFilesHash, generated from the CheckBuildReceipt task, to the package path in the
 * build.json file. It should only be executed in a task which runs the CheckBuildReceipt subtask first, and
 * should only be run at the end of the task when everything has successfully completed.
 */
var UpdateBuildReceiptTask = (function (_super) {
    __extends(UpdateBuildReceiptTask, _super);
    function UpdateBuildReceiptTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'mark-changes';
        return _this;
    }
    UpdateBuildReceiptTask.prototype.executeTask = function (gulp, completeCallback) {
        var packageHashPath = path.join(process.cwd(), this.buildConfig.packageFolder, 'build.json');
        fs.writeFile(packageHashPath, JSON.stringify(_lastLocalHashes, undefined, 2), completeCallback);
    };
    return UpdateBuildReceiptTask;
}(GulpTask_1.GulpTask));
exports.UpdateBuildReceiptTask = UpdateBuildReceiptTask;
function _getLocalHashes() {
    return new Promise(function (complete) {
        child_process.exec("git ls-tree HEAD -r && echo " + PROCESS_OUTPUT_DELIMITER + " && git status --s -u .", { cwd: process.cwd() }, function (error, stdout) {
            var fileHashes = {};
            var processOutputBlocks = stdout.split(PROCESS_OUTPUT_DELIMITER + '\n');
            processOutputBlocks[0].split('\n').forEach(function (line) {
                if (line) {
                    var parts = line.substr(line.indexOf('blob ') + 5).split('\t');
                    fileHashes[parts[1]] = parts[0];
                }
            });
            if (processOutputBlocks[1]) {
                var changedFiles_1 = processOutputBlocks[1]
                    .split('\n')
                    .map(function (line) { return line.trim().split(' ')[1]; }).filter(function (name) { return !!name; });
                if (changedFiles_1.length) {
                    child_process.exec('git hash-object ' + changedFiles_1.join(' '), { cwd: process.cwd() }, function (hashError, hashStdout) {
                        var hashes = hashStdout.split('\n');
                        changedFiles_1.forEach(function (filename, i) { return fileHashes[filename] = hashes[i]; });
                        complete(fileHashes);
                    });
                }
            }
            else {
                complete(fileHashes);
            }
        });
    });
}
function _readPackageHashes(receiptPath) {
    return new Promise(function (complete) {
        fs.readFile(receiptPath, 'utf8', function (err, data) {
            complete(err ? undefined : JSON.parse(data));
        });
    });
}
function _areObjectsEqual(obj1, obj2) {
    var obj1Keys = Object.keys(obj1);
    var obj2Keys = Object.keys(obj2);
    if (obj1Keys.length === obj2Keys.length) {
        for (var _i = 0, obj1Keys_1 = obj1Keys; _i < obj1Keys_1.length; _i++) {
            var key = obj1Keys_1[_i];
            if (obj1[key] !== obj2[key]) {
                return false;
            }
        }
        return true;
    }
    return false;
}

//# sourceMappingURL=BuildReceiptTask.js.map
