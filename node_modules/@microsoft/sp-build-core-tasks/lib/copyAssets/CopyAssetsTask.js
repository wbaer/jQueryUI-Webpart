"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var path = require("path");
var gulp = require("gulp");
var through2 = require("through2");
var merge = require("merge2");
var gulpReplace = require("gulp-replace");
var setWebpackPublicPath = require("@microsoft/loader-set-webpack-public-path");
var lodash_1 = require("lodash");
var OdspGulpTask_1 = require("./../OdspGulpTask");
var ConfigureWebpackTask_1 = require("./../configureWebpack/ConfigureWebpackTask");
var constants_1 = require("../constants");
var url_1 = require("../utilities/url");
// If we change the type of bundle we're producing, we need to update this
var escapedStringsName = lodash_1.escapeRegExp(constants_1.default.stringsExternalBundleName);
var defaultStringsModuleRegex = new RegExp("^(define\\(.*\\[.*(\\\"|\\'))(?:" + escapedStringsName + ")((?:\\2).*])");
exports.externalsRegex = /external \"(.+)\"$/;
/**
 * Prepares deployment to CDNs and the manifest server through onedrive-buildtools.
 *
 * Example:
 *  IN:
 *   webpack stats
 *   deployCdnPath - a path where files should be placed for upload to CDNs and the manifest server
 *
 *  OUT:
 *   all assets for the package copied to {deployCdnPath}
 *   all externals for the package copied to {deployCdnPath}
 *   data required to produce manifests in the properties object
 */
var CopyAssetsTask = (function (_super) {
    __extends(CopyAssetsTask, _super);
    function CopyAssetsTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'copy-assets';
        _this.taskConfig = {
            deployCdnPath: undefined,
            extsToIgnore: ['.map', '.stats.json', '.stats.html']
        };
        return _this;
    }
    CopyAssetsTask.prototype.loadSchema = function () {
        return require('./copy-assets.schema.json');
    };
    CopyAssetsTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        var shouldPrepareProductionDeployment = this.buildConfig.production;
        if (!this.taskConfig.deployCdnPath && this.buildConfig.production) {
            shouldPrepareProductionDeployment = false;
            // Suppressed warning for now to unblock CI. VSO#219493
            this.log /*Warning*/('No deploy CDN path specified. Unable to prepare production deployment.');
        }
        var webpackStats = this.properties.initialWebpackStats || this.properties.webpackStats;
        if (!webpackStats) {
            this.logWarning('Missing webpack stats object. Nothing to prepare for deployment.');
            completeCallback();
            return;
        }
        var bundleEntries = this.properties.bundleEntries;
        if (!bundleEntries || !bundleEntries.length || bundleEntries.length === 0) {
            // @TODO: SPPPlat VSO 221536
            // this.logWarning('Missing config entries list. Nothing to prepare for deployment.');
            completeCallback();
            return;
        }
        var tasks = [];
        var webpackEntryChunks = new Map();
        var externalModules = [];
        var webpackStatsJson = webpackStats.toJson();
        var webpackAssets = webpackStatsJson.assets, webpackChunks = webpackStatsJson.chunks, webpackModules = webpackStatsJson.modules;
        webpackChunks.forEach(function (webpackChunk) {
            if (webpackChunk.entry) {
                webpackChunk.names.forEach(function (name) {
                    webpackEntryChunks.set(name, webpackChunk);
                });
            }
        });
        var configExternals = this.properties.externals || {};
        webpackModules.forEach(function (webpackModule) {
            var matches = webpackModule.name.match(exports.externalsRegex);
            if (matches) {
                var externalName_1 = matches[1];
                var configExternal = configExternals[externalName_1];
                var linkedExternal = (_this.properties.linkedExternals || {})[externalName_1];
                var configExternalPath = void 0;
                if (configExternal) {
                    if (linkedExternal) {
                        _this.logError("External \"" + externalName_1 + "\" is specified both as a linked package in the node_modules " +
                            'dependency tree and as an external in in the config.json file. Remove one of the external ' +
                            'references. Only one external reference type is allowed per external package.');
                        return;
                    }
                    else {
                        if (typeof configExternal === 'string') {
                            // it is an AMD external
                            configExternalPath = configExternal;
                        }
                        else {
                            // it is a non-AMD external
                            configExternalPath = configExternal.path;
                            if (!configExternal.globalName) {
                                _this.logError("External \"" + externalName_1 + "\" is defined as a Non-AMD script," +
                                    "but is missing a globalName property.");
                                return;
                            }
                            webpackModule.nonAmdConfig = configExternal;
                            (configExternal.globalDependencies || []).forEach(function (nonAMDDependency) {
                                var dependencyConfig = configExternals[nonAMDDependency];
                                if (!dependencyConfig) {
                                    _this.logError("External \"" + externalName_1 + "\" is referencing dependency \"" + nonAMDDependency + "\" which is " +
                                        'not defined.');
                                    return;
                                }
                                else if (!dependencyConfig.globalName) {
                                    _this.logError("External \"" + externalName_1 + "\" is referencing dependency \"" + nonAMDDependency + "\", " +
                                        'which is not defined as a global, non-AMD external.');
                                    return;
                                }
                                else if (_this.properties.bundledExternals &&
                                    _this.properties.bundledExternals.indexOf(nonAMDDependency) !== -1) {
                                    _this.logError("External \"" + externalName_1 + "\" is referencing dependency \"" + nonAMDDependency + "\", which " +
                                        'has been bundled.');
                                    return;
                                }
                            });
                        }
                    }
                }
                if (configExternalPath) {
                    // Keep the whole path if it is a full URL
                    webpackModule.isExternalUrl = url_1.isUrl(configExternalPath);
                    var configExternalFullPath = webpackModule.isExternalUrl
                        ? configExternalPath : path.join(_this.buildConfig.rootPath, configExternalPath);
                    webpackModule.configExternalFullPath = configExternalFullPath;
                }
                else if (!_this.properties.discoveredLocalizedResources[externalName_1] &&
                    !linkedExternal) {
                    // Make sure if we haven't found other references to this external, it's been discovered as a localized
                    // external
                    _this.logError("External \"" + externalName_1 + "\" is not correctly referenced in config.json. Deployed " +
                        'modules will produce unexpected behavior.');
                }
                if (!_this.properties.bundledExternals || _this.properties.bundledExternals.indexOf(externalName_1) === -1) {
                    // Only record the external it if hasn't been bundled by a second webpack run
                    webpackModule.externalName = externalName_1; // Add the external name as a new property
                    webpackModule.renameCallbacks = []; // Create a list of callbacks here
                    externalModules.push(webpackModule);
                }
            }
        });
        // Copy non-entry assets to the CDN deploy directory
        if (shouldPrepareProductionDeployment) {
            var assetsToCopy = [];
            var _loop_1 = function (webpackAsset) {
                var notIgnoredExt = !this_1.taskConfig.extsToIgnore ||
                    this_1.taskConfig.extsToIgnore.reduce(function (state, ext) {
                        return state && webpackAsset.name.slice(-ext.length) !== ext;
                    }, true);
                var notEntryChunk = webpackAsset.chunks.reduce(function (state, chunkId) {
                    return state && !webpackChunks[chunkId].entry;
                }, true);
                if (notIgnoredExt && notEntryChunk) {
                    // If we make it here, we aren't ignoring this chunk's extension and it isn't an entrypoint asset
                    // so we should copy it to the CDN deploy directory
                    // Try to ensure the file has a checksum in the filename
                    var checksumFound = false;
                    if (webpackAsset.chunks.length > 0) {
                        // Look through all of the asset's chunks and ensure the asset's name contains one of the chunks' hashes
                        checksumFound = webpackAsset.chunks.reduce(function (state, chunkId) {
                            return state || webpackAsset.name.indexOf(webpackChunks[chunkId].hash) > -1;
                        }, false);
                    }
                    else {
                        // Split the filename by "-" and "_", and test each part to see if it looks like a 5+ character hex digest
                        var name_1 = webpackAsset.name;
                        var filenameParts = path.basename(name_1, path.extname(name_1)).split(/[-_]/);
                        checksumFound = filenameParts.reduce(function (state, filenamePart) {
                            return state || !!filenamePart.match(/[a-fA-F0-9]{5,}/);
                        }, false);
                    }
                    if (!checksumFound) {
                        this_1.logError("Webpack-produced asset \"" + webpackAsset.name + "\" does not appear to have a checksum " +
                            'in its filename, meaning that it is not safe to deploy to the CDN.');
                    }
                    var assetPath = path.join(this_1.outputDirectory, webpackAsset.name);
                    assetsToCopy.push(assetPath);
                    if (webpackAsset.name.toLowerCase() !== webpackAsset.name) {
                        this_1.logWarning("Asset \"" + webpackAsset.name + "\"'s name is not all lowercase and will likely not be " +
                            'accessible after being copied to the CDN. Ensure that its name is all lowercase, ' +
                            'and consider using the "@microsoft/loader-cased-file" loader.');
                    }
                }
            };
            var this_1 = this;
            for (var _i = 0, webpackAssets_1 = webpackAssets; _i < webpackAssets_1.length; _i++) {
                var webpackAsset = webpackAssets_1[_i];
                _loop_1(webpackAsset);
            }
            // Copy the assets we've queued
            tasks.push(gulp.src(assetsToCopy).pipe(gulp.dest(this.taskConfig.deployCdnPath)));
        }
        var deployEntries = [];
        var stringsCopyCallbackMap = new Map();
        // If we have a bundleTemporaryName, we need to create a regex to find it and replace it in the
        //  "define(<name>, ..." statement
        var bundleTemporaryNameRegex = undefined;
        if (this.properties.webpackLibraryNameIsTemporary) {
            var escapedBundleTemporaryName = lodash_1.escapeRegExp(this.properties.webpackLibraryName);
            // If we change the type of bundle we're producing, we need to update this
            bundleTemporaryNameRegex = new RegExp("^(define\\((\\\"|\\'))(?:" + escapedBundleTemporaryName + ")((?:\\2),)");
        }
        bundleEntries.forEach(function (bundleEntry) {
            var manifest = _this.getManifest(bundleEntry.configEntry.manifest);
            if (!manifest) {
                _this.logWarning("Missing manifest for entry \"" + bundleEntry.configEntry.entry + "\". " +
                    'Unable to prepare deployment for this entry.');
                return;
            }
            // If we're only producing one manifest in this project, set the version to the package.json version
            if (bundleEntries.length === 1) {
                var manifestVersion = _this.getPackageVersion();
                manifest.version = manifestVersion;
            }
            var deployEntry = {
                bundleEntry: bundleEntry,
                configEntry: bundleEntry.configEntry,
                manifest: manifest,
                entryName: bundleEntry.entryName
            };
            deployEntries.push(deployEntry);
            deployEntry.debugModules = {
                localizedPathModules: new Map(),
                pathModules: new Map(),
                componentModules: new Map()
            };
            deployEntry.productionModules = {
                localizedPathModules: new Map(),
                pathModules: new Map(),
                componentModules: new Map()
            };
            var manifestId = deployEntry.manifest.id;
            var stringsModuleId = manifestId + "_strings";
            _this._processEntry(deployEntry, shouldPrepareProductionDeployment, stringsModuleId, bundleTemporaryNameRegex, tasks);
            var entryWebpackChunk = webpackEntryChunks.get(bundleEntry.entryName);
            var webpackChunkId = entryWebpackChunk.id;
            _this._processExternalsForEntry(webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap);
        });
        this._copyStrings(stringsCopyCallbackMap, tasks);
        this._processExternals(externalModules, tasks);
        // Save the deploy entries so they can be picked up by the WriteManifests task.
        this.properties.deployEntries = deployEntries;
        return merge(tasks).on('finish', function () { return completeCallback(); });
    };
    CopyAssetsTask.prototype._copyStrings = function (stringsCopyCallbackMap, tasks) {
        var _this = this;
        var moduleBaseName = path.basename(this.buildConfig.rootPath).toLowerCase();
        stringsCopyCallbackMap.forEach(function (callbacks, key) {
            var isStandardStringsModule = key === constants_1.default.stringsExternalBundleName;
            var baseFilename = isStandardStringsModule
                ? moduleBaseName
                : moduleBaseName + "-" + key.toLowerCase().replace(/\//g, '_');
            var localizedFiles = _this.properties.discoveredLocalizedResources[key];
            var _loop_2 = function (locale) {
                if (localizedFiles.hasOwnProperty(locale)) {
                    tasks.push(_this._renameWithHash(gulp.src(localizedFiles[locale]), function (hash) { return baseFilename + "_" + locale + "_" + hash + ".js"; }, function (filename) {
                        return callbacks.forEach(function (callback) {
                            return callback(locale, filename);
                        });
                    })
                        .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
                }
            };
            for (var locale in localizedFiles) {
                _loop_2(locale);
            }
        });
    };
    CopyAssetsTask.prototype._processEntry = function (deployEntry, shouldPrepareProductionDeployment, stringsModuleId, bundleTemporaryNameRegex, tasks) {
        var _this = this;
        var bundleEntry = deployEntry.bundleEntry;
        if (bundleEntry.nonLocalizedEntrypointPath && bundleEntry.localizedEntrypointPaths) {
            this.logError('Both localized and non-localized entrypoint files are specified for ' +
                ("entry " + deployEntry.configEntry.entry + ". Only one may be specified."));
            return false;
        }
        var entryName = deployEntry.entryName;
        var entryRegExp = entryName + "_?[a-zA-Z0-9-_]*.js";
        var entrypointFilesGlob;
        var productionRenameCallback;
        var getFilenameCallback;
        if (bundleEntry.nonLocalizedEntrypointPath) {
            var entryBundlePath = bundleEntry.nonLocalizedEntrypointPath;
            entrypointFilesGlob = [entryBundlePath];
            // Record the debug entry module
            var debugModules = deployEntry.debugModules;
            var debugEntryModule = {
                type: 'path',
                path: entryBundlePath
            };
            debugModules.pathModules.set(entryName, debugEntryModule);
            debugModules.entryModuleId = entryName;
            if (shouldPrepareProductionDeployment) {
                // Record the production entry module
                var productionModules = deployEntry.productionModules;
                var productionEntryModule_1 = {
                    type: 'path',
                    path: undefined
                };
                productionModules.pathModules.set(entryName, productionEntryModule_1);
                productionModules.entryModuleId = entryName;
                productionRenameCallback = function (filename) { return productionEntryModule_1.path = filename; };
                getFilenameCallback = function (hash) { return entryName.toLowerCase() + "_" + hash + ".js"; };
            }
        }
        else if (bundleEntry.localizedEntrypointPaths) {
            var reverseEntrypointLookup_1 = {};
            entrypointFilesGlob = [];
            for (var locale in bundleEntry.localizedEntrypointPaths) {
                if (bundleEntry.localizedEntrypointPaths.hasOwnProperty(locale)) {
                    var path_1 = bundleEntry.localizedEntrypointPaths[locale];
                    reverseEntrypointLookup_1[path_1] = locale;
                    entrypointFilesGlob.push(path_1);
                }
            }
            var defaultLocale_1 = this._selectDefaultLocaleForResource(bundleEntry.localizedEntrypointPaths, entryName);
            // Record the debug entry module
            var debugModules = deployEntry.debugModules;
            var debugEntryModule = {
                type: 'localizedPath',
                paths: {},
                defaultPath: undefined
            };
            debugModules.localizedPathModules.set(entryName, debugEntryModule);
            debugModules.entryModuleId = entryName;
            this._fillLocalizedPaths(bundleEntry.localizedEntrypointPaths, defaultLocale_1, debugEntryModule);
            if (shouldPrepareProductionDeployment) {
                // Record the production entry module
                var productionModules = deployEntry.productionModules;
                var productionEntryModule_2 = {
                    type: 'localizedPath',
                    paths: {},
                    defaultPath: undefined
                };
                productionModules.localizedPathModules.set(entryName, productionEntryModule_2);
                productionModules.entryModuleId = entryName;
                productionRenameCallback = function (filename, originalFilename) {
                    var locale = reverseEntrypointLookup_1[originalFilename];
                    _this._fillLocalizedPath(filename, locale, defaultLocale_1, productionEntryModule_2);
                };
                getFilenameCallback = function (hash, originalFilename) {
                    var locale = reverseEntrypointLookup_1[originalFilename];
                    return entryName.toLowerCase() + "_" + locale + "_" + hash + ".js";
                };
            }
        }
        else {
            this.logError('Neither a localized entrypoint file nor non-localized entrypoint files are specified for ' +
                ("entry " + deployEntry.configEntry.entry + ". One must be specified."));
            return false;
        }
        // Initialize the entry gulp stream and make a few initial transformations
        var entryGulpStream = gulp.src(entrypointFilesGlob)
            .pipe(through2.obj(this._insertGlobalRegisterCodeIfNecessary(this, !this.buildConfig.production)))
            .pipe(gulpReplace(defaultStringsModuleRegex, "$1" + stringsModuleId + "$3"))
            .pipe(gulpReplace(new RegExp(constants_1.default.defaultWebpackPublicPathScriptName, 'g'), entryRegExp));
        if (bundleTemporaryNameRegex) {
            // If we have a bundle temporary name, we need to set the correct name for each entrypoint file
            var correctName = ConfigureWebpackTask_1.getBundleId(bundleEntry.manifest);
            entryGulpStream = entryGulpStream.pipe(gulpReplace(bundleTemporaryNameRegex, "$1" + correctName + "$3"));
        }
        // Write entry file(s) back to 'dist'
        entryGulpStream = entryGulpStream.pipe(gulp.dest(this.outputDirectory));
        if (shouldPrepareProductionDeployment) {
            // Write production file(s) to the CDN deploy path
            entryGulpStream = this._renameWithHash(entryGulpStream, getFilenameCallback, productionRenameCallback)
                .pipe(gulp.dest(this.taskConfig.deployCdnPath));
        }
        tasks.push(entryGulpStream);
    };
    CopyAssetsTask.prototype._processExternals = function (externalModules, tasks) {
        var _this = this;
        externalModules.forEach(function (externalModule) {
            if (externalModule.renameCallbacks.length > 0) {
                // Replace slashes in the filename with dashes so we don't end up with unexpected subfolders
                var baseFilename_1 = externalModule.externalName.replace(/[\/\\]/, '-');
                tasks.push(_this._renameWithHash(gulp.src(externalModule.configExternalFullPath), function (hash) { return baseFilename_1.toLowerCase() + "_" + hash + ".js"; }, function (filename) {
                    return externalModule.renameCallbacks.forEach(function (renameCallback) {
                        return renameCallback(filename);
                    });
                })
                    .pipe(gulp.dest(_this.taskConfig.deployCdnPath)));
            }
        });
    };
    CopyAssetsTask.prototype._processExternalsForEntry = function (webpackChunkId, deployEntry, externalModules, stringsModuleId, shouldPrepareProductionDeployment, stringsCopyCallbackMap) {
        var _this = this;
        externalModules.forEach(function (externalModule) {
            // Determine if this external is referenced by the entry chunk
            if (externalModule.chunks.reduce(function (state, chunkId) { return state || webpackChunkId === chunkId; }, false)) {
                var externalName = externalModule.externalName;
                var localizedResource = _this.properties.discoveredLocalizedResources[externalName];
                if (localizedResource) {
                    // This is a localized resource
                    var isStandardStringsModule = externalName === constants_1.default.stringsExternalBundleName;
                    var resourceName = isStandardStringsModule ? stringsModuleId : externalName;
                    var debugModule = {
                        defaultPath: undefined,
                        type: 'localizedPath',
                        paths: {}
                    };
                    deployEntry.debugModules.localizedPathModules.set(resourceName, debugModule);
                    var defaultLocale_2 = _this._selectDefaultLocaleForResource(localizedResource, resourceName);
                    _this._fillLocalizedPaths(localizedResource, defaultLocale_2, debugModule);
                    if (shouldPrepareProductionDeployment) {
                        var productionModule_1 = {
                            defaultPath: undefined,
                            type: 'localizedPath',
                            paths: {}
                        };
                        deployEntry.productionModules.localizedPathModules.set(resourceName, productionModule_1);
                        if (!stringsCopyCallbackMap.has(externalName)) {
                            stringsCopyCallbackMap.set(externalName, []);
                        }
                        var callbacks = stringsCopyCallbackMap.get(externalName);
                        callbacks.push((function (locale, filename) {
                            _this._fillLocalizedPath(filename, locale, defaultLocale_2, productionModule_1);
                        }));
                    }
                }
                else if ((_this.properties.linkedExternals || {})[externalName]) {
                    // This is a component module, so we need to record that this entry is using it, but we don't need to
                    // copy it to the CDN directory
                    var linkedExternal = _this.properties.linkedExternals[externalName];
                    var debugModule = {
                        type: 'component',
                        version: linkedExternal.version,
                        id: linkedExternal.id,
                        failoverPath: linkedExternal.failoverPath
                    };
                    deployEntry.debugModules.componentModules.set(externalName, debugModule);
                    if (shouldPrepareProductionDeployment) {
                        var productionModule = {
                            type: 'component',
                            version: linkedExternal.version,
                            id: linkedExternal.id
                        };
                        deployEntry.productionModules.componentModules.set(externalName, productionModule);
                    }
                }
                else if (!externalModule.configExternalFullPath) {
                    _this.logError("External \"" + externalName + "\" was specified without a path, and it is neither a " +
                        'component nor a localized module. The produced manifest will likely not load.');
                    return;
                }
                else {
                    // This is a plain path module, so we do need to copy it to the CDN directory if we're in production
                    // mode and it is not a fully qualified URL
                    deployEntry.debugModules.pathModules.set(externalName, externalModule.nonAmdConfig ?
                        {
                            type: 'path',
                            path: externalModule.configExternalFullPath,
                            globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                            globalName: externalModule.nonAmdConfig.globalName
                        } : {
                        type: 'path',
                        path: externalModule.configExternalFullPath
                    });
                    if (shouldPrepareProductionDeployment) {
                        var productionModule_2 = externalModule.nonAmdConfig ?
                            {
                                type: 'path',
                                path: undefined,
                                globalDependencies: externalModule.nonAmdConfig.globalDependencies,
                                globalName: externalModule.nonAmdConfig.globalName
                            } : {
                            type: 'path',
                            path: undefined
                        };
                        deployEntry.productionModules.pathModules.set(externalName, productionModule_2);
                        if (externalModule.isExternalUrl) {
                            // There won't be a rename since this is not on the local filesystem
                            productionModule_2.path = externalModule.configExternalFullPath;
                        }
                        else {
                            externalModule.renameCallbacks.push(function (filename) { return productionModule_2.path = filename; });
                        }
                    }
                }
            }
        });
    };
    CopyAssetsTask.prototype._renameWithHash = function (gulpStream, getFilename, filenameCallback) {
        return gulpStream.pipe(through2.obj(this._getRenameTransformFunction(getFilename, filenameCallback)));
    };
    CopyAssetsTask.prototype._getRenameTransformFunction = function (getFilename, filenameCallback) {
        var self = this;
        return function (file, enc, callback) {
            var checksum = self.getChecksum(file.contents.toString(enc));
            var originalFilename = file.path;
            var filename = getFilename(checksum, originalFilename);
            file.path = path.join(path.dirname(file.path), filename);
            filenameCallback(filename, originalFilename);
            this.push(file);
            callback();
        };
    };
    CopyAssetsTask.prototype._selectDefaultLocaleForResource = function (paths, externalName) {
        var defaultLocale;
        var defaultLocaleInPaths = false;
        var localeKeys = Object.keys(paths);
        if (localeKeys.length === 1) {
            // We only have one locale, so pick that one as the default
            defaultLocale = localeKeys[0];
        }
        else if ('default' in paths) {
            // We have a "default" default locale, so make "default" the default
            defaultLocale = 'default';
        }
        else if (constants_1.default.defaultLocale in paths) {
            // We have the constants.defaultLocale locale ("en-us"), so pick that one as the default
            defaultLocale = constants_1.default.defaultLocale;
            defaultLocaleInPaths = true; // In this case, the default locale is en-us, but that's also a regular path
        }
        else {
            // We couldn't pick a default locale, so issue a warning
            this.logWarning("Unable to select a default locale for external resource \"" + externalName + "\". " +
                'Packaging a production build will fail.');
        }
        return { defaultLocale: defaultLocale, defaultLocaleInPaths: defaultLocaleInPaths };
    };
    CopyAssetsTask.prototype._fillLocalizedPaths = function (paths, defaultLocale, moduleConfig) {
        for (var locale in paths) {
            if (paths.hasOwnProperty(locale)) {
                var path_2 = paths[locale];
                this._fillLocalizedPath(path_2, locale, defaultLocale, moduleConfig);
            }
        }
    };
    CopyAssetsTask.prototype._fillLocalizedPath = function (path, locale, defaultLocale, moduleConfig) {
        var isDefaultLocale = locale === defaultLocale.defaultLocale;
        if (isDefaultLocale) {
            moduleConfig.defaultPath = path;
        }
        if (!isDefaultLocale || defaultLocale.defaultLocaleInPaths) {
            moduleConfig.paths[locale] = path;
        }
    };
    /**
     * For webpack entries that are imported using SystemJS, the script is injected into the page, but
     * the element is removed before the entry is initialized. Webpack requires a public path be set,
     * and because we don't have a single host location, we need to set the public path dynamically.
     * The public path is set when the entry is initialized, and in certain cases (like in development),
     * it will look at the script tags on the page to determine what the root path is.
     *
     * We can append a small bit of code to the end of the entry's JS file that will mitigate this issue
     * by maintaining a registry of scripts that have been injected onto the page, so the public path
     * can be correctly set even if the script element that pointed to the entry's JS file has been removed
     * already.
     */
    CopyAssetsTask.prototype._insertGlobalRegisterCodeIfNecessary = function (self, debug) {
        return function (file, enc, callback) {
            if (!file.isNull() && file.contents) {
                var contents = file.contents.toString(enc);
                if (contents.match(new RegExp(setWebpackPublicPath.registryVarName, 'g'))) {
                    var registerCode = setWebpackPublicPath.getGlobalRegisterCode(debug);
                    file.contents = new Buffer("" + contents + registerCode);
                }
                this.push(file);
            }
            callback();
        };
    };
    return CopyAssetsTask;
}(OdspGulpTask_1.default));
exports.CopyAssetsTask = CopyAssetsTask;

//# sourceMappingURL=CopyAssetsTask.js.map
