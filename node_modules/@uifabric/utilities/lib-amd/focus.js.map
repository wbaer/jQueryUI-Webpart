{"version":3,"sources":["focus.ts"],"names":[],"mappings":"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","file":"focus.js","sourcesContent":["/* tslint:disable:no-string-literal */\r\n\r\nimport { elementContains, getDocument } from './dom';\r\n\r\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\r\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\r\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\r\n\r\nexport function getFirstFocusable(\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean): HTMLElement {\r\n\r\n  return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);\r\n}\r\n\r\nexport function getLastFocusable(\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  includeElementsInFocusZones?: boolean): HTMLElement {\r\n\r\n  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);\r\n}\r\n\r\n/**\r\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\r\n * @return True if focus was set, false if it was not.\r\n * @param {HTMLElement} rootElement - element to start the search for a focusable child.\r\n */\r\nexport function focusFirstChild(\r\n  rootElement: HTMLElement): boolean {\r\n  let element: HTMLElement = getNextElement(rootElement, rootElement, true, false, false, true);\r\n\r\n  if (element) {\r\n    element.focus();\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/** Traverse to find the previous element. */\r\nexport function getPreviousElement(\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  checkNode?: boolean,\r\n  suppressParentTraversal?: boolean,\r\n  traverseChildren?: boolean,\r\n  includeElementsInFocusZones?: boolean): HTMLElement {\r\n\r\n  if (!currentElement ||\r\n    currentElement === rootElement) {\r\n    return null;\r\n  }\r\n\r\n  let isCurrentElementVisible = isElementVisible(currentElement);\r\n\r\n  // Check its children.\r\n  if (traverseChildren && (includeElementsInFocusZones || !isElementFocusZone(currentElement)) && isCurrentElementVisible) {\r\n    const childMatch = getPreviousElement(\r\n      rootElement,\r\n      currentElement.lastElementChild as HTMLElement,\r\n      true,\r\n      true,\r\n      true,\r\n      includeElementsInFocusZones);\r\n\r\n    if (childMatch) {\r\n      return childMatch;\r\n    }\r\n  }\r\n\r\n  // Check the current node, if it's not the first traversal.\r\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\r\n    return currentElement;\r\n  }\r\n\r\n  // Check its previous sibling.\r\n  const siblingMatch = getPreviousElement(\r\n    rootElement,\r\n    currentElement.previousElementSibling as HTMLElement,\r\n    true,\r\n    true,\r\n    true,\r\n    includeElementsInFocusZones);\r\n\r\n  if (siblingMatch) {\r\n    return siblingMatch;\r\n  }\r\n\r\n  // Check its parent.\r\n  if (!suppressParentTraversal) {\r\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/** Traverse to find the next focusable element. */\r\nexport function getNextElement(\r\n  rootElement: HTMLElement,\r\n  currentElement: HTMLElement,\r\n  checkNode?: boolean,\r\n  suppressParentTraversal?: boolean,\r\n  suppressChildTraversal?: boolean,\r\n  includeElementsInFocusZones?: boolean): HTMLElement {\r\n\r\n  if (\r\n    !currentElement ||\r\n    (currentElement === rootElement && suppressChildTraversal)) {\r\n    return null;\r\n  }\r\n\r\n  let isCurrentElementVisible = isElementVisible(currentElement);\r\n\r\n  // Check the current node, if it's not the first traversal.\r\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\r\n    return currentElement;\r\n  }\r\n\r\n  // Check its children.\r\n  if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !isElementFocusZone(currentElement))) {\r\n    const childMatch = getNextElement(\r\n      rootElement,\r\n      currentElement.firstElementChild as HTMLElement,\r\n      true,\r\n      true,\r\n      false,\r\n      includeElementsInFocusZones);\r\n\r\n    if (childMatch) {\r\n      return childMatch;\r\n    }\r\n  }\r\n\r\n  if (currentElement === rootElement) {\r\n    return null;\r\n  }\r\n\r\n  // Check its sibling.\r\n  const siblingMatch = getNextElement(\r\n    rootElement,\r\n    currentElement.nextElementSibling as HTMLElement,\r\n    true,\r\n    true,\r\n    false,\r\n    includeElementsInFocusZones);\r\n\r\n  if (siblingMatch) {\r\n    return siblingMatch;\r\n  }\r\n\r\n  if (!suppressParentTraversal) {\r\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function isElementVisible(element: HTMLElement): boolean {\r\n  // If the element is not valid, return false.\r\n  if (!element || !element.getAttribute) {\r\n    return false;\r\n  }\r\n\r\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\r\n\r\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\r\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\r\n    return visibilityAttribute === 'true';\r\n  }\r\n\r\n  // Fallback to other methods of determining actual visibility.\r\n  return (element.offsetHeight !== 0 ||\r\n    element.offsetParent !== null ||\r\n    (element as any).isVisible === true); // used as a workaround for testing.\r\n}\r\n\r\nexport function isElementTabbable(element: HTMLElement): boolean {\r\n\r\n  // If this element is null or is disabled, it is not considered tabbable.\r\n  if (!element || (element as HTMLButtonElement).disabled) {\r\n    return false;\r\n  }\r\n\r\n  // In IE, element.tabIndex is default to 0. We need to use element get tabIndex attribute to get the correct tabIndex\r\n  let tabIndex = -1;\r\n\r\n  if (element && element.getAttribute) {\r\n    tabIndex = parseInt(element.getAttribute('tabIndex'), 10);\r\n  }\r\n\r\n  let isFocusableAttribute: string = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\r\n\r\n  return (\r\n    !!element && isFocusableAttribute !== 'false' &&\r\n    (element.tagName === 'A' ||\r\n      (element.tagName === 'BUTTON') ||\r\n      (element.tagName === 'INPUT') ||\r\n      (element.tagName === 'TEXTAREA') ||\r\n      (tabIndex >= 0) ||\r\n      (element.getAttribute && (\r\n        isFocusableAttribute === 'true' ||\r\n        element.getAttribute('role') === 'button'\r\n      ))\r\n    ));\r\n}\r\n\r\nexport function isElementFocusZone(element?: HTMLElement): boolean {\r\n  return element && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE);\r\n}\r\n\r\nexport function doesElementContainFocus(element: HTMLElement) {\r\n  let currentActiveElement: HTMLElement = getDocument(element).activeElement as HTMLElement;\r\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n"],"sourceRoot":"..\\src"}