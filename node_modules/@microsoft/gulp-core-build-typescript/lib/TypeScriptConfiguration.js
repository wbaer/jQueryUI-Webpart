"use strict";
var path = require("path");
var assign = require("object-assign");
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var typescript = require("typescript");
/* tslint:disable:no-any */
/*
 * A helper class which provides access to the TSConfig.json file for a particular project.
 * It also is a central place for managing the version of typescript which this project
 * should be built with.
 */
var TypeScriptConfiguration = (function () {
    function TypeScriptConfiguration() {
    }
    /**
     * Gets `gulp-typescript` version of the config (used by TypeScriptTask)
     * Returns a new object each time.
     */
    TypeScriptConfiguration.getGulpTypescriptOptions = function (buildConfig) {
        var file = assign({}, this._getTsConfigFile(buildConfig));
        assign(file.compilerOptions, {
            rootDir: buildConfig.rootPath,
            typescript: this.getTypescriptCompiler()
        });
        return file;
    };
    /*
     * Gets the `typescript` version of the config (used by ApiExtractorTask)
     * Note: these differ slightly from the values in the tsconfig.json
     * Returns a new object each time.
     *
     * Specifically, the issue in the difference between:
     *    typescript.CompilerOptions
     *               &
     *          ts.Settings
     *
     * Insofar as `ts.Settings` accepts (and requires) enums for certain options, rather than strings.
     * The clearest example is `moduleResolution` below.
     */
    TypeScriptConfiguration.getTypescriptOptions = function (buildConfig) {
        var oldConfig = this.getGulpTypescriptOptions(buildConfig);
        var newConfig = oldConfig;
        delete newConfig.compilerOptions.moduleResolution;
        /**
         * Attempt to index into the enum to determine which target.
         */
        var scriptTarget = {
            'es2015': typescript.ScriptTarget.ES2015,
            'es2016': typescript.ScriptTarget.ES2016,
            'es2017': typescript.ScriptTarget.ES2017,
            'es3': typescript.ScriptTarget.ES3,
            'es5': typescript.ScriptTarget.ES5,
            'exnext': typescript.ScriptTarget.ESNext,
            'latest': typescript.ScriptTarget.Latest
        };
        if (typeof oldConfig.compilerOptions.target === 'string') {
            var target = oldConfig.compilerOptions.target.toLowerCase();
            newConfig.compilerOptions.target = scriptTarget[target];
            if (!newConfig.compilerOptions.target) {
                throw new Error("Invalid setting found in tsconfig.json: target: '" + target + "' to be one of: "
                    + Object.keys(scriptTarget).toString());
            }
        }
        /**
         * Map the string in the tsconfig.json file to an enum for the typescript API
         */
        var moduleKind = {
            'commonjs': typescript.ModuleKind.CommonJS,
            'amd': typescript.ModuleKind.AMD,
            'es2015': typescript.ModuleKind.ES2015,
            'none': typescript.ModuleKind.None,
            'system': typescript.ModuleKind.System,
            'umd': typescript.ModuleKind.UMD
        };
        if (typeof oldConfig.compilerOptions.module === 'string') {
            var module_1 = oldConfig.compilerOptions.module;
            newConfig.compilerOptions.module = moduleKind[module_1.toLowerCase()];
            if (!newConfig.compilerOptions.module) {
                throw new Error("Invalid setting found in tsconfig.json: Expected module: '" + module_1 + "' to be one of: "
                    + Object.keys(moduleKind).toString());
            }
        }
        return newConfig;
    };
    /**
     * Override the version of the typescript compiler
     */
    TypeScriptConfiguration.setTypescriptCompiler = function (typescript) {
        if (this._typescript) {
            throw new Error('The version of the typescript compiler should only be set once.');
        }
        if (this._baseTsConfig) {
            throw new Error('Set the version of the typescript compiler before tasks call getConfig()');
        }
        this._typescript = typescript;
    };
    /**
     * Get the version of the typescript compiler which is to be used
     */
    TypeScriptConfiguration.getTypescriptCompiler = function () {
        if (!this._typescript) {
            return require('typescript');
        }
        return this._typescript;
    };
    /**
     * Helper function which reads the tsconfig.json (or provides one), and memoizes it
     */
    TypeScriptConfiguration._getTsConfigFile = function (config) {
        if (!this._baseTsConfig) {
            try {
                this._baseTsConfig = gulp_core_build_1.SchemaValidator.readCommentedJsonFile(this._getConfigPath(config));
            }
            catch (e) {
            }
            if (!this._baseTsConfig) {
                this._baseTsConfig = {
                    compilerOptions: {
                        declaration: true,
                        experimentalDecorators: true,
                        jsx: 'react',
                        moduleResolution: 'node',
                        sourceMap: true,
                        target: 'es5',
                        noUnusedParameters: true,
                        noUnusedLocals: true
                    }
                };
            }
        }
        return this._baseTsConfig;
    };
    /**
     * Extracts the path to the tsconfig.json based on the buildConfiguration
     */
    TypeScriptConfiguration._getConfigPath = function (buildConfig) {
        return path.resolve(path.join(buildConfig.rootPath, 'tsconfig.json'));
    };
    return TypeScriptConfiguration;
}());
TypeScriptConfiguration._typescript = require('typescript');
exports.TypeScriptConfiguration = TypeScriptConfiguration;

//# sourceMappingURL=TypeScriptConfiguration.js.map
