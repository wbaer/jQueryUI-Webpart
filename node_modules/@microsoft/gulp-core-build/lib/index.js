'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
/* tslint:disable:max-line-length */
var path = require("path");
var GulpTask_1 = require("./tasks/GulpTask");
var GulpProxy_1 = require("./GulpProxy");
var CleanTask_1 = require("./tasks/CleanTask");
var State_1 = require("./State");
var logging_1 = require("./logging");
var config_1 = require("./config");
var notifier = require("node-notifier");
var logging_2 = require("./logging");
exports.addSuppression = logging_2.addSuppression;
exports.coverageData = logging_2.coverageData;
exports.functionalTestRun = logging_2.functionalTestRun;
exports.getErrors = logging_2.getErrors;
exports.getWarnings = logging_2.getWarnings;
exports.TestResultState = logging_2.TestResultState;
exports.warn = logging_2.warn;
exports.verbose = logging_2.verbose;
exports.error = logging_2.error;
exports.fileError = logging_2.fileError;
exports.fileLog = logging_2.fileLog;
exports.fileWarning = logging_2.fileWarning;
exports.reset = logging_2.reset;
exports.log = logging_2.log;
exports.logSummary = logging_2.logSummary;
__export(require("./tasks/CopyTask"));
__export(require("./tasks/GenerateShrinkwrapTask"));
__export(require("./tasks/GulpTask"));
__export(require("./tasks/CleanTask"));
__export(require("./tasks/ValidateShrinkwrapTask"));
__export(require("./jsonUtilities/SchemaValidator"));
/* tslint:disable:variable-name */
require('es6-promise').polyfill();
/* tslint:enable:variable-name */
// tslint:disable-next-line:no-any
var packageJSON = require(path.resolve(process.cwd(), 'package.json'));
var _taskMap = {};
var _uniqueTasks = [];
var packageFolder = (packageJSON.directories && packageJSON.directories.packagePath) ?
    packageJSON.directories.packagePath : '';
var _buildConfig = {
    packageFolder: packageFolder,
    srcFolder: 'src',
    distFolder: path.join(packageFolder, 'dist'),
    libAMDFolder: undefined,
    libFolder: path.join(packageFolder, 'lib'),
    tempFolder: 'temp',
    properties: {},
    relogIssues: config_1.getFlagValue('relogIssues', true),
    showToast: config_1.getFlagValue('showToast', true),
    buildSuccessIconPath: path.resolve(__dirname, 'pass.png'),
    buildErrorIconPath: path.resolve(__dirname, 'fail.png'),
    verbose: config_1.getFlagValue('verbose', false),
    production: config_1.getFlagValue('production', false),
    args: State_1.args,
    shouldWarningsFailBuild: false
};
/**
 * Merges the given build config settings into existing settings.
 *
 * @param config - The build config settings.
 */
function setConfig(config) {
    /* tslint:disable:typedef */
    var objectAssign = require('object-assign');
    /* tslint:enable:typedef */
    _buildConfig = objectAssign({}, _buildConfig, config);
}
exports.setConfig = setConfig;
/**
 * Merges the given build config settings into existing settings.
 *
 * @param  config - The build config settings.
 */
function mergeConfig(config) {
    /* tslint:disable:typedef */
    var merge = require('lodash.merge');
    /* tslint:enable:typedef */
    _buildConfig = merge({}, _buildConfig, config);
}
exports.mergeConfig = mergeConfig;
/**
 * Replaces the build config.
 *
 * @param  config - The build config settings.
 */
function replaceConfig(config) {
    _buildConfig = config;
}
exports.replaceConfig = replaceConfig;
/**
 * Gets the current config.
 * @returns the current build configuration
 */
function getConfig() {
    return _buildConfig;
}
exports.getConfig = getConfig;
/**
 * Registers an IExecutable to gulp so that it can be called from the command line
 * @param taskName - the name of the task, can be called from the command line (e.g. "gulp <taskName>")
 * @param task - the executable to execute when the task is invoked
 * @returns the task parameter
 */
function task(taskName, task) {
    _taskMap[taskName] = task;
    _trackTask(task);
    return task;
}
exports.task = task;
var CustomTask = (function (_super) {
    __extends(CustomTask, _super);
    function CustomTask(name, fn) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._fn = fn.bind(_this);
        return _this;
    }
    CustomTask.prototype.executeTask = function (gulp, completeCallback) {
        return this._fn(gulp, getConfig(), completeCallback);
    };
    return CustomTask;
}(GulpTask_1.GulpTask));
/**
 * Creates a new subtask from a function callback. Useful as a shorthand way
 * of defining tasks directly in a gulpfile.
 *
 * @param taskName - the name of the task, appearing in build logs
 * @param fn - the callback function to execute when this task runs
 * @returns an IExecutable which can be registered to the command line with task()
 */
function subTask(taskName, fn) {
    var customTask = new CustomTask(taskName, fn);
    return customTask;
}
exports.subTask = subTask;
/**
 * Defines a gulp watch and maps it to a given IExecutable.
 *
 * @param watrchMatch - the list of files patterns to watch
 * @param task - the task to execute when a file changes
 * @returns IExecutable
 */
function watch(watchMatch, task) {
    _trackTask(task);
    var isWatchRunning = false;
    var shouldRerunWatch = false;
    var lastError = undefined;
    return {
        execute: function (buildConfig) {
            logging_1.setWatchMode();
            buildConfig.gulp.watch(watchMatch, _runWatch);
            function _runWatch() {
                if (isWatchRunning) {
                    shouldRerunWatch = true;
                }
                else {
                    isWatchRunning = true;
                    _executeTask(task, buildConfig)
                        .then(function () {
                        if (buildConfig.showToast && lastError) {
                            lastError = undefined;
                            notifier.notify({
                                title: 'Build succeeded',
                                message: packageJSON.name,
                                icon: buildConfig.buildSuccessIconPath
                            });
                        }
                        _finalizeWatch();
                    })
                        .catch(function (error) {
                        if (buildConfig.showToast) {
                            if (!lastError || lastError !== error) {
                                lastError = error;
                                notifier.notify({
                                    title: 'Build failed',
                                    message: error,
                                    icon: buildConfig.buildErrorIconPath
                                });
                            }
                        }
                        _finalizeWatch();
                    });
                }
            }
            function _finalizeWatch() {
                isWatchRunning = false;
                if (shouldRerunWatch) {
                    shouldRerunWatch = false;
                    _runWatch();
                }
            }
            return Promise.resolve();
        }
    };
}
exports.watch = watch;
/**
 * Takes in IExecutables as arguments and returns an IExecutable that will execute them in serial.
 */
function serial() {
    var tasks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tasks[_i] = arguments[_i];
    }
    // tslint:disable-next-line:no-null-keyword
    var flatTasks = _flatten(tasks).filter(function (task) { return task !== null && task !== undefined; });
    for (var _a = 0, flatTasks_1 = flatTasks; _a < flatTasks_1.length; _a++) {
        var task_1 = flatTasks_1[_a];
        _trackTask(task_1);
    }
    return {
        execute: function (buildConfig) {
            var output = Promise.resolve();
            var _loop_1 = function (task_2) {
                output = output.then(function () { return _executeTask(task_2, buildConfig); });
            };
            for (var _i = 0, flatTasks_2 = flatTasks; _i < flatTasks_2.length; _i++) {
                var task_2 = flatTasks_2[_i];
                _loop_1(task_2);
            }
            return output;
        }
    };
}
exports.serial = serial;
/**
 * Takes in IExecutables as arguments and returns an IExecutable that will execute them in parallel.
 */
function parallel() {
    var tasks = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        tasks[_i] = arguments[_i];
    }
    // tslint:disable-next-line:no-null-keyword
    var flattenTasks = _flatten(tasks).filter(function (task) { return task !== null && task !== undefined; });
    for (var _a = 0, flattenTasks_1 = flattenTasks; _a < flattenTasks_1.length; _a++) {
        var task_3 = flattenTasks_1[_a];
        _trackTask(task_3);
    }
    return {
        // tslint:disable-next-line:no-any
        execute: function (buildConfig) {
            return new Promise(function (resolve, reject) {
                var promises = [];
                for (var _i = 0, flattenTasks_2 = flattenTasks; _i < flattenTasks_2.length; _i++) {
                    var task_4 = flattenTasks_2[_i];
                    promises.push(_executeTask(task_4, buildConfig));
                }
                // Use promise all to make sure errors are propagated correctly
                Promise.all(promises).then(resolve, reject);
            });
        }
    };
}
exports.parallel = parallel;
/**
 * Initializes the gulp tasks.
 */
function initialize(gulp) {
    _buildConfig.rootPath = process.cwd();
    _buildConfig.gulp = new GulpProxy_1.GulpProxy(gulp);
    _buildConfig.uniqueTasks = _uniqueTasks;
    _handleCommandLineArguments();
    config_1.setConfigDefaults(_buildConfig);
    for (var _i = 0, _a = _buildConfig.uniqueTasks; _i < _a.length; _i++) {
        var task_5 = _a[_i];
        if (task_5.onRegister) {
            task_5.onRegister();
        }
    }
    logging_1.initialize(gulp, undefined, undefined);
    Object.keys(_taskMap).forEach(function (taskName) { return _registerTask(gulp, taskName, _taskMap[taskName]); });
    logging_1.markTaskCreationTime();
}
exports.initialize = initialize;
/**
 * Registers a given gulp task given a name and an IExecutable.
 */
function _registerTask(gulp, taskName, task) {
    gulp.task(taskName, function (cb) {
        _executeTask(task, _buildConfig)
            .then(function () {
            cb();
        }, function (error) {
            cb(logging_1.generateGulpError(error));
        });
    });
}
/**
 * Executes a given IExecutable.
 */
function _executeTask(task, buildConfig) {
    // Try to fallback to the default task if provided.
    if (task && !task.execute) {
        /* tslint:disable:no-any */
        if (task.default) {
            task = task.default;
        }
    }
    // If the task is missing, throw a meaningful error.
    if (!task || !task.execute) {
        return Promise.reject(new Error("A task was scheduled, but the task was null. This probably means the task wasn't imported correctly."));
    }
    if (task.isEnabled === undefined || task.isEnabled(buildConfig)) {
        var startTime_1 = process.hrtime();
        if (buildConfig.onTaskStart && task.name) {
            buildConfig.onTaskStart(task.name);
        }
        var taskPromise = task.execute(buildConfig)
            .then(function () {
            if (buildConfig.onTaskEnd && task.name) {
                buildConfig.onTaskEnd(task.name, process.hrtime(startTime_1));
            }
        }, 
        // tslint:disable-next-line:no-any
        function (error) {
            if (buildConfig.onTaskEnd && task.name) {
                buildConfig.onTaskEnd(task.name, process.hrtime(startTime_1), error);
            }
            return Promise.reject(error);
        });
        return taskPromise;
    }
    // No-op otherwise.
    return Promise.resolve();
}
function _trackTask(task) {
    if (_uniqueTasks.indexOf(task) < 0) {
        _uniqueTasks.push(task);
    }
}
/**
 * Flattens a set of arrays into a single array.
 */
function _flatten(oArr) {
    var output = [];
    function traverse(arr) {
        for (var i = 0; i < arr.length; ++i) {
            if (Array.isArray(arr[i])) {
                traverse(arr[i]);
            }
            else {
                output.push(arr[i]);
            }
        }
    }
    traverse(oArr);
    return output;
}
function _handleCommandLineArguments() {
    _handleTasksListArguments();
}
function _handleTasksListArguments() {
    /* tslint:disable:no-string-literal */
    if (State_1.args['tasks'] || State_1.args['tasks-simple'] || State_1.args['T']) {
        global['dontWatchExit'] = true;
    }
    if (State_1.args['h']) {
        // we are showing a help command prompt via yargs or ts-command-line
        global['dontWatchExit'] = true;
    }
    /* tslint:enable:no-string-literal */
}
exports.clean = new CleanTask_1.CleanTask();
// Register default clean task.
task('clean', exports.clean);

//# sourceMappingURL=index.js.map
