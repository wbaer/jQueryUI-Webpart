"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var ts = require("gulp-typescript");
var path = require("path");
var TypeScriptConfiguration_1 = require("./TypeScriptConfiguration");
var TypeScriptTask = (function (_super) {
    __extends(TypeScriptTask, _super);
    function TypeScriptTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'typescript';
        _this.taskConfig = {
            failBuildOnErrors: true,
            reporter: {
                error: function (error) {
                    var filename = error.relativeFilename || error.fullFilename;
                    var line = error.startPosition ? error.startPosition.line : 0;
                    var character = error.startPosition ? error.startPosition.character : 0;
                    var code = error.diagnostic.code;
                    var errorMessage = (typeof error.diagnostic.messageText === 'object') ?
                        error.diagnostic.messageText.messageText :
                        error.diagnostic.messageText;
                    _this.fileError(filename, line, character, 'TS' + code, errorMessage);
                }
            },
            sourceMatch: [
                'src/**/*.ts',
                'src/**/*.tsx',
                'typings/main/**/*.ts',
                'typings/main.d.ts',
                'typings/tsd.d.ts',
                'typings/index.d.ts'
            ],
            staticMatch: [
                'src/**/*.js',
                'src/**/*.json',
                'src/**/*.jsx'
            ],
            removeCommentsFromJavaScript: false,
            emitSourceMaps: true,
            libDir: undefined,
            libAMDDir: undefined
        };
        return _this;
    }
    TypeScriptTask.prototype.loadSchema = function () {
        return require('./schemas/typescript.schema.json');
    };
    TypeScriptTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        /* tslint:disable:typedef */
        var assign = require('object-assign');
        var merge = require('merge2');
        /* tslint:enable:typedef */
        var allStreams = [];
        var result = {
            errorCount: 0
        };
        this._normalizeConfig();
        // Log the compiler version for custom verisons.
        var typescript = TypeScriptConfiguration_1.TypeScriptConfiguration.getTypescriptCompiler(); // tslint:disable-line:no-any
        if (typescript && typescript.version) {
            this.log("TypeScript version: " + typescript.version);
        }
        // tslint:disable-next-line:no-any
        var compilerOptions = TypeScriptConfiguration_1.TypeScriptConfiguration.getGulpTypescriptOptions(this.buildConfig).compilerOptions;
        if (compilerOptions.module !== 'commonjs' && compilerOptions.module) {
            this.logWarning("Your tsconfig.json file specifies a different \"target\" than expected. "
                + ("Expected: \"commonjs\". Actual: \"" + compilerOptions.module + "\". Using \"commonjs\" instead."));
            compilerOptions.module = 'commonjs';
        }
        this._tsProject = this._tsProject || ts.createProject(compilerOptions);
        this._compileProject(gulp, this._tsProject, this.taskConfig.libDir, allStreams, result);
        // Static passthrough files.
        var staticSrc = gulp.src(this.taskConfig.staticMatch);
        allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libDir)));
        // If AMD modules are required, also build that.
        if (this.taskConfig.libAMDDir) {
            allStreams.push(staticSrc.pipe(gulp.dest(this.taskConfig.libAMDDir)));
            this._tsAMDProject = this._tsAMDProject || ts.createProject(assign({}, compilerOptions, { module: 'amd' }));
            this._compileProject(gulp, this._tsAMDProject, this.taskConfig.libAMDDir, allStreams, result);
        }
        // Listen for pass/fail, and ensure that the task passes/fails appropriately.
        merge(allStreams)
            .on('queueDrain', function () {
            if (_this.taskConfig.failBuildOnErrors && result.errorCount) {
                completeCallback('TypeScript error(s) occurred.');
            }
            else {
                completeCallback();
            }
        })
            .on('error', completeCallback);
    };
    TypeScriptTask.prototype.getCleanMatch = function (buildConfig, taskConfig) {
        if (taskConfig === void 0) { taskConfig = this.taskConfig; }
        this._normalizeConfig(buildConfig);
        var cleanMatch = [
            this.taskConfig.libDir
        ];
        if (this.taskConfig.libAMDDir) {
            cleanMatch.push(this.taskConfig.libAMDDir);
        }
        return cleanMatch;
    };
    /** Override the new mergeConfig API */
    TypeScriptTask.prototype.mergeConfig = function (config) {
        throw 'Do not use mergeConfig with gulp-core-build-typescript';
    };
    TypeScriptTask.prototype._normalizeConfig = function (buildConfig) {
        if (buildConfig === void 0) { buildConfig = this.buildConfig; }
        if (!this.taskConfig.libDir) {
            this.taskConfig.libDir = buildConfig.libFolder;
        }
        if (!this.taskConfig.libAMDDir) {
            this.taskConfig.libAMDDir = buildConfig.libAMDFolder;
        }
    };
    TypeScriptTask.prototype._compileProject = function (gulp, tsProject, destDir, allStreams, result) {
        /* tslint:disable:typedef */
        var plumber = require('gulp-plumber');
        var sourcemaps = require('gulp-sourcemaps');
        /* tslint:enable:typedef */
        // tslint:disable-next-line:no-any
        var tsResult = gulp.src(this.taskConfig.sourceMatch)
            .pipe(plumber({
            errorHandler: function () {
                result.errorCount++;
            }
        }));
        if (this.taskConfig.emitSourceMaps) {
            tsResult = tsResult.pipe(sourcemaps.init());
        }
        tsResult = tsResult
            .pipe(tsProject(this.taskConfig.reporter));
        // tslint:disable-next-line:typedef
        var jsResult = (this.taskConfig.removeCommentsFromJavaScript
            ? tsResult.js.pipe(require('gulp-decomment')({
                space: !!this.taskConfig.emitSourceMaps /* turn comments into spaces to preserve sourcemaps */
            }))
            : tsResult.js);
        if (this.taskConfig.emitSourceMaps) {
            jsResult = jsResult.pipe(sourcemaps.write('.', { sourceRoot: this._resolveSourceMapRoot }));
        }
        allStreams.push(jsResult
            .pipe(gulp.dest(destDir)));
        allStreams.push(tsResult.dts.pipe(gulp.dest(destDir)));
    };
    TypeScriptTask.prototype._resolveSourceMapRoot = function (file) {
        return path.relative(file.relative, path.join(file.cwd, 'src'));
    };
    return TypeScriptTask;
}(gulp_core_build_1.GulpTask));
exports.TypeScriptTask = TypeScriptTask;

//# sourceMappingURL=TypeScriptTask.js.map
