{"version":3,"sources":["next/StreamCollator.ts"],"names":[],"mappings":"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","file":"next/StreamCollator.js","sourcesContent":["/**\r\n * @file StreamCollator.ts\r\n * @Copyright (c) Microsoft Corporation.  All rights reserved.\r\n *\r\n * A special stream which will manage the output of multiple parallel streams,\r\n * ensuring that only 1 stream is writing to the console at a given time.\r\n */\r\n/* istanbul ignore next */\r\n\r\nimport * as stream from 'stream';\r\n\r\nenum StreamState {\r\n  Open,\r\n  ClosedUnwritten,\r\n  Written\r\n}\r\n\r\nclass StreamInfo<T extends NodeJS.ReadableStream> {\r\n  public stream: T;\r\n  public state: StreamState;\r\n  public name: string;\r\n  public buffer: string[];\r\n\r\n  constructor(stream: T) {\r\n    this.stream = stream;\r\n    this.buffer = [];\r\n    this.state = StreamState.Open;\r\n  }\r\n\r\n  public flush(): string {\r\n    const data: string = this.buffer.join('');\r\n    this.buffer = [];\r\n    return data;\r\n  }\r\n}\r\n\r\n/**\r\n * A class which manages the output of multiple threads.\r\n */\r\nexport default class StreamCollator<T extends NodeJS.ReadableStream>\r\n  extends stream.Readable implements NodeJS.ReadableStream {\r\n  private _streams: StreamInfo<T>[] = [];\r\n  private _activeStream: StreamInfo<T> = undefined;\r\n\r\n  public _read(): void {\r\n    /* no-op */\r\n  };\r\n\r\n  /**\r\n   * Registers a stream into the list of active buffers.\r\n   */\r\n  public register(stream: T): void {\r\n    const streamState: StreamInfo<T> = new StreamInfo<T>(stream);\r\n\r\n    stream.on('end', this._streamEnd(streamState));\r\n    stream.on('data', this._streamData(streamState));\r\n\r\n    this._streams.push(streamState);\r\n    this._ensureActiveTask();\r\n  }\r\n\r\n  /**\r\n   * Locates a suitable stream which could be set as the new active stream\r\n   */\r\n  private _findActiveTaskCandidate(): StreamInfo<T> {\r\n    for (const stream of this._streams) {\r\n      if (stream.state === StreamState.Open && stream !== this._activeStream) {\r\n        return stream;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensures that a stream is set as active, will set the passed in stream as the active stream if none exists\r\n   */\r\n  private _ensureActiveTask(): void {\r\n    if (!this._activeStream) {\r\n      const stream: StreamInfo<T> = this._findActiveTaskCandidate();\r\n      this._activeStream = stream;\r\n\r\n      // In some cases there may be no streams which we can make active\r\n      if (stream) {\r\n        this._writeTaskBuffer(stream);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Flushes a streams buffer and writes it to disk\r\n   */\r\n  private _writeTaskBuffer(stream: StreamInfo<T>): void {\r\n    if (stream.buffer.length) {\r\n      this.push(stream.flush());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The on('data') callback handler, which either writes or buffers the data\r\n   */\r\n  private _streamData(stream: StreamInfo<T>): (data: string | Buffer) => void {\r\n    return (data: string | Buffer) => {\r\n      if (this._activeStream === stream) {\r\n        this.push(data.toString());\r\n      } else {\r\n        stream.buffer.push(data.toString());\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Marks a stream as completed. There are 3 cases:\r\n   *  - If the stream was the active stream, also write out all completed, unwritten streams\r\n   *  - If there is no active stream, write the output to the screen\r\n   *  - If there is an active stream, mark the stream as completed and wait for active stream to complete\r\n   */\r\n  private _streamEnd(stream: StreamInfo<T>): () => void {\r\n    return () => {\r\n      if (stream === this._activeStream) {\r\n        this._writeAllCompletedTasks();\r\n\r\n        stream.state = StreamState.Written;\r\n\r\n        this._activeStream = undefined;\r\n        this._ensureActiveTask();\r\n      } else {\r\n        stream.state = StreamState.ClosedUnwritten;\r\n      }\r\n\r\n      // Close this if all substreams are closed\r\n      if (this._areStreamsClosedAndWritten()) {\r\n        this.push(null); // tslint:disable-line\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Helper function which returns true if all streams have been closed\r\n   */\r\n  private _areStreamsClosedAndWritten(): boolean {\r\n    for (const streamInfo of this._streams) {\r\n      if (streamInfo.state !== StreamState.Written) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Helper function which writes all completed streams\r\n   */\r\n  private _writeAllCompletedTasks(): void {\r\n    for (const stream of this._streams) {\r\n      if (stream && stream.state === StreamState.ClosedUnwritten) {\r\n        this._writeTaskBuffer(stream);\r\n        stream.state = StreamState.Written;\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\src"}