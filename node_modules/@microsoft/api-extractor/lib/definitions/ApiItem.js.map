{"version":3,"sources":["definitions/ApiItem.ts"],"names":[],"mappings":"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","file":"definitions/ApiItem.js","sourcesContent":["/* tslint:disable:no-bitwise */\r\n/* tslint:disable:no-constant-condition */\r\n\r\nimport * as ts from 'typescript';\r\nimport Extractor from '../Extractor';\r\nimport ApiDocumentation, { ApiTag } from './ApiDocumentation';\r\nimport TypeScriptHelpers from '../TypeScriptHelpers';\r\nimport DocElementParser from '../DocElementParser';\r\n\r\n/**\r\n * Indicates the type of definition represented by a ApiItem object.\r\n */\r\nexport enum ApiItemKind {\r\n  /**\r\n    * A TypeScript class.\r\n    */\r\n  Class = 0,\r\n  /**\r\n    * A TypeScript enum.\r\n    */\r\n  Enum = 1,\r\n  /**\r\n    * A TypeScript value on an enum.\r\n    */\r\n  EnumValue = 2,\r\n  /**\r\n    * A TypeScript function.\r\n    */\r\n  Function = 3,\r\n  /**\r\n    * A TypeScript interface.\r\n    */\r\n  Interface = 4,\r\n  /**\r\n    * A TypeScript method.\r\n    */\r\n  Method = 5,\r\n  /**\r\n    * A TypeScript package.\r\n    */\r\n  Package = 6,\r\n  /**\r\n    * A TypeScript parameter.\r\n    */\r\n  Parameter = 7,\r\n  /**\r\n    * A TypeScript property.\r\n    */\r\n  Property = 8,\r\n  /**\r\n    * A TypeScript type literal expression, i.e. which defines an anonymous interface.\r\n    */\r\n  TypeLiteral = 9,\r\n  /**\r\n   * A Typescript class constructor function.\r\n   */\r\n  Constructor = 10\r\n}\r\n\r\n/**\r\n * The state of completing the ApiItem's doc comment references inside a recursive call to ApiItem.resolveReferences().\r\n */\r\nenum InitializationState {\r\n  /**\r\n   * The references of this ApiItem have not begun to be completed.\r\n   */\r\n  Incomplete = 0,\r\n  /**\r\n   * The refernces of this ApiItem are in the process of being completed.\r\n   * If we encounter this state again during completing, a circular dependency\r\n   * has occured.\r\n   */\r\n  Completing = 1,\r\n  /**\r\n   * The references of this ApiItem have all been completed and the documentation can\r\n   * now safely be created.\r\n   */\r\n  Completed = 2\r\n}\r\n\r\n/**\r\n  * This interface is used to pass options between constructors for ApiItem child classes.\r\n  */\r\nexport interface IApiItemOptions {\r\n  /**\r\n   * The associated Extractor object for this ApiItem\r\n   */\r\n  extractor: Extractor;\r\n  /**\r\n   * The declaration node for the main syntax item that this ApiItem is associated with.\r\n   */\r\n  declaration: ts.Declaration;\r\n  /**\r\n   * The semantic information for the declaration.\r\n   */\r\n  declarationSymbol: ts.Symbol;\r\n  /**\r\n   * The declaration node that contains the JSDoc comments for this ApiItem.\r\n   * In most cases this is the same as `declaration`, but for ApiPackage it will be\r\n   * a separate node under the root.\r\n   */\r\n  jsdocNode: ts.Node;\r\n  /**\r\n   * The symbol used to export this ApiItem from the ApiPackage.\r\n   */\r\n  exportSymbol?: ts.Symbol;\r\n}\r\n\r\n/**\r\n * ApiItem is an abstract base that represents TypeScript API definitions such as classes,\r\n * interfaces, enums, properties, functions, and variables.  Rather than directly using the\r\n * abstract syntax tree from the TypeScript Compiler API, we use ApiItem to extract a\r\n * simplified tree which correponds to the major topics for our API documentation.\r\n */\r\nabstract class ApiItem {\r\n  /**\r\n   * The name of the definition, as seen by external consumers of the Public API.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, the ApiItem.name would be \"_MyClass\", i.e. the alias as exported\r\n   * from the top-level ApiPackage, not \"MyClass\" from the original definition.\r\n   */\r\n  public name: string;\r\n\r\n  /**\r\n   * Indicates the type of definition represented by this ApiItem instance.\r\n   */\r\n  public kind: ApiItemKind;\r\n\r\n  /**\r\n   * A superset of memberItems. Includes memberItems and also other ApiItems that \r\n   * comprise this ApiItem. \r\n   * \r\n   * Ex: if this ApiItem is an ApiFunction, then in it's innerItems would\r\n   * consist of ApiParameters. \r\n   * Ex: if this ApiItem is an ApiMember that is a type literal, then it's \r\n   * innerItems would contain ApiProperties. \r\n   */\r\n  public innerItems: ApiItem[] = [];\r\n\r\n  /**\r\n   * True if this ApiItem either itself has missing type information or one \r\n   * of it's innerItems is missing type information. \r\n   * \r\n   * Ex: if this ApiItem is an ApiMethod and has no type on the return value, then \r\n   * we consider the ApiItem as 'itself' missing type informations and this property \r\n   * is set to true. \r\n   * Ex: If this ApiItem is an ApiMethod and one of its innerItems is an ApiParameter \r\n   * that has no type specified, then we say an innerItem of this ApiMethod is missing\r\n   * type information and this property is set to true.\r\n   */\r\n  public hasIncompleteTypes: boolean = false;\r\n\r\n  /**\r\n   * A list of extractor warnings that were reported using ApiItem.reportWarning().\r\n   * Whereas an \"error\" will break the build, a \"warning\" will merely be tracked in\r\n   * the API file produced by ApiFileGenerator.\r\n   */\r\n  public warnings: string[];\r\n\r\n  /**\r\n   * The declaration node that contains the JSDoc comments for this ApiItem.\r\n   * In most cases this is the same as `declaration`, but for ApiPackage it will be\r\n   * a separate node under the root.\r\n   */\r\n  public jsdocNode: ts.Node;\r\n\r\n  public documentation: ApiDocumentation;\r\n\r\n  /**\r\n   * Indicates that this ApiItem does not have adequate JSDoc comments. If shouldHaveDocumentation()=true,\r\n   * and there is less than 10 characters of summary text in the JSDoc, then this will be set to true and \r\n   * noted in the API file produced by ApiFileGenerator.  \r\n   * (The JSDoc text itself is not included in that report, because documentation\r\n   * changes do not require an API review, and thus should not cause a diff for that report.)\r\n   */\r\n  public needsDocumentation: boolean;\r\n\r\n  /**\r\n   * The Extractor object that acts as the root of the abstract syntax tree that this item belongs to.\r\n   */\r\n  protected extractor: Extractor;\r\n\r\n  /**\r\n   * Syntax information from the TypeScript Compiler API, corresponding to the place\r\n   * where this object is originally defined.\r\n   */\r\n  protected declaration: ts.Declaration;\r\n\r\n  /**\r\n   * Semantic information from the TypeScript Compiler API, corresponding to the place\r\n   * where this object is originally defined.\r\n   */\r\n  protected declarationSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * Semantic information from the TypeScript Compiler API, corresponding to the symbol\r\n   * that is seen by external consumers of the Public API.  For an aliased symbol, this\r\n   * would be the alias that is exported from the top-level package (i.e. ApiPackage).\r\n   */\r\n  protected exportSymbol: ts.Symbol;\r\n\r\n  protected typeChecker: ts.TypeChecker;\r\n\r\n  /**\r\n   * Syntax information from the TypeScript Compiler API, used to locate the file name\r\n   * and line number when reporting an error for this ApiItem.\r\n   */\r\n  private _errorNode: ts.Node;\r\n\r\n  /**\r\n   * The state of this ApiItems references. These references could include \\@inheritdoc references\r\n   * or type references.\r\n   */\r\n  private _state: InitializationState;\r\n\r\n  constructor(options: IApiItemOptions) {\r\n    this.reportError = this.reportError.bind(this);\r\n\r\n    this.jsdocNode = options.jsdocNode;\r\n    this.declaration = options.declaration;\r\n    this._errorNode = options.declaration;\r\n    this._state = InitializationState.Incomplete;\r\n    this.warnings = [];\r\n\r\n    this.extractor = options.extractor;\r\n    this.declarationSymbol = options.declarationSymbol;\r\n    this.exportSymbol = options.exportSymbol || this.declarationSymbol;\r\n\r\n    this.name = this.exportSymbol.name || '???';\r\n    this.typeChecker = this.extractor.typeChecker;\r\n\r\n    let originalJsDoc: string = '';\r\n    if (this.jsdocNode) {\r\n      originalJsDoc = TypeScriptHelpers.getJsDocComments(this.jsdocNode, this.reportError);\r\n    }\r\n\r\n    this.documentation = new ApiDocumentation(\r\n      originalJsDoc,\r\n      this.extractor.docItemLoader,\r\n      this.extractor,\r\n      this.reportError\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the compiler's underlying Declaration object\r\n   * @todo Generally ApiItem classes don't expose ts API objects; we should add\r\n   *       an appropriate member to avoid the need for this.\r\n   */\r\n  public getDeclaration(): ts.Declaration {\r\n    return this.declaration;\r\n  }\r\n\r\n  /**\r\n   * Return the compiler's underlying Symbol object that contains semantic information about the item\r\n   * @todo Generally ApiItem classes don't expose ts API objects; we should add\r\n   *       an appropriate member to avoid the need for this.\r\n   */\r\n  public getDeclarationSymbol(): ts.Symbol {\r\n    return this.declarationSymbol;\r\n  }\r\n\r\n  /**\r\n   * Whether this APiItem should have documentation or not.  If false, then\r\n   * ApiItem.missingDocumentation will never be set.\r\n   */\r\n  public shouldHaveDocumentation(): boolean {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * This traverses any type aliases to find the original place where an item was defined.\r\n   * For example, suppose a class is defined as \"export default class MyClass { }\"\r\n   * but exported from the package's index.ts like this:\r\n   *\r\n   *    export { default as _MyClass } from './MyClass';\r\n   *\r\n   * In this example, calling followAliases() on the _MyClass symbol will return the\r\n   * original definition of MyClass, traversing any intermediary places where the\r\n   * symbol was imported and re-exported.\r\n   */\r\n  protected followAliases(symbol: ts.Symbol): ts.Symbol {\r\n    let current: ts.Symbol = symbol;\r\n    while (true) {\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) {\r\n        break;\r\n      }\r\n      const currentAlias: ts.Symbol = this.typeChecker.getAliasedSymbol(current);\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n      current = currentAlias;\r\n    }\r\n\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Reports an error through the ApiErrorHandler interface that was registered with the Extractor,\r\n   * adding the filename and line number information for the declaration of this ApiItem.\r\n   */\r\n  protected reportError(message: string): void {\r\n    this.extractor.reportError(message, this._errorNode.getSourceFile(), this._errorNode.getStart());\r\n  }\r\n\r\n /**\r\n   * Adds a warning to the ApiItem.warnings list.  These warnings will be emtted in the API file\r\n   * produced by ApiFileGenerator.\r\n   */\r\n  protected reportWarning(message: string): void {\r\n    this.warnings.push(message);\r\n  }\r\n\r\n  /**\r\n   * This function assumes all references from this ApiItem have been resolved and we can now safely create\r\n   * the documentation.\r\n   */\r\n  protected onCompleteInitialization(): void {\r\n\r\n    this.documentation.completeInitialization();\r\n    // TODO: this.collectTypeReferences(this);\r\n\r\n    const summaryTextCondensed: string = DocElementParser.getAsText(\r\n      this.documentation.summary,\r\n      this.reportError).replace(/\\s\\s/g, ' ');\r\n    this.needsDocumentation = this.shouldHaveDocumentation() && summaryTextCondensed.length <= 10;\r\n\r\n    if (this.kind === ApiItemKind.Package) {\r\n      if (this.documentation.apiTag !== ApiTag.None) {\r\n        const tag: string = '@' + ApiTag[this.documentation.apiTag].toLowerCase();\r\n        this.reportError(`The ${tag} tag is not allowed on the package, which is always public`);\r\n      }\r\n      this.documentation.apiTag = ApiTag.Public;\r\n    }\r\n\r\n    if (this.documentation.preapproved) {\r\n      if (!(this.getDeclaration().kind & (ts.SyntaxKind.InterfaceDeclaration | ts.SyntaxKind.ClassDeclaration))) {\r\n        this.reportError('The @preapproved tag may only be applied to classes and interfaces');\r\n        this.documentation.preapproved = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This function is a second stage that happens after Extractor.analyze() calls ApiItem constructor to build up\r\n   * the abstract syntax tree. In this second stage, we are creating the documentation for each ApiItem.\r\n   *\r\n   * This function makes sure we create the documentation for each ApiItem in the correct order.\r\n   * In the event that a circular dependency occurs, an error is reported. For example, if ApiItemOne has\r\n   * an \\@inheritdoc referencing ApiItemTwo, and ApiItemTwo has an \\@inheritdoc refercing ApiItemOne then\r\n   * we have a circular dependency and an error will be reported.\r\n   */\r\n  public completeInitialization(): void {\r\n    switch (this._state) {\r\n      case InitializationState.Completed:\r\n        return;\r\n      case InitializationState.Incomplete:\r\n        this._state = InitializationState.Completing;\r\n        this.onCompleteInitialization();\r\n        this._state = InitializationState.Completed;\r\n\r\n        for (const innerItem of this.innerItems) {\r\n          innerItem.completeInitialization();\r\n        }\r\n        return;\r\n      case InitializationState.Completing:\r\n        this.reportError('circular reference');\r\n        return;\r\n      default:\r\n        throw new Error('ApiItem state is invalid');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A procedure for determining if this ApiItem is missing type \r\n   * information. We first check if the ApiItem itself is missing \r\n   * any type information and if not then we check each of it's \r\n   * innerItems for missing types. \r\n   * \r\n   * Ex: On the ApiItem itself, there may be missing type information \r\n   * on the return value or missing type declaration of itself \r\n   * (const name;).\r\n   * Ex: For each innerItem, there may be an ApiParameter that is missing \r\n   * a type. Or for an ApiMember that is a type literal, there may be an \r\n   * ApiProperty that is missing type information. \r\n   */\r\n  public hasAnyIncompleteTypes(): boolean {\r\n    if (this.hasIncompleteTypes) {\r\n      return true;\r\n    }\r\n    for (const innerItem of this.innerItems) {\r\n      if (innerItem.hasIncompleteTypes) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\nexport default ApiItem;\r\n"],"sourceRoot":"..\\..\\src"}