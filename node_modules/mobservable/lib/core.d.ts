import { Lambda, IObservableArray, IObservableValue, IContextInfoStruct, IArrayChange, IArraySplice, IObjectChange } from './interfaces';
import { ObservableValue } from './observablevalue';
import { ObservableView } from './observableview';
import { ObservableMap, KeyValueMap } from './observablemap';
export declare function observable(target: Object, key: string, baseDescriptor?: PropertyDescriptor): any;
export declare function observable<T>(value: T[]): IObservableArray<T>;
export declare function observable<T, S extends Object>(value: () => T, thisArg?: S): IObservableValue<T>;
export declare function observable<T extends string | number | boolean | Date | RegExp | Function | void>(value: T): IObservableValue<T>;
export declare function observable<T extends Object>(value: T): T;
export declare function map<V>(initialValues?: KeyValueMap<V>, valueModifier?: Function): ObservableMap<V>;
export declare function fastArray<V>(initialValues?: V[]): IObservableArray<V>;
export declare function asReference<T>(value: T): T;
export declare function asStructure<T>(value: T): T;
export declare function asFlat<T>(value: T): T;
export declare function isObservable(value: any, property?: string): boolean;
export declare function autorun(view: Lambda, scope?: any): Lambda;
export declare function autorunUntil(predicate: () => boolean, effect: Lambda, scope?: any): Lambda;
export declare function autorunAsync<T>(view: () => T, effect: (latestValue: T) => void, delay?: number, scope?: any): Lambda;
export declare function autorunAsync(func: Lambda, delay?: number, scope?: any): Lambda;
export declare function expr<T>(expr: () => T, scope?: any): T;
export declare function extendObservable<A extends Object, B extends Object>(target: A, ...properties: B[]): A & B;
export declare function toJSON(source: any, detectCycles?: boolean, __alreadySeen?: [any, any][]): any;
export declare function getStrict(): boolean;
export declare function withStrict(newStrict: boolean, func: Lambda): void;
export declare enum ValueType {
    Reference = 0,
    PlainObject = 1,
    ComplexObject = 2,
    Array = 3,
    ViewFunction = 4,
    ComplexFunction = 5,
}
export declare enum ValueMode {
    Recursive = 0,
    Reference = 1,
    Structure = 2,
    Flat = 3,
}
export declare function getTypeOfValue(value: any): ValueType;
export declare function extendObservableHelper(target: any, properties: any, mode: ValueMode, context: IContextInfoStruct): Object;
export declare function toGetterSetterFunction<T>(observable: ObservableValue<T> | ObservableView<T>): IObservableValue<T>;
export declare class AsReference {
    value: any;
    constructor(value: any);
}
export declare class AsStructure {
    value: any;
    constructor(value: any);
}
export declare class AsFlat {
    value: any;
    constructor(value: any);
}
export declare function getValueModeFromValue(value: any, defaultMode: ValueMode): [ValueMode, any];
export declare function getValueModeFromModifierFunc(func?: Function): ValueMode;
export declare function makeChildObservable(value: any, parentMode: ValueMode, context: any): any;
export declare function assertUnwrapped(value: any, message: any): void;
export declare function isObservableObject(thing: any): boolean;
export declare function isObservableArray(thing: any): boolean;
export declare function isObservableMap(thing: any): boolean;
export declare function observe<T>(observableArray: IObservableArray<T>, listener: (change: IArrayChange<T> | IArraySplice<T>) => void): Lambda;
export declare function observe<T>(observableMap: ObservableMap<T>, listener: (change: IObjectChange<T, ObservableMap<T>>) => void): Lambda;
export declare function observe(func: () => void): Lambda;
export declare function observe<T extends Object>(object: T, listener: (change: IObjectChange<any, T>) => void): Lambda;
export declare function observe<T extends Object, Y>(object: T, prop: string, listener: (newValue: Y, oldValue?: Y) => void): Lambda;
