// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
var path = require("path");
var PackageDependencyKind;
(function (PackageDependencyKind) {
    PackageDependencyKind[PackageDependencyKind["Normal"] = 0] = "Normal";
    /**
     * The dependency was listed in the optionalDependencies section of package.json.
     */
    PackageDependencyKind[PackageDependencyKind["Optional"] = 1] = "Optional";
    /**
     * The dependency should be a symlink to a project that is locally built by Rush..
     */
    PackageDependencyKind[PackageDependencyKind["LocalLink"] = 2] = "LocalLink";
})(PackageDependencyKind = exports.PackageDependencyKind || (exports.PackageDependencyKind = {}));
var Package = (function () {
    function Package(name, version, dependencies, folderPath) {
        /**
         * If this is a local path that we are planning to symlink to a target folder,
         * then symlinkTargetFolderPath keeps track of the intended target.
         */
        this.symlinkTargetFolderPath = undefined;
        /**
         * If this was loaded using createFromNpm(), then the parsed package.json is stored here.
         */
        this.originalPackageJson = undefined;
        this.name = name;
        this.version = version;
        this.dependencies = dependencies.slice(0); // clone the array
        this.folderPath = folderPath;
        this.parent = undefined;
        this.children = [];
        this._childrenByName = new Map();
    }
    /**
     * Recursive constructs a tree of Package objects using information returned
     * by the "read-package-tree" library.
     */
    Package.createFromNpm = function (npmPackage) {
        if (npmPackage.error) {
            throw Error("Failed to parse package.json for " + path.basename(npmPackage.path) + ": "
                + npmPackage.error.message);
        }
        var dependencies = [];
        var dependencyNames = new Set();
        var packageJson = npmPackage.package;
        if (packageJson.optionalDependencies) {
            for (var _i = 0, _a = Object.keys(packageJson.optionalDependencies); _i < _a.length; _i++) {
                var dependencyName = _a[_i];
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.optionalDependencies[dependencyName],
                        kind: PackageDependencyKind.Optional
                    });
                }
            }
        }
        if (packageJson.dependencies) {
            for (var _b = 0, _c = Object.keys(packageJson.dependencies); _b < _c.length; _b++) {
                var dependencyName = _c[_b];
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.dependencies[dependencyName],
                        kind: PackageDependencyKind.Normal
                    });
                }
            }
        }
        if (packageJson.rushDependencies) {
            for (var _d = 0, _e = Object.keys(packageJson.rushDependencies); _d < _e.length; _d++) {
                var dependencyName = _e[_d];
                if (!dependencyNames.has(dependencyName)) {
                    dependencyNames.add(dependencyName);
                    dependencies.push({
                        name: dependencyName,
                        versionRange: packageJson.dependencies[dependencyName],
                        kind: PackageDependencyKind.LocalLink
                    });
                }
            }
        }
        dependencies = dependencies.sort(function (a, b) { return a.name.localeCompare(b.name); });
        var newPackage = new Package(npmPackage.package.name, npmPackage.package.version, dependencies, 
        // NOTE: We don't use packageNode.realpath here, because if "npm unlink" was
        // performed without redoing "rush link", then a broken symlink is better than
        // a symlink to the wrong thing.
        npmPackage.path);
        newPackage.originalPackageJson = packageJson;
        for (var _f = 0, _g = npmPackage.children; _f < _g.length; _f++) {
            var child = _g[_f];
            newPackage.addChild(Package.createFromNpm(child));
        }
        return newPackage;
    };
    Object.defineProperty(Package.prototype, "nameAndVersion", {
        get: function () {
            var result = '';
            if (this.name) {
                result += this.name;
            }
            else {
                result += '(missing name)';
            }
            result += '@';
            if (this.version) {
                result += this.version;
            }
            else {
                result += '(missing version)';
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Package.prototype.addChild = function (child) {
        if (child.parent) {
            throw Error('Child already has a parent');
        }
        if (this._childrenByName.has(child.name)) {
            throw Error('Child already exists');
        }
        child.parent = this;
        this.children.push(child);
        this._childrenByName.set(child.name, child);
    };
    Package.prototype.getChildByName = function (childPackageName) {
        return this._childrenByName.get(childPackageName);
    };
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  Note that the nearest match may have an incompatible version.
     * If a match is found, then the "found" result will not be undefined.
     * In either case, the parentForCreate result indicates where the missing
     * dependency can be added, i.e. if the requested dependency was not found
     * or was found with an incompatible version.
     *
     * "cyclicSubtreeRoot" is a special optional parameter that specifies a different
     * root for the tree; the cyclicDependencyProjects feature uses this to isolate
     * certain devDependencies in their own subtree.
     */
    Package.prototype.resolveOrCreate = function (dependencyName, cyclicSubtreeRoot) {
        var currentParent = this;
        var parentForCreate = undefined;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            // Does any child match?
            for (var _i = 0, _a = currentParent.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.name === dependencyName) {
                    // One of the children matched.  Note that parentForCreate may be
                    // undefined, e.g. if an immediate child is found but has the wrong version,
                    // then we have no place in the tree to create another version.
                    return { found: child, parentForCreate: parentForCreate };
                }
            }
            // If no child matched, then make this node the "parentForCreate" where we
            // could add a missing dependency.
            parentForCreate = currentParent;
            if (!currentParent.parent
                || (cyclicSubtreeRoot && currentParent === cyclicSubtreeRoot)) {
                // We reached the root without finding a match
                // parentForCreate will be the root.
                return { found: undefined, parentForCreate: parentForCreate };
            }
            // Continue walking upwards.
            currentParent = currentParent.parent;
        }
    };
    /**
     * Searches the node_modules hierarchy for the nearest matching package with the
     * given name.  If no match is found, then undefined is returned.
     */
    Package.prototype.resolve = function (dependencyName) {
        return this.resolveOrCreate(dependencyName).found;
    };
    Package.prototype.printTree = function (indent) {
        if (!indent) {
            indent = '';
        }
        console.log(indent + this.nameAndVersion);
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            child.printTree(indent + '  ');
        }
    };
    return Package;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Package;

//# sourceMappingURL=Package.js.map
