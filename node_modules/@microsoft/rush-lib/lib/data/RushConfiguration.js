// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
"use strict";
var path = require("path");
var fsx = require("fs-extra");
var os = require("os");
var semver = require("semver");
var rushVersion_1 = require("../rushVersion");
var Validator = require("z-schema");
var JsonFile_1 = require("../utilities/JsonFile");
var RushConfigurationProject_1 = require("./RushConfigurationProject");
var Utilities_1 = require("../utilities/Utilities");
/**
 * This represents the Rush configuration for a repository, based on the Rush.json
 * configuration file.
 */
var RushConfiguration = (function () {
    /**
     * DO NOT CALL -- Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    function RushConfiguration(rushConfigurationJson, rushJsonFilename) {
        var _this = this;
        if (rushConfigurationJson.nodeSupportedVersionRange) {
            if (!semver.validRange(rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error('Error parsing the node-semver expression in the "nodeSupportedVersionRange"'
                    + (" field from rush.json: \"" + rushConfigurationJson.nodeSupportedVersionRange + "\""));
            }
            if (!semver.satisfies(process.version, rushConfigurationJson.nodeSupportedVersionRange)) {
                throw new Error("Your dev environment is running Node.js version " + process.version + " which does"
                    + " not meet the requirements for building this repository.  (The rush.json configuration"
                    + (" requires nodeSupportedVersionRange=\"" + rushConfigurationJson.nodeSupportedVersionRange + "\")"));
            }
        }
        this._rushJsonFolder = path.dirname(rushJsonFilename);
        this._commonFolder = path.resolve(path.join(this._rushJsonFolder, rushConfigurationJson.commonFolder));
        if (!fsx.existsSync(this._commonFolder)) {
            throw new Error("Rush common folder does not exist: " + rushConfigurationJson.commonFolder);
        }
        this._commonFolderName = path.basename(this._commonFolder);
        if (rushConfigurationJson.useLocalNpmCache) {
            this._cacheFolder = path.resolve(path.join(this._commonFolder, 'npm-cache'));
            this._tmpFolder = path.resolve(path.join(this._commonFolder, 'npm-tmp'));
        }
        this._tempModulesFolder = path.join(this._commonFolder, 'temp_modules');
        var unresolvedUserFolder = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];
        this._homeFolder = path.resolve(unresolvedUserFolder);
        if (!fsx.existsSync(this._homeFolder)) {
            throw new Error('Unable to determine the current user\'s home directory');
        }
        this._rushLinkJsonFilename = path.join(this._commonFolder, 'rush-link.json');
        this._npmToolVersion = rushConfigurationJson.npmVersion;
        this._npmToolFilename = path.join(this._commonFolder, 'npm-local', 'node_modules', '.bin', 'npm');
        this._projectFolderMinDepth = rushConfigurationJson.projectFolderMinDepth !== undefined
            ? rushConfigurationJson.projectFolderMinDepth : 1;
        if (this._projectFolderMinDepth < 1) {
            throw new Error('Invalid projectFolderMinDepth; the minimum possible value is 1');
        }
        this._projectFolderMaxDepth = rushConfigurationJson.projectFolderMaxDepth !== undefined
            ? rushConfigurationJson.projectFolderMaxDepth : 2;
        if (this._projectFolderMaxDepth < this._projectFolderMinDepth) {
            throw new Error('The projectFolderMaxDepth cannot be smaller than the projectFolderMinDepth');
        }
        this._packageReviewFile = undefined;
        if (rushConfigurationJson.packageReviewFile) {
            this._packageReviewFile = path.resolve(path.join(this._rushJsonFolder, rushConfigurationJson.packageReviewFile));
            if (!fsx.existsSync(this._packageReviewFile)) {
                throw new Error('The packageReviewFile file was not found: "' + this._packageReviewFile + '"');
            }
        }
        this._reviewCategories = new Set(rushConfigurationJson.reviewCategories);
        this._gitAllowedEmailRegExps = [];
        this._gitSampleEmail = '';
        if (rushConfigurationJson.gitPolicy) {
            if (rushConfigurationJson.gitPolicy.sampleEmail) {
                this._gitSampleEmail = rushConfigurationJson.gitPolicy.sampleEmail;
            }
            if (rushConfigurationJson.gitPolicy.allowedEmailRegExps) {
                this._gitAllowedEmailRegExps = rushConfigurationJson.gitPolicy.allowedEmailRegExps;
                if (this._gitSampleEmail.trim().length < 1) {
                    throw new Error('The rush.json file is missing the "sampleEmail" option, ' +
                        'which is required when using "allowedEmailRegExps"');
                }
            }
        }
        this._projects = [];
        this._projectsByName = new Map();
        // We sort the projects array in alphabetical order.  This ensures that the packages
        // are processed in a deterministic order by the various Rush algorithms.
        var sortedProjectJsons = rushConfigurationJson.projects.slice(0);
        sortedProjectJsons.sort(function (a, b) { return a.packageName.localeCompare(b.packageName); });
        var tempNamesByProject = RushConfiguration._generateTempNamesForProjects(sortedProjectJsons);
        for (var _i = 0, sortedProjectJsons_1 = sortedProjectJsons; _i < sortedProjectJsons_1.length; _i++) {
            var projectJson = sortedProjectJsons_1[_i];
            var tempProjectName = tempNamesByProject.get(projectJson);
            var project = new RushConfigurationProject_1.default(projectJson, this, tempProjectName);
            this._projects.push(project);
            if (this._projectsByName.get(project.packageName)) {
                throw new Error("The project name \"" + project.packageName + "\" was specified more than once"
                    + " in the rush.json configuration file.");
            }
            this._projectsByName.set(project.packageName, project);
        }
        var _loop_1 = function (project) {
            project.cyclicDependencyProjects.forEach(function (cyclicDependencyProject) {
                if (!_this.getProjectByName(cyclicDependencyProject)) {
                    throw new Error("In rush.json, the \"" + cyclicDependencyProject + "\" project does not exist,"
                        + (" but was referenced by the cyclicDependencyProjects for " + project.packageName));
                }
            });
            // Compute the downstream dependencies within the list of Rush projects.
            this_1._populateDownstreamDependencies(project.packageJson.dependencies, project.packageName);
            this_1._populateDownstreamDependencies(project.packageJson.devDependencies, project.packageName);
        };
        var this_1 = this;
        for (var _a = 0, _b = this._projects; _a < _b.length; _a++) {
            var project = _b[_a];
            _loop_1(project);
        }
    }
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    RushConfiguration.loadFromConfigurationFile = function (rushJsonFilename) {
        var rushConfigurationJson = JsonFile_1.default.loadJsonFile(rushJsonFilename);
        // Check the Rush version *before* we validate the schema, since if the version is outdated
        // then the schema may have changed.
        var rushMinimumVersion = rushConfigurationJson.rushMinimumVersion;
        // If the version is missing or malformed, fall through and let the schema handle it.
        if (rushMinimumVersion && semver.valid(rushMinimumVersion)) {
            if (semver.lt(rushVersion_1.default, rushMinimumVersion)) {
                throw new Error("Your rush tool is version " + rushVersion_1.default + ", but rush.json"
                    + (" requires version " + rushConfigurationJson.rushMinimumVersion + " or newer.  To upgrade,")
                    + " run \"npm install @microsoft/rush -g\".");
            }
        }
        // Remove the $schema reference that appears in the configuration object (used for IntelliSense),
        // since we are replacing it with the precompiled version.  The validator.setRemoteReference()
        // API is a better way to handle this, but we'd first need to publish the schema file
        // to a public web server where Visual Studio can find it.
        delete rushConfigurationJson.$schema;
        var validator = new Validator({
            breakOnFirstError: true,
            noTypeless: true
        });
        var rushSchema = JsonFile_1.default.loadJsonFile(path.join(__dirname, '../rush-schema.json'));
        if (!validator.validate(rushConfigurationJson, rushSchema)) {
            var error = validator.getLastError();
            var detail = error.details[0];
            var errorMessage = "Error parsing file '" + path.basename(rushJsonFilename) + "',"
                + ("section[" + detail.path + "]:" + os.EOL + "(" + detail.code + ") " + detail.message);
            console.log(os.EOL + 'ERROR: ' + errorMessage + os.EOL + os.EOL);
            throw new Error(errorMessage);
        }
        return new RushConfiguration(rushConfigurationJson, rushJsonFilename);
    };
    RushConfiguration.loadFromDefaultLocation = function () {
        var currentFolder = process.cwd();
        // Look upwards at parent folders until we find a folder containing rush.json
        for (var i = 0; i < 10; ++i) {
            var rushJsonFilename = path.join(currentFolder, 'rush.json');
            if (fsx.existsSync(rushJsonFilename)) {
                if (i > 0) {
                    console.log('Found configuration in ' + rushJsonFilename);
                }
                console.log('');
                return RushConfiguration.loadFromConfigurationFile(rushJsonFilename);
            }
            var parentFolder = path.dirname(currentFolder);
            if (parentFolder === currentFolder) {
                break;
            }
            currentFolder = parentFolder;
        }
        throw new Error('Unable to find rush.json configuration file');
    };
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    RushConfiguration._generateTempNamesForProjects = function (sortedProjectJsons) {
        var tempNamesByProject = new Map();
        var usedTempNames = new Set();
        // NOTE: projectJsons was already sorted in alphabetical order by the caller.
        for (var _i = 0, sortedProjectJsons_2 = sortedProjectJsons; _i < sortedProjectJsons_2.length; _i++) {
            var projectJson = sortedProjectJsons_2[_i];
            // If the name is "@ms/MyProject", extract the "MyProject" part
            var unscopedName = Utilities_1.default.parseScopedPackageName(projectJson.packageName).name;
            // Generate a unique like name "rush-MyProject", or "rush-MyProject-2" if
            // there is a naming conflict
            var counter = 0;
            var tempProjectName = 'rush-' + unscopedName;
            while (usedTempNames.has(tempProjectName)) {
                ++counter;
                tempProjectName = 'rush-' + unscopedName + '-' + counter;
            }
            usedTempNames.add(tempProjectName);
            tempNamesByProject.set(projectJson, tempProjectName);
        }
        return tempNamesByProject;
    };
    Object.defineProperty(RushConfiguration.prototype, "rushJsonFolder", {
        /**
         * The folder that contains rush.json for this project.
         */
        get: function () {
            return this._rushJsonFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "commonFolder", {
        /**
         * The common folder specified in rush.json.  By default, this is the fully
         * resolved path for a subfolder of rushJsonFolder whose name is "common".
         * Example: "C:\MyRepo\common"
         */
        get: function () {
            return this._commonFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "commonFolderName", {
        /**
         * This is how we refer to the common folder, e.g. in error messages.
         * For example if commonFolder is "C:\MyRepo\common" then
         * commonFolderName="common".
         */
        get: function () {
            return this._commonFolderName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "cacheFolder", {
        /**
         * The cache folder specified in rush.json. If no folder is specified, this
         * value is undefined.
         * Example: "C:\MyRepo\common\npm-cache"
         */
        get: function () {
            return this._cacheFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "tmpFolder", {
        /**
         * The tmp folder specified in rush.json. If no folder is specified, this
         * value is undefined.
         * Example: "C:\MyRepo\common\npm-tmp"
         */
        get: function () {
            return this._tmpFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "tempModulesFolder", {
        /**
         * The folder containing the temp packages generated by "rush generate".
         * Example: "C:\MyRepo\common\temp_modules"
         */
        get: function () {
            return this._tempModulesFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "homeFolder", {
        /**
         * The absolute path to the home directory for the current user.  On Windows,
         * it would be something like "C:\Users\YourName".
         */
        get: function () {
            return this._homeFolder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "rushLinkJsonFilename", {
        /**
         * The filename of the build dependency data file.  By default this is
         * called 'rush-link.json' resides in the Rush common folder.
         * Its data structure is defined by IRushLinkJson.
         */
        get: function () {
            return this._rushLinkJsonFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmToolVersion", {
        /**
         * The version of the locally installed NPM tool.  (Example: "1.2.3")
         */
        get: function () {
            return this._npmToolVersion;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "npmToolFilename", {
        /**
         * The absolute path to the locally installed NPM tool.  If "rush install" has not
         * been run, then this file may not exist yet.
         * Example: "C:\MyRepo\common\npm-local\node_modules\.bin\npm"
         */
        get: function () {
            return this._npmToolFilename;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectFolderMinDepth", {
        /**
         * The minimum allowable folder depth for the projectFolder field in the rush.json file.
         * This setting provides a way for repository maintainers to discourage nesting of project folders
         * that makes the directory tree more difficult to navigate.  The default value is 2,
         * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
         */
        get: function () {
            return this._projectFolderMinDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectFolderMaxDepth", {
        /**
         * The maximum allowable folder depth for the projectFolder field in the rush.json file.
         * This setting provides a way for repository maintainers to discourage nesting of project folders
         * that makes the directory tree more difficult to navigate.  The default value is 2,
         * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
         */
        get: function () {
            return this._projectFolderMaxDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "packageReviewFile", {
        /**
         * The absolute path to a JSON file that tracks the NPM packages that were approved for usage
         * in this repository.  This is part of an optional approval workflow, whose purpose is to
         * review any new dependencies that are introduced (e.g. maybe a legal review is required, or
         * maybe we are trying to minimize bloat).  When "rush generate" is run, any new
         * package.json dependencies will be appended to this file.  When "rush install" is run
         * (e.g. as part of a PR build), an error will be reported if the file is not up to date.
         * The intent is that this file will be stored in Git and tracked by a branch policy which
         * notifies reviewers whenever a PR attempts to modify the file.
         *
         * The PackageReviewConfiguration class can load/save this file format.
         *
         * Example: "C:\MyRepo\common\reviews\PackageDependenies.json"
         */
        get: function () {
            return this._packageReviewFile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "reviewCategories", {
        /**
         * A list of category names that are valid for usage as the RushConfigurationProject.reviewCategory field.
         * This array will never be undefined.
         */
        get: function () {
            return this._reviewCategories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "gitAllowedEmailRegExps", {
        /**
         * A list of regular expressions describing allowable e-mail patterns for Git commits.
         * They are case-insensitive anchored JavaScript RegExps.
         * Example: ".*@example\.com"
         * This array will never be undefined.
         */
        get: function () {
            return this._gitAllowedEmailRegExps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "gitSampleEmail", {
        /**
         * An example valid e-mail address that conforms to one of the allowedEmailRegExps.
         * Example: "foxtrot@example\.com"
         * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
         */
        get: function () {
            return this._gitSampleEmail;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projects", {
        get: function () {
            return this._projects;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RushConfiguration.prototype, "projectsByName", {
        get: function () {
            return this._projectsByName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    RushConfiguration.prototype.getProjectByName = function (projectName) {
        return this._projectsByName.get(projectName);
    };
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like "@something/example".  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    RushConfiguration.prototype.findProjectByShorthandName = function (shorthandProjectName) {
        // Is there an exact match?
        var result = this._projectsByName.get(shorthandProjectName);
        if (result) {
            return result;
        }
        // Is there an approximate match?
        for (var _i = 0, _a = this._projects; _i < _a.length; _i++) {
            var project = _a[_i];
            if (Utilities_1.default.parseScopedPackageName(project.packageName).name === shorthandProjectName) {
                if (result) {
                    // Ambiguous -- there is more than one match
                    return undefined;
                }
                else {
                    result = project;
                }
            }
        }
        return result;
    };
    RushConfiguration.prototype._populateDownstreamDependencies = function (dependencies, packageName) {
        var _this = this;
        if (!dependencies) {
            return;
        }
        Object.keys(dependencies).forEach(function (dependencyName) {
            var depProject = _this._projectsByName.get(dependencyName);
            if (depProject) {
                depProject.downstreamDependencyProjects.push(packageName);
            }
        });
    };
    return RushConfiguration;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RushConfiguration;

//# sourceMappingURL=RushConfiguration.js.map
