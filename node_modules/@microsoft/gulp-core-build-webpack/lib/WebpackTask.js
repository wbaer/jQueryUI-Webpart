"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var gulp_core_build_1 = require("@microsoft/gulp-core-build");
var os_1 = require("os");
var WebpackTask = (function (_super) {
    __extends(WebpackTask, _super);
    function WebpackTask() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'webpack';
        _this.taskConfig = {
            configPath: './webpack.config.js',
            suppressWarnings: []
        };
        return _this;
    }
    Object.defineProperty(WebpackTask.prototype, "resources", {
        get: function () {
            if (!this._resources) {
                this._resources = {
                    webpack: require('webpack')
                };
            }
            return this._resources;
        },
        enumerable: true,
        configurable: true
    });
    WebpackTask.prototype.isEnabled = function (buildConfig) {
        return (_super.prototype.isEnabled.call(this, buildConfig) &&
            this.taskConfig.configPath !== null // tslint:disable-line:no-null-keyword
        );
    };
    WebpackTask.prototype.loadSchema = function () {
        return require('./webpack.schema.json');
    };
    WebpackTask.prototype.executeTask = function (gulp, completeCallback) {
        var _this = this;
        var shouldInitWebpack = (process.argv.indexOf('--initwebpack') > -1);
        /* tslint:disable:typedef */
        var path = require('path');
        /* tslint:enabled:typedef */
        if (shouldInitWebpack) {
            this.log('Initializing a webpack.config.js, which bundles lib/index.js ' +
                'into dist/packagename.js into a UMD module.');
            this.copyFile(path.resolve(__dirname, '..', 'webpack.config.js'));
            completeCallback();
        }
        else {
            var webpackConfig = void 0;
            if (this.taskConfig.configPath && this.fileExists(this.taskConfig.configPath)) {
                try {
                    webpackConfig = require(this.resolvePath(this.taskConfig.configPath));
                }
                catch (err) {
                    completeCallback("Error parsing webpack config: " + this.taskConfig.configPath + ": " + err);
                    return;
                }
            }
            else if (this.taskConfig.config) {
                webpackConfig = this.taskConfig.config;
            }
            else {
                this._logMissingConfigWarning();
                completeCallback();
                return;
            }
            if (webpackConfig) {
                var webpack = this.taskConfig.webpack || require('webpack');
                var gutil_1 = require('gulp-util');
                var startTime_1 = new Date().getTime();
                var outputDir_1 = this.buildConfig.distFolder;
                webpack(webpackConfig, function (error, stats) {
                    if (!_this.buildConfig.properties) {
                        _this.buildConfig.properties = {};
                    }
                    /* tslint:disable:no-string-literal */
                    _this.buildConfig.properties['webpackStats'] = stats;
                    /* tslint:enable:no-string-literal */
                    var statsResult = stats.toJson({
                        hash: false,
                        source: false
                    });
                    if (statsResult.errors && statsResult.errors.length) {
                        _this.logError("'" + outputDir_1 + "':" + os_1.EOL + statsResult.errors.join(os_1.EOL) + os_1.EOL);
                    }
                    if (statsResult.warnings && statsResult.warnings.length) {
                        var unsuppressedWarnings_1 = [];
                        var warningSuppressonRegexes_1 = (_this.taskConfig.suppressWarnings || []).map(function (regex) {
                            return new RegExp(regex);
                        });
                        statsResult.warnings.forEach(function (warning) {
                            var suppressed = false;
                            for (var i = 0; i < warningSuppressonRegexes_1.length; i++) {
                                var suppressionRegex = warningSuppressonRegexes_1[i];
                                if (warning.match(suppressionRegex)) {
                                    suppressed = true;
                                    break;
                                }
                            }
                            if (!suppressed) {
                                unsuppressedWarnings_1.push(warning);
                            }
                        });
                        if (unsuppressedWarnings_1.length > 0) {
                            _this.logWarning("'" + outputDir_1 + "':" + os_1.EOL + unsuppressedWarnings_1.join(os_1.EOL) + os_1.EOL);
                        }
                    }
                    var duration = (new Date().getTime() - startTime_1);
                    var statsResultChildren = statsResult.children ? statsResult.children : [statsResult];
                    statsResultChildren.forEach(function (child) {
                        if (child.chunks) {
                            child.chunks.forEach(function (chunk) {
                                if (chunk.files) {
                                    chunk.files.forEach(function (file) { return (_this.log("Bundled: '" + gutil_1.colors.cyan(path.basename(file)) + "', " +
                                        ("size: " + gutil_1.colors.magenta(chunk.size) + " bytes, ") +
                                        ("took " + gutil_1.colors.magenta(duration) + " ms."))); }); // end file
                                }
                            }); // end chunk
                        }
                    }); // end child
                    completeCallback();
                }); // endwebpack callback
            }
        }
    };
    WebpackTask.prototype._logMissingConfigWarning = function () {
        this.logWarning('No webpack config has been provided. ' +
            'Run again using --initwebpack to create a default config, ' +
            "or call webpack.setConfig({ configPath: null }) in your gulpfile.");
    };
    return WebpackTask;
}(gulp_core_build_1.GulpTask));
exports.WebpackTask = WebpackTask;

//# sourceMappingURL=WebpackTask.js.map
